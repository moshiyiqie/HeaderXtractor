<note>  ??, ??, 1-10 (??)  </note>::line_number::0
<note> c ?? Kluwer Academic Publishers, Boston. Manufactured in The Netherlands.   </note>::line_number::1
<title>  Unifying Two-View and Three-View Geometry   </title>::line_number::2
<author>  SHAI AVIDAN, AMNON SHASHUA   </author>::line_number::3
<email>  favidan,shashuag@cs.huji.ac.il   </email>::line_number::4
<affiliation>  Institute of Computer Science, The Hebrew University,   Jerusalem 91904, Israel   </affiliation>::line_number::5
<note>  Received ??. Revised ??.   </note>::line_number::6
<abstract>  Abstract. The core of multiple-view geometry is governed by the fundamental matrix and the trilinear  </abstract>::line_number::7
<abstract> tensor. In this paper we unify both representations by first re-deriving the fundamental matrix as a rank  </abstract>::line_number::8
<abstract> deficient tensor, and secondly by deriving a unified set of operators that are transparent to the number of  </abstract>::line_number::9
<abstract> views. As a result, we show that the basic building block of the geometry of multiple views is the trilinear  </abstract>::line_number::10
<abstract> tensor of three views and that this tensor specializes to the fundamental matrix (in it's tensor form) in  </abstract>::line_number::11
<abstract> the case of two views. The properties of the tensor (geometric interpretation, contraction properties,  </abstract>::line_number::12
<abstract> etc.) are independent of the number of views (two or three). As a byproduct, every two-view algorithm  </abstract>::line_number::13
<abstract> can be considered as a degenerate three-view algorithm and three-view algorithms can work with either  </abstract>::line_number::14
<abstract> two or three images, all using one standard set of tensor operations. To highlight the usefulness of this  </abstract>::line_number::15
<abstract> paradigm we provide two practical applications. First we present a novel view synthesis algorithm that  </abstract>::line_number::16
<abstract> starts with the fundamental matrix (in its tensor form) and seamlessly move to the general trilinear  </abstract>::line_number::17
<abstract> tensor, all using one set of tensor operations. The second application is a camera stabilization algorithm,  </abstract>::line_number::18
<abstract> originally introduced for three views, now working with two views without modification.   </abstract>::line_number::19
<intro>  1. Introduction  </intro>::line_number::20

<title>  Using Queue Time Predictions for Processor Allocation   </title>::line_number::0
<author>  Allen B. Downey    </author>::line_number::1
<affiliation>  University of California at Berkeley  </affiliation>::line_number::2
<affiliation> San Diego Supercomputer Center   </affiliation>::line_number::3
<abstract>  Abstract  </abstract>::line_number::4
<abstract> When a moldable job is submitted to a space-sharing  </abstract>::line_number::5
<abstract> parallel computer, it must choose whether to begin execution on a small, available cluster or wait in queue for  </abstract>::line_number::6
<abstract> more processors to become available. To make this decision, it must predict how long it will have to wait for  </abstract>::line_number::7
<abstract> the larger cluster. We propose statistical techniques for  </abstract>::line_number::8
<abstract> predicting these queue times, and develop an allocation  </abstract>::line_number::9
<abstract> strategy that uses these predictions. We present a workload model based on observed workloads at the San Diego  </abstract>::line_number::10
<abstract> Supercomputer Center and the Cornell Theory Center,  </abstract>::line_number::11
<abstract> and use this model to drive simulations of various allocation strategies. We find that prediction-based allocation  </abstract>::line_number::12
<abstract> not only improves the turnaround time of individual jobs;  </abstract>::line_number::13
<abstract> it also improves the utilization of the system as a whole.   </abstract>::line_number::14
<intro>  1 Introduction  </intro>::line_number::15

<title>  Measure, Stochasticity, and the Density   </title>::line_number::0
<title> of Hard Languages   </title>::line_number::1
<pubnum>  TR 92-13   </pubnum>::line_number::2
<author>  Jack H. Lutz and Elvira Mayordomo   </author>::line_number::3
<date>  May 1992   </date>::line_number::4
<affiliation>  Iowa State University of Science and Technology  </affiliation>::line_number::5
<affiliation> Department of Computer Science   </affiliation>::line_number::6
<address>  226 Atanasoff  </address>::line_number::7
<address> Ames, IA 50011   </address>::line_number::8
<page>  +PAGE+  </page>::line_number::9

<title>  An Executable Semantics for a   </title>::line_number::0
<title> Formalized Data Flow Diagram   </title>::line_number::1
<title> Specification Language   </title>::line_number::2
<pubnum>  TR93-27   </pubnum>::line_number::3
<author>  Tim Wahls, Albert L. Baker, and Gary T. Leavens   </author>::line_number::4
<date>  November 15, 1993   </date>::line_number::5
<affiliation>  Iowa State University of Science and Technology  </affiliation>::line_number::6
<affiliation> Department of Computer Science   </affiliation>::line_number::7
<address>  226 Atanasoff  </address>::line_number::8
<address> Ames, IA 50011   </address>::line_number::9
<page>  +PAGE+  </page>::line_number::10

<title>  Coordination and Control Structures and Processes:  </title>::line_number::0
<title> Possibilities for Connectionist Networks (CN)   </title>::line_number::1
<author>  Vasant Honavar & Leonard Uhr   </author>::line_number::2
<affiliation>  Computer Sciences Department  </affiliation>::line_number::3
<affiliation> University of Wisconsin-Madison   </affiliation>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> The absence of powerful control structures and processes that synchronize, coordinate, switch between, choose among, regulate, direct, modulate interactions between, and  </abstract>::line_number::6
<abstract> combine distinct yet interdependent modules of large connectionist networks (CN) is  </abstract>::line_number::7
<abstract> probably one of the most important reasons why such networks have not yet succeeded at  </abstract>::line_number::8
<abstract> handling difficult tasks (e.g. complex object recognition and description, complex  </abstract>::line_number::9
<abstract> problem-solving, planning).  </abstract>::line_number::10
<abstract> In this paper we examine how CN built from large numbers of relatively simple  </abstract>::line_number::11
<abstract> neuron-like units can be given the ability to handle problems that in typical multi-computer networks and artificial intelligence programs along with all other types of  </abstract>::line_number::12
<abstract> programs are always handled using extremely elaborate and precisely worked out central control (coordination, synchronization, switching, etc.). We point out the several  </abstract>::line_number::13
<abstract> mechanisms for central control of this un-brain-like sort that CN already have built into  </abstract>::line_number::14
<abstract> them albeit in hidden, often overlooked, ways.  </abstract>::line_number::15
<abstract> We examine the kinds of control mechanisms found in computers, programs, fetal  </abstract>::line_number::16
<abstract> development, cellular function and the immune system, evolution, social organizations,  </abstract>::line_number::17
<abstract> and especially brains, that might be of use in CN. Particularly intriguing suggestions are  </abstract>::line_number::18
<abstract> found in the pacemakers, oscillators, and other local sources of the brain's complex partial synchronies; the diffuse, global effects of slow electrical waves and neurohormones;  </abstract>::line_number::19
<abstract> the developmental program that guides fetal development; communication and coordination within and among living cells; the working of the immune system; the evolutionary  </abstract>::line_number::20
<abstract> processes that operate on large populations of organisms; and the great variety of partially competing partially cooperating controls found in small groups, organizations, and  </abstract>::line_number::21
<abstract> larger societies. All these systems are rich in control but typically control that emerges  </abstract>::line_number::22
<abstract> from complex interactions of many local and diffuse sources. We explore how several  </abstract>::line_number::23
<abstract> different kinds of plausible control mechanisms might be incorporated into CN, and  </abstract>::line_number::24
<abstract> assess their potential benefits with respect to their cost.   </abstract>::line_number::25
<intro>  Introduction  </intro>::line_number::26

<title>  1 FEATURE SUBSET SELECTION USING A  </title>::line_number::0
<title> GENETIC ALGORITHM   </title>::line_number::1
<author>  Jihoon Yang and Vasant Honavar   </author>::line_number::2
<affiliation>  Artificial Intelligence Research Group  </affiliation>::line_number::3
<affiliation> Department of Computer Science   </affiliation>::line_number::4
<address>  226 Atanasoff Hall   </address>::line_number::5
<affiliation>  Iowa State University   </affiliation>::line_number::6
<address>  Ames, IA 50011  </address>::line_number::7
<address> U.S.A.   </address>::line_number::8
<email>  yangjhonavar-@cs.iastate.edu   </email>::line_number::9
<abstract>  Abstract: Practical pattern classification and knowledge discovery problems require selection of a  </abstract>::line_number::10
<abstract> subset of attributes or features (from a much larger set) to represent the patterns to be classified.  </abstract>::line_number::11
<abstract> This is due to the fact that the performance of the classifier (usually induced by some learning  </abstract>::line_number::12
<abstract> algorithm) and the cost of classification are sensitive to the choice of the features used to construct  </abstract>::line_number::13
<abstract> the classifier. Exhaustive evaluation of possible feature subsets is usually infeasible in practice because  </abstract>::line_number::14
<abstract> of the large amount of computational effort required. Genetic algorithms, which belong to a class of  </abstract>::line_number::15
<abstract> randomized heuristic search techniques, offer an attractive approach to find near-optimal solutions  </abstract>::line_number::16
<abstract> to such optimization problems. This paper presents an approach to feature subset selection using a  </abstract>::line_number::17
<abstract> genetic algorithm. Some advantages of this approach include the ability to accommodate multiple  </abstract>::line_number::18
<abstract> criteria such as accuracy and cost of classification into the feature selection process and to find feature  </abstract>::line_number::19
<abstract> subsets that perform well for particular choices of the inductive learning algorithm used to construct  </abstract>::line_number::20
<abstract> the pattern classifier. Our experiments with several benchmark real-world pattern classification  </abstract>::line_number::21
<abstract> problems demonstrate the feasibility of this approach to feature subset selection in the automated  </abstract>::line_number::22
<abstract> design of neural networks for pattern classification and knowledge discovery.   </abstract>::line_number::23
<intro>  1.1 INTRODUCTION  </intro>::line_number::24

<title>  EFFICIENT COMPILATION AND PROFILE-DRIVEN  </title>::line_number::0
<title> DYNAMIC RECOMPILATION IN SCHEME   </title>::line_number::1
<author>  Robert G. Burger   </author>::line_number::2
<degree>  Submitted to the faculty of the University Graduate School  </degree>::line_number::3
<degree> in partial fulfillment of the requirements  </degree>::line_number::4
<degree> for the degree  </degree>::line_number::5
<degree> Doctor of Philosophy  </degree>::line_number::6
<affiliation> in the   Department of Computer Science,  </affiliation>::line_number::7
<affiliation> Indiana University   </affiliation>::line_number::8
<date>  March 1997   </date>::line_number::9
<page>  +PAGE+  </page>::line_number::10

<title>  Compiler Construction Using Scheme   </title>::line_number::0
<author>  Erik Hilsdale J. Michael Ashley  </author>::line_number::1
<author> R. Kent Dybvig Daniel P. Friedman   </author>::line_number::2
<affiliation>  Indiana University Computer Science Department   </affiliation>::line_number::3
<address>  Lindley Hall 215  </address>::line_number::4
<address> Bloomington, Indiana 47405   </address>::line_number::5
<email>  fehilsdal,jashley,dyb,dfried g@cs.indiana.edu   </email>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> This paper describes a course in compiler design that focuses on the  </abstract>::line_number::8
<abstract> Scheme implementation of a Scheme compiler that generates native assembly code for a real architecture. The course is suitable for advanced  </abstract>::line_number::9
<abstract> undergraduate and beginning graduate students. It is intended both to  </abstract>::line_number::10
<abstract> provide a general knowledge about compiler design and implementation  </abstract>::line_number::11
<abstract> and to serve as a springboard to more advanced courses. Although this  </abstract>::line_number::12
<abstract> paper concentrates on the implementation of a compiler, an outline for an  </abstract>::line_number::13
<abstract> advanced topics course that builds upon the compiler is also presented.   </abstract>::line_number::14
<intro>  1 Introduction  </intro>::line_number::15

<title>  Using Goals and Experience to Guide Abduction   </title>::line_number::0
<author>  David B. Leake   </author>::line_number::1
<email>  leake@cs.indiana.edu   </email>::line_number::2
<pubnum>  Technical Report #359   </pubnum>::line_number::3
<affiliation>  Department of Computer Science, Indiana University   </affiliation>::line_number::4
<address>  Lindley Hall 215, Bloomington, IN 47405   </address>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Standard methods for abductive understanding are neutral to prior experience and current goals.  </abstract>::line_number::7
<abstract> Candidate explanations are built from scratch by backwards chaining, without considering how  </abstract>::line_number::8
<abstract> similar situations were previously explained, and selection of the candidate to accept is based on its  </abstract>::line_number::9
<abstract> likelihood, without considering the information needs beyond routine understanding. Problems arise  </abstract>::line_number::10
<abstract> when applying these methods to everyday understanding: The vast range of possible explanations  </abstract>::line_number::11
<abstract> makes it difficult to control the cost of explanation construction and to assure that the explanations  </abstract>::line_number::12
<abstract> generated will actually be useful.  </abstract>::line_number::13
<abstract> We argue that these problems can be overcome by using goals and experience to guide both  </abstract>::line_number::14
<abstract> explanation generation and evaluation. Our work is within the framework of case-based explanation, which builds explanations by retrieving and adapting prior explanations stored in memory.  </abstract>::line_number::15
<abstract> We substantiate our model by describing mechanisms that enable it to effectively generate good  </abstract>::line_number::16
<abstract> explanations. First, we demonstrate that there exists a theory of anomaly and explanation that can  </abstract>::line_number::17
<abstract> guide retrieval of relevant explanations. Second, we present a plausibility evaluation process that  </abstract>::line_number::18
<abstract> efficiently detects conflicts and confirmations of an explanation's assumptions by prior patterns,  </abstract>::line_number::19
<abstract> making it possible to focus explanation adaptation when retrieved explanations are implausible.  </abstract>::line_number::20
<abstract> Third, we present methods for judging whether explanations provide the information needed to satisfy explainer goals beyond routine understanding. By reflecting experience and goals in the search  </abstract>::line_number::21
<abstract> for explanations, case-based explanation provides a practical mechanism for guiding search towards  </abstract>::line_number::22
<abstract> explanations that are both plausible and useful.   </abstract>::line_number::23
<note>  1 The work described here was supported in part by the Defense Advanced Research Projects Agency,  </note>::line_number::24

<title>  Toward the Rigorous Use of  </title>::line_number::0
<title> Diagrams in Reasoning about  </title>::line_number::1
<title> Hardware   </title>::line_number::2
<author>  Steven D. Johnson   sjohnson@indiana.edu   Department of Computer Science Indiana University   </author>::line_number::3
<author>  Jon Barwise   </author>::line_number::4
<email>  barwise@indiana.edu   </email>::line_number::5
<affiliation>  Departments of Philosophy, Mathematics, and Computer Science  </affiliation>::line_number::6
<affiliation> Indiana University   </affiliation>::line_number::7
<author>  Gerard T. Allwein   </author>::line_number::8
<affiliation>  Visual Inference Laboratory  </affiliation>::line_number::9
<affiliation> Indiana University  </affiliation>::line_number::10
<affiliation> Indiana University Logic Group   </affiliation>::line_number::11
<pubnum>  Preprint No. IULG-93-23   </pubnum>::line_number::12
<date>  May 1993   </date>::line_number::13
<page>  +PAGE+  </page>::line_number::14

<note>  Proceedings of the Fifteenth International Joint Conference on Artificial Intelligence, Morgan Kaufmann, San Francisco, 1997.   </note>::line_number::0
<title>  Learning to Integrate Multiple Knowledge Sources  </title>::line_number::1
<title> for Case-Based Reasoning   </title>::line_number::2
<author>  David B. Leake, Andrew Kinley, and David Wilson   </author>::line_number::3
<affiliation>  Computer Science Department   </affiliation>::line_number::4
<address>  Lindley Hall 215,   Indiana University   </address>::line_number::5
<address>  Bloomington, IN 47405, U.S.A.   </address>::line_number::6
<email>  fleake, akinley, davwilsg@cs.indiana.edu   </email>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> The case-based reasoning process depends on  </abstract>::line_number::9
<abstract> multiple overlapping knowledge sources, each  </abstract>::line_number::10
<abstract> of which provides an opportunity for learning. Exploiting these opportunities requires  </abstract>::line_number::11
<abstract> not only determining the learning mechanisms  </abstract>::line_number::12
<abstract> to use for each individual knowledge source,  </abstract>::line_number::13
<abstract> but also how the different learning mechanisms interact and their combined utility. This  </abstract>::line_number::14
<abstract> paper presents a case study examining the  </abstract>::line_number::15
<abstract> relative contributions and costs involved in  </abstract>::line_number::16
<abstract> learning processes for three different knowledge sources|cases, case adaptation knowledge, and similarity information|in a case-based planner. It demonstrates the importance  </abstract>::line_number::17
<abstract> of interactions between different learning processes and identifies a promising method for integrating multiple learning methods to improve  </abstract>::line_number::18
<abstract> case-based reasoning.   </abstract>::line_number::19
<intro>  1 Introduction  </intro>::line_number::20

<title>  A Ray Tracing Method for Illumination Calculation in  </title>::line_number::0
<title> Diffuse-Specular Scenes   </title>::line_number::1
<author>  Peter Shirley   </author>::line_number::2
<affiliation>  Department of Computer Science  </affiliation>::line_number::3
<affiliation> University of Illinois   </affiliation>::line_number::4
<address>  1304 West Springfield Avenue  </address>::line_number::5
<address> Urbana, Illinois 61801  </address>::line_number::6
<address> USA   </address>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> Several ways of improving the realism of the results  </abstract>::line_number::9
<abstract> of traditional ray tracing are presented. The essential physical quantities of spectral radiant power and  </abstract>::line_number::10
<abstract> spectral radiance and their use in lighting calculations  </abstract>::line_number::11
<abstract> are discussed. Global illumination terms are derived  </abstract>::line_number::12
<abstract> by employing illumination ray tracing for calculation of  </abstract>::line_number::13
<abstract> quickly changing indirect lighting components, and ra-diosity ray tracing for slowly changing indirect lighting  </abstract>::line_number::14
<abstract> components. Direct lighting is calculated during the  </abstract>::line_number::15
<abstract> viewing phase allowing the use of bump maps. Finally,  </abstract>::line_number::16
<abstract> a method is introduced that reduces the total number  </abstract>::line_number::17
<abstract> of shadow rays to no more than the total number of  </abstract>::line_number::18
<abstract> viewing rays for a given picture.   </abstract>::line_number::19
<keyword>  Keywords: Bump Mapping, Illumination, Radiosity,  </keyword>::line_number::20
<keyword> Radiance, Ray Tracing, Realism, Stratified Sampling,  </keyword>::line_number::21
<keyword> Texture Mapping.   </keyword>::line_number::22
<intro>  1 Introduction  </intro>::line_number::23

<title>  3-D Stereo Using Photometric Ratios   </title>::line_number::0
<author>  Lawrence B. Wolff  </author>::line_number::1
<author> Elli Angelopoulou   </author>::line_number::2
<affiliation>  Computer Vision Laboratory  </affiliation>::line_number::3
<affiliation> Department of Computer Science  </affiliation>::line_number::4
<affiliation> The Johns Hopkins University   </affiliation>::line_number::5
<address>  Baltimore, MD 21218   </address>::line_number::6
<abstract>  ABSTRACT  </abstract>::line_number::7
<abstract> We present a novel robust methodology for corresponding a dense set of points on an  </abstract>::line_number::8
<abstract> object surface from photometric values, for 3-D stereo computation of depth. The methodology utilizes multiple stereo pairs of images, each stereo pair taken of exactly the same  </abstract>::line_number::9
<abstract> scene but under different illumination. With just 2 stereo pairs of images taken respectively for 2 different illumination conditions, a stereo pair of ratio images can be produced; one for the ratio of left images, and one for the ratio of right images. We  </abstract>::line_number::10
<abstract> demonstrate how the photometric ratios composing these images can be used for accurate  </abstract>::line_number::11
<abstract> correspondence of object points. Object points having the same photometric ratio with  </abstract>::line_number::12
<abstract> respect to 2 different illumination conditions comprise a well-defined equivalence class of  </abstract>::line_number::13
<abstract> physical constraints defined by local surface orientation relative to illumination conditions. We formally show that for diffuse reection the photometric ratio is invariant to  </abstract>::line_number::14
<abstract> varying camera characteristics, surface albedo, and viewpoint and that therefore the same  </abstract>::line_number::15
<abstract> photometric ratio in both images of a stereo pair implies the same equivalence class of  </abstract>::line_number::16
<abstract> physical constraints. Corresponding photometric ratios along epipolar lines in a stereo pair  </abstract>::line_number::17
<abstract> of images under different illumination conditions is therefore a robust correspondence of  </abstract>::line_number::18
<abstract> equivalent physical constraints, and determination of depth from stereo can be performed  </abstract>::line_number::19
<abstract> without explicitly knowing what these physical constraints being corresponded actually  </abstract>::line_number::20
<abstract> are. This implies a very practical shape-from-stereo methodology applicable to perspective views and not requiring any knowledge whatsoever of illumination conditions. This is  </abstract>::line_number::21
<abstract> particularly practical for determination of 3-D shape on smooth featureless surfaces which  </abstract>::line_number::22
<abstract> has previously been hard to perform using stereo. We demonstrate experimental 3-D shape  </abstract>::line_number::23
<abstract> determination from a dense set of points using our stereo technique on smooth objects of  </abstract>::line_number::24
<abstract> known ground truth shape that are accurate to well within 1% depth accuracy.   </abstract>::line_number::25
<page>  +PAGE+  </page>::line_number::26

<note>  IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE, VOL. 17, NO. 6, JUNE 1995 599   </note>::line_number::0
<title>  Best-Case Results for Nearest Neighbor  </title>::line_number::1
<title> Learning   </title>::line_number::2
<author>  Steven Salzberg, Arthur Delcher, David Heath, and Simon Kasif   </author>::line_number::3
<abstract>  Abstract| In this paper we propose a theoretical model  </abstract>::line_number::4
<abstract> for analysis of classification methods, in which the teacher  </abstract>::line_number::5
<abstract> knows the classification algorithm and chooses examples in  </abstract>::line_number::6
<abstract> the best way possible. We apply this model using the nearest-neighbor learning algorithm, and develop upper and lower  </abstract>::line_number::7
<abstract> bounds on sample complexity for several different concept  </abstract>::line_number::8
<abstract> classes. For some concept classes, the sample complexity  </abstract>::line_number::9
<abstract> turns out to be exponential even using this best-case model,  </abstract>::line_number::10
<abstract> which implies that the concept class is inherently difficult  </abstract>::line_number::11
<abstract> for the nearest-neighbor algorithm. We identify several geometric properties that make learning certain concepts relatively easy. Finally we discuss the relation of our work  </abstract>::line_number::12
<abstract> to helpful teacher models, its application to decision-tree  </abstract>::line_number::13
<abstract> learning algorithms, and some of its implications for current experimental work.   </abstract>::line_number::14
<keyword>  Keywords| machine learning, nearest-neighbor, geometric  </keyword>::line_number::15
<keyword> concepts.   </keyword>::line_number::16
<intro>  I. Introduction  </intro>::line_number::17

<title>  Deterministic Sorting  </title>::line_number::0
<title> in Nearly Logarithmic Time  </title>::line_number::1
<title> on the Hypercube  </title>::line_number::2
<title> and Related Computers   </title>::line_number::3
<author>  Robert Cypher   </author>::line_number::4
<affiliation>  IBM Almaden Research Center   </affiliation>::line_number::5
<address>  650 Harry Rd.  </address>::line_number::6
<address> San Jose, CA 95120   </address>::line_number::7
<author>  C. Greg Plaxton    </author>::line_number::8
<affiliation>  MIT Laboratory for Computer Science   </affiliation>::line_number::9
<address>  545 Technology Square  </address>::line_number::10
<address> Cambridge, MA 02139   </address>::line_number::11
<date>  November 29, 1995   </date>::line_number::12
<abstract>  Abstract  </abstract>::line_number::13
<abstract> This paper presents a deterministic sorting algorithm, called Sharesort, that sorts n  </abstract>::line_number::14
<abstract> records on an n-processor hypercube, shu*e-exchange, or cube-connected cycles in  </abstract>::line_number::15
<abstract> O(log n (log log n) 2 ) time in the worst case. The algorithm requires only a constant  </abstract>::line_number::16
<abstract> amount of storage at each processor. The fastest previous deterministic algorithm for  </abstract>::line_number::17
<abstract> this problem was Batcher's bitonic sort, which runs in O(log 2 n) time.   </abstract>::line_number::18
<note>  Supported by an NSERC postdoctoral fellowship, and DARPA contracts N00014-87-K-825 and N00014  </note>::line_number::19
<note> 89-J-1988.   </note>::line_number::20
<page>  +PAGE+  </page>::line_number::21

<note>  Appears in Machine Learning: Proceedings of the Tenth International Conference,  </note>::line_number::0
<note> P. E. Utgoff (editor), Morgan Kaufmann, San Mateo, CA, 1993   </note>::line_number::1
<title>  Learning Symbolic Rules Using Artificial Neural Networks   </title>::line_number::2
<author>  Mark W. Craven and Jude W. Shavlik   </author>::line_number::3
<affiliation>  Computer Sciences Department  </affiliation>::line_number::4
<affiliation> University of Wisconsin   </affiliation>::line_number::5
<address>  1210 West Dayton St.  </address>::line_number::6
<address> Madison, WI 53706   </address>::line_number::7
<email>  email: fcraven, shavlikg@cs.wisc.edu   </email>::line_number::8
<abstract>  Abstract  </abstract>::line_number::9
<abstract> A distinct advantage of symbolic learning  </abstract>::line_number::10
<abstract> algorithms over artificial neural networks is  </abstract>::line_number::11
<abstract> that typically the concept representations  </abstract>::line_number::12
<abstract> they form are more easily understood by humans. One approach to understanding the  </abstract>::line_number::13
<abstract> representations formed by neural networks is  </abstract>::line_number::14
<abstract> to extract symbolic rules from trained networks. In this paper we describe and investigate an approach for extracting rules from  </abstract>::line_number::15
<abstract> networks that uses (1) the NofM extraction algorithm, and (2) the network training  </abstract>::line_number::16
<abstract> method of soft weight-sharing. Previously,  </abstract>::line_number::17
<abstract> the NofM algorithm had been successfully  </abstract>::line_number::18
<abstract> applied only to knowledge-based neural networks. Our experiments demonstrate that  </abstract>::line_number::19
<abstract> our extracted rules generalize better than  </abstract>::line_number::20
<abstract> rules learned using the C4.5 system. In addition to being accurate, our extracted rules  </abstract>::line_number::21
<abstract> are also reasonably comprehensible.   </abstract>::line_number::22
<intro>  1 INTRODUCTION  </intro>::line_number::23

<title>  The Royal Tree Problem, a Benchmark for Single and  </title>::line_number::0
<title> Multi-population Genetic Programming   </title>::line_number::1
<note>  appears in "Advances in Genetic Programming II", MIT Press, Pete Angeline and  </note>::line_number::2
<note> Kim Kinnear, editors   </note>::line_number::3
<author>  Bill Punch, Doug Zongker, and Erik Goodman   </author>::line_number::4
<abstract>  We report on work done to develop a benchmark problem for genetic programming, both  </abstract>::line_number::5
<abstract> as a difficult problem to test GP abilities and as a platform for tuning GP parameters.  </abstract>::line_number::6
<abstract> This benchmark, the royal tree, is a function that accounts for tree shape as part of its  </abstract>::line_number::7
<abstract> evaluation function, thus it controls for a parameter not often found in the GP literature.  </abstract>::line_number::8
<abstract> It also is a progressive function, allowing the user to set the difficulty of the problem  </abstract>::line_number::9
<abstract> attempted. We not only describe the function, but also report on results of using island  </abstract>::line_number::10
<abstract> parallelism for solving GP problems. The results obtained are somewhat surprising, as it  </abstract>::line_number::11
<abstract> appears that a single large population outperforms a group of smaller populations under  </abstract>::line_number::12
<abstract> all the conditions tested.   </abstract>::line_number::13
<intro>  15.1 Introduction  </intro>::line_number::14

<title>  A Perspective on Word Sense Disambiguation Methods  </title>::line_number::0
<title> and Their Evaluation   </title>::line_number::1
<author>  Philip Resnik   </author>::line_number::2
<affiliation>  Dept. of Linguistics/UMIACS  </affiliation>::line_number::3
<affiliation> University of Maryland   </affiliation>::line_number::4
<address>  College Park, MD 20742   </address>::line_number::5
<email>  resnik@umiacs.umd.edu   </email>::line_number::6
<author>  David Yarowsky   </author>::line_number::7
<affiliation>  Dept. of Computer Science/CLSP  </affiliation>::line_number::8
<affiliation> Johns Hopkins University   </affiliation>::line_number::9
<address>  Baltimore, MD 21218   </address>::line_number::10
<email>  yarowsky@cs.jhu.edu   </email>::line_number::11
<abstract>  Abstract  </abstract>::line_number::12
<abstract> In this position paper, we make several  </abstract>::line_number::13
<abstract> observations about the state of the art in  </abstract>::line_number::14
<abstract> automatic word sense disambiguation. Motivated by these observations, we offer several specific proposals to the community regarding improved evaluation criteria, common training and testing resources, and the  </abstract>::line_number::15
<abstract> definition of sense inventories.   </abstract>::line_number::16
<intro>  1 Introduction  </intro>::line_number::17

<title>  Inductive Constraint Logic  </title>::line_number::0
<title> and the Mutagenesis Problem   </title>::line_number::1
<author>  Wim Van Laer Hendrik Blockeel  </author>::line_number::2
<author> Luc De Raedt   </author>::line_number::3
<affiliation>  Department of Computer Science, Katholieke Universiteit Leuven   </affiliation>::line_number::4
<address>  Celestijnenlaan 200A, B-3001 Heverlee, Belgium   </address>::line_number::5
<email>  Email:fWimV,Hendrik,LucDRg@cs.kuleuven.ac.be   </email>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> A novel approach to learning first order logic formulae from positive and negative examples is incorporated in a system named ICL (Inductive Constraint  </abstract>::line_number::8
<abstract> Logic). In ICL, examples are viewed as interpretations which are true or false  </abstract>::line_number::9
<abstract> for the target theory, whereas in present inductive logic programming systems,  </abstract>::line_number::10
<abstract> examples are true and false ground facts (or clauses). Furthermore, ICL uses a  </abstract>::line_number::11
<abstract> clausal representation, which corresponds to a conjunctive normal form where  </abstract>::line_number::12
<abstract> each conjunct forms a constraint on positive examples, whereas classical learning  </abstract>::line_number::13
<abstract> techniques have concentrated on concept representations in disjunctive normal  </abstract>::line_number::14
<abstract> form.  </abstract>::line_number::15
<abstract> We present some experiments with this new system on the mutagenesis problem. These experiments illustrate some of the differences with other systems,  </abstract>::line_number::16
<abstract> and indicate that our approach should work at least as well as the more classical  </abstract>::line_number::17
<abstract> approaches.   </abstract>::line_number::18
<intro>  1 Introduction  </intro>::line_number::19

<title>  Model-guided Segmentation of Corpus Callosum in MR Images   </title>::line_number::0
<author>  Arvid Lundervold 1 , Nicolae Duta 2 , Torfinn Taxt 1 & Anil K. Jain 2   </author>::line_number::1
<affiliation>  1 Section for Medical Image Analysis and Informatics, Department of Physiology   </affiliation>::line_number::2
<affiliation>  University of Bergen,   Arstadveien 19, N-5009 Bergen, Norway   </affiliation>::line_number::3
<affiliation>  2 Department of Computer Science and Engineering, Michigan State University   </affiliation>::line_number::4
<address>  East Lansing, MI 48824-1226, USA   </address>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Magnetic resonance imaging (MRI) of the brain, followed by automated segmentation of the corpus callosum  </abstract>::line_number::7
<abstract> (CC) in midsagittal sections have important applications  </abstract>::line_number::8
<abstract> in both clinical neurology and neurocognitive research  </abstract>::line_number::9
<abstract> since the size and shape of the CC are shown to be correlated to sex, age, neurodegenerative diseases and various lateralized behavior in man. Moreover, whole head,  </abstract>::line_number::10
<abstract> multispectral 3D MRI recordings enable voxel-based tissue classification and estimation of total brain volumes,  </abstract>::line_number::11
<abstract> in addition to CC morphometric parameters. We propose  </abstract>::line_number::12
<abstract> a new algorithm that uses both multispectral MRI measurements (intensity values) and prior information about  </abstract>::line_number::13
<abstract> shape (CC template) to segment CC in midsagittal slices  </abstract>::line_number::14
<abstract> with very little user interaction. The algorithm has been  </abstract>::line_number::15
<abstract> tested on a sample of 10 subjects scanned with multispec-tral 3D MRI, collected for a study of dyslexia, with very  </abstract>::line_number::16
<abstract> good agreement between the manually traced (true) CC  </abstract>::line_number::17
<abstract> outline and the detected CC outline. We conclude that  </abstract>::line_number::18
<abstract> the proposed method for CC segmentation is promising for  </abstract>::line_number::19
<abstract> clinical use when multispectral MR images are recorded.   </abstract>::line_number::20
<intro>  1 Introduction  </intro>::line_number::21

<title>  Statistical Characteristics and Multiplexing of MPEG Streams   </title>::line_number::0
<author>  Marwan Krunz , Ron Sass , and Herman Hughes    </author>::line_number::1
<affiliation>  Department of Electrical Engineering  </affiliation>::line_number::2
<affiliation> Department of Computer Science  </affiliation>::line_number::3
<affiliation> Michigan State University   </affiliation>::line_number::4
<address>  East Lansing, MI 48824   </address>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> This paper presents a study of the statistical characteristics and multiplexing of Variable-Bit-Rate (VBR)  </abstract>::line_number::7
<abstract> MPEG-coded video streams. Our results are based on  </abstract>::line_number::8
<abstract> 23 minutes of video obtained from the entertainment  </abstract>::line_number::9
<abstract> movie, The Wizard of Oz. The experimental setup  </abstract>::line_number::10
<abstract> which was used to capture, digitize, and compress the  </abstract>::line_number::11
<abstract> video stream is described. Although the study is conducted at the frame level (as opposed to the slice level),  </abstract>::line_number::12
<abstract> it is observed that the inter-frame correlation structure for the frame-size sequence involves complicated  </abstract>::line_number::13
<abstract> forms of pseudo-periodicity that are mainly affected  </abstract>::line_number::14
<abstract> by the compression pattern of the sequence. A simple model for an MPEG traffic source is developed in  </abstract>::line_number::15
<abstract> which frames are generated according to the compression pattern of the original captured video stream. The  </abstract>::line_number::16
<abstract> number of cells per frame is fitted by a lognormal distribution. Simulations are used to study the performance of an ATM multiplexer for MPEG streams.   </abstract>::line_number::17
<intro>  1 Introduction  </intro>::line_number::18

<title>  Aditi-Prolog language manual +L + </title>::line_number::0
<author>  James Harland  </author>::line_number::1
<author> David B. Kemp  </author>::line_number::2
<author> Tim S. Leask  </author>::line_number::3
<author> Kotagiri Ramamohanarao  </author>::line_number::4
<author> John A. Shepherd  </author>::line_number::5
<author> Zoltan Somogyi  </author>::line_number::6
<author> Peter J. Stuckey  </author>::line_number::7
<author> Jayen Vaghani   </author>::line_number::8
<abstract>  Abstract  </abstract>::line_number::9
<abstract> Aditi is a deductive database system under development at the Collaborative Information  </abstract>::line_number::10
<abstract> Technology Research Institute by researchers from the University of Melbourne. The main  </abstract>::line_number::11
<abstract> language in which users interact with Aditi is Aditi-Prolog. This document is a reference  </abstract>::line_number::12
<abstract> manual for Aditi-Prolog.   </abstract>::line_number::13
<intro>  1 Introduction  </intro>::line_number::14

<title>  An Agent-Based Approach  </title>::line_number::0
<title> for Robot Vision System   </title>::line_number::1
<pubnum>  Technical Report 95/34   </pubnum>::line_number::2
<author>  Tak Keung CHENG  </author>::line_number::3
<author> Leslie KITCHEN  </author>::line_number::4
<author> Zhi-Qiang LIU  </author>::line_number::5
<author> James COOPER   </author>::line_number::6
<page>  +PAGE+  </page>::line_number::7

<title>  Agents for Citation Finding  </title>::line_number::0
<title> on the World Wide Web   </title>::line_number::1
<author>  Yi Han, Seng Wai Loke, Leon Sterling   </author>::line_number::2
<pubnum>  Technical Report 96/40   </pubnum>::line_number::3
<affiliation>  Department of Computer Science  </affiliation>::line_number::4
<affiliation> The University of Melbourne   </affiliation>::line_number::5
<address>  Parkville, Victoria 3052  </address>::line_number::6
<address> Australia   </address>::line_number::7
<page>  +PAGE+  </page>::line_number::8

<title>  Termination Analysis for Mercury   </title>::line_number::0
<author>  Chris Speirs, Zoltan Somogyi and Harald Stndergaard   </author>::line_number::1
<affiliation>  Department of Computer Science  </affiliation>::line_number::2
<affiliation> The University of Melbourne   </affiliation>::line_number::3
<address>  Parkville, Victoria 3052, Australia   </address>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> Since the late eighties, much progress has been made in the theory of termination analysis for  </abstract>::line_number::6
<abstract> logic programs. However, from a practical point of view, the significance of much of the work  </abstract>::line_number::7
<abstract> on termination is hard to judge, since experimental evaluations rarely get published. Here we  </abstract>::line_number::8
<abstract> describe and evaluate a termination analyzer for Mercury, a strongly typed and moded logic-  </abstract>::line_number::9
<abstract> functional programming language. Mercury's high degree of referential transparency and the  </abstract>::line_number::10
<abstract> guaranteed availability of reliable mode information simplify the termination analysis of Mer-  </abstract>::line_number::11
<abstract> cury compared with that of other logic programming languages. We describe our termination  </abstract>::line_number::12
<abstract> analyzer, which uses a variant of a method developed by Plumer. It deals with full Mercury,  </abstract>::line_number::13
<abstract> including modules, declarative input/output, the foreign language interface, and higher-order  </abstract>::line_number::14
<abstract> features. In spite of these obstacles, it produces high-quality termination information, comparable to the results recently obtained by Lindenstrauss and Sagiv. Most important, in stark  </abstract>::line_number::15
<abstract> contrast with Lindenstrauss and Sagiv's experimental results, our analyzer has a negligible  </abstract>::line_number::16
<abstract> impact on the running time of the compiler of which it is part, even for large programs. This  </abstract>::line_number::17
<abstract> means that the Mercury compiler can produce valuable termination information at no real  </abstract>::line_number::18
<abstract> cost to the programmer.   </abstract>::line_number::19
<intro>  1 Introduction  </intro>::line_number::20

<title>  Mixed Semidefinite-Quadratic-Linear Programs   </title>::line_number::0
<author>  Jean-Pierre Haeberly Madhu V. Nayakkankuppam   </author>::line_number::1
<author> Michael L. Overton    </author>::line_number::2
<date>  September 23, 1998   </date>::line_number::3
<abstract>  Abstract  </abstract>::line_number::4
<abstract> We consider mixed semidefinite-quadratic-linear programs. These are  </abstract>::line_number::5
<abstract> linear optimization problems with three kinds of cone constraints, namely:  </abstract>::line_number::6
<abstract> the semidefinite cone, the quadratic cone and the nonnegative orthant. We  </abstract>::line_number::7
<abstract> outline a primal-dual path following method to solve these problems and  </abstract>::line_number::8
<abstract> highlight the main features of SDPpack, a Matlab package which solves  </abstract>::line_number::9
<abstract> such programs. We give some examples where such mixed programs arise,  </abstract>::line_number::10
<abstract> and provide numerical results on benchmark problems.   </abstract>::line_number::11
<intro>  1 Introduction  </intro>::line_number::12

<title>  Methods for Handling Faults and Asynchrony  </title>::line_number::0
<title> in Parallel Computation    </title>::line_number::1
<author>  Z. M. Kedem    </author>::line_number::2
<intro>  1. Introduction and Motivation  </intro>::line_number::3

<title>  Toward the Automation of the Card-Playing  </title>::line_number::0
<title> Component of Bridge   </title>::line_number::1
<author>  Ming-Sheng Chang   </author>::line_number::2
<affiliation>  Department of Computer Science  </affiliation>::line_number::3
<affiliation> Courant Institute of Mathematical Sciences  </affiliation>::line_number::4
<affiliation> New York University   </affiliation>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> In comparision with other games, particularly chess, the research in computer bridge is  </abstract>::line_number::7
<abstract> immature, and the best bridge-playing programs are mediocre. We propose to study the  </abstract>::line_number::8
<abstract> automation of the card-playing segment of bridge (omitting bidding), using a number of  </abstract>::line_number::9
<abstract> different techniques. In this paper we first give an introduction to the state of computer  </abstract>::line_number::10
<abstract> bridge. Next, we propose two possible architectures for solving double-dummy bridge  </abstract>::line_number::11
<abstract> (i.e., a simplified bridge game with perfect information): The first is based on the  </abstract>::line_number::12
<abstract> combination of And-OR search and heuristic evaluation. The second forms a global plan  </abstract>::line_number::13
<abstract> by merging subplans for each individual suit. Next, to deal with uncertain information in  </abstract>::line_number::14
<abstract> real bridge, we present a new mechanism that combines the concepts of both minimax  </abstract>::line_number::15
<abstract> search and possible worlds. Finally we give a brief description of further work toward  </abstract>::line_number::16
<abstract> automating card-playing in real bridge.   </abstract>::line_number::17
<intro>  1 Introduction  </intro>::line_number::18

<title>  The Development of the C Language   </title>::line_number::0
<author>  Dennis M. Ritchie   </author>::line_number::1
<affiliation>  AT&T Bell Laboratories   </affiliation>::line_number::2
<address>  Murray Hill, NJ 07974 USA   </address>::line_number::3
<email>  dmr@research.att.com   </email>::line_number::4
<abstract>  ABSTRACT  </abstract>::line_number::5
<abstract> The C programming language was devised in the early 1970s as a system  </abstract>::line_number::6
<abstract> implementation language for the nascent Unix operating system. Derived from  </abstract>::line_number::7
<abstract> the typeless language BCPL, it evolved a type structure; created on a tiny  </abstract>::line_number::8
<abstract> machine as a tool to improve a meager programming environment, it has become  </abstract>::line_number::9
<abstract> one of the dominant languages of today. This paper studies its evolution.   </abstract>::line_number::10
<intro>  Introduction </intro>::line_number::11
<intro>  </intro>::line_number::12

<title>  Hierarchical Explanation-Based Reinforcement Learning   </title>::line_number::0
<author>  Prasad Tadepalli and Thomas G. Dietterich   </author>::line_number::1
<affiliation>  Computer Science Department  </affiliation>::line_number::2
<affiliation> Oregon State University   </affiliation>::line_number::3
<address>  Corvallis,Oregon 97331-3202   </address>::line_number::4
<email>  ftadepalli,tgdg@research.cs.orst.edu   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Explanation-Based Reinforcement Learning  </abstract>::line_number::7
<abstract> (EBRL) was introduced by Dietterich and  </abstract>::line_number::8
<abstract> Flann as a way of combining the ability of  </abstract>::line_number::9
<abstract> Reinforcement Learning (RL) to learn optimal plans with the generalization ability  </abstract>::line_number::10
<abstract> of Explanation-Based Learning (EBL) (Di-etterich & Flann, 1995). We extend this  </abstract>::line_number::11
<abstract> work to domains where the agent must order and achieve a sequence of subgoals in  </abstract>::line_number::12
<abstract> an optimal fashion. Hierarchical EBRL can  </abstract>::line_number::13
<abstract> effectively learn optimal policies in some of  </abstract>::line_number::14
<abstract> these sequential task domains even when the  </abstract>::line_number::15
<abstract> subgoals weakly interact with each other.  </abstract>::line_number::16
<abstract> We also show that when a planner that can  </abstract>::line_number::17
<abstract> achieve the individual subgoals is available,  </abstract>::line_number::18
<abstract> our method converges even faster.   </abstract>::line_number::19
<intro>  1 Introduction  </intro>::line_number::20

<title>  DISTRIBUTED CONTROL IN OPTICAL WDM NETWORKS   </title>::line_number::0
<author>  X. Yuan R. Gupta R. Melhem   </author>::line_number::1
<affiliation>  Department of Computer Science  </affiliation>::line_number::2
<affiliation> University of Pittsburgh   </affiliation>::line_number::3
<address>  Pittsburgh, PA 15260   </address>::line_number::4
<abstract>  ABSTRACT  </abstract>::line_number::5
<abstract> This paper describes and evaluates distributed  </abstract>::line_number::6
<abstract> wavelength reservation protocols for all-optical WDM  </abstract>::line_number::7
<abstract> networks. These protocols are essential for applying  </abstract>::line_number::8
<abstract> WDM techniques to large scale all-optical networks.  </abstract>::line_number::9
<abstract> The protocols ensure that the wavelengths on the links  </abstract>::line_number::10
<abstract> along a path are reserved before communication takes  </abstract>::line_number::11
<abstract> place. A message is transmitted using the reserved  </abstract>::line_number::12
<abstract> wavelengths and remains in the optical domain utill  </abstract>::line_number::13
<abstract> it reaches the destination. Based upon the timing at  </abstract>::line_number::14
<abstract> which the reservation is performed, the protocols are  </abstract>::line_number::15
<abstract> classified into two categories: forward reservation protocols and backward reservation protocols. Although  </abstract>::line_number::16
<abstract> forward reservation protocols are simpler, our performance study shows that backward reservation protocols provide better performance.   </abstract>::line_number::17
<intro>  INTRODUCTION  </intro>::line_number::18

<title>  Contingency Selection in Plan Generation   </title>::line_number::0
<author>  Nilufer Onder   </author>::line_number::1
<affiliation>  Department of Computer Science  </affiliation>::line_number::2
<affiliation> University of Pittsburgh   </affiliation>::line_number::3
<address>  Pittsburgh, PA 15260   </address>::line_number::4
<note>  nilufer@cs.pitt.edu   </note>::line_number::5
<author>  Martha E. Pollack   </author>::line_number::6
<affiliation>  Department of Computer Science  </affiliation>::line_number::7
<affiliation> and Intelligent Systems Program  </affiliation>::line_number::8
<affiliation> University of Pittsburgh   </affiliation>::line_number::9
<address>  Pittsburgh, PA 15260   </address>::line_number::10
<note>  pollack@cs.pitt.edu   </note>::line_number::11
<abstract>  Abstract  </abstract>::line_number::12
<abstract> A key question in conditional planning is: how many,  </abstract>::line_number::13
<abstract> and which of the possible execution failures should be  </abstract>::line_number::14
<abstract> planned for? One cannot, in general, plan for all the  </abstract>::line_number::15
<abstract> possible failures because the search space is too large.  </abstract>::line_number::16
<abstract> One cannot ignore all the possible failures, or one will  </abstract>::line_number::17
<abstract> fail to produce sufficiently flexible plans. In this paper,  </abstract>::line_number::18
<abstract> we describe an approach to conditional planning that  </abstract>::line_number::19
<abstract> attempts to identify the contingencies that contribute  </abstract>::line_number::20
<abstract> the most to a plan's overall utility. Plan generation  </abstract>::line_number::21
<abstract> proceeds by handling the most important contingencies first, extending the plan to include actions that  </abstract>::line_number::22
<abstract> will be taken in case the contingency fails. We discuss  </abstract>::line_number::23
<abstract> the representational issues that must be addressed in  </abstract>::line_number::24
<abstract> order to implement such an algorithm, and present an  </abstract>::line_number::25
<abstract> example which illustrates our approach.   </abstract>::line_number::26
<intro>  Introduction  </intro>::line_number::27

<title>  Working Sets, Cache Sizes, and Node Granularity Issues  </title>::line_number::0
<title> for Large-Scale Multiprocessors   </title>::line_number::1
<author>  Edward Rothberg Jaswinder Pal Singh and Anoop Gupta   </author>::line_number::2
<affiliation>  Intel Supercomputer Systems Division Computer Systems Laboratory   </affiliation>::line_number::3
<address>  14924 N.W. Greenbrier Parkway   Stanford University   </address>::line_number::4
<address>  Beaverton, OR 97006 Stanford, CA 94305   </address>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> The distribution of resources among processors, memory and  </abstract>::line_number::7
<abstract> caches is a crucial question faced by designers of large-scale  </abstract>::line_number::8
<abstract> parallel machines. If a machine is to solve problems with a  </abstract>::line_number::9
<abstract> certain data set size, should it be built with a large number of  </abstract>::line_number::10
<abstract> processors each with a small amount of memory, or a smaller  </abstract>::line_number::11
<abstract> number of processors each with a large amount of memory?  </abstract>::line_number::12
<abstract> How much cache memory should be provided per processor for  </abstract>::line_number::13
<abstract> cost-effectiveness? And how do these decisions change as larger  </abstract>::line_number::14
<abstract> problems are run on larger machines?  </abstract>::line_number::15
<abstract> In this paper, we explore the above questions based on the  </abstract>::line_number::16
<abstract> characteristics of five important classes of large-scale parallel scientific applications. We first show that all the applications have a hierarchy of well-defined per-processor working  </abstract>::line_number::17
<abstract> sets, whose size, performance impact and scaling characteristics  </abstract>::line_number::18
<abstract> can help determine how large different levels of a multiprocessor's cache hierarchy should be. Then, we use these working sets together with certain other important characteristics of  </abstract>::line_number::19
<abstract> the applications|such as communication to computation ratios,  </abstract>::line_number::20
<abstract> concurrency, and load balancing behavior|to reflect upon the  </abstract>::line_number::21
<abstract> broader question of the granularity of processing nodes in high-performance multiprocessors.  </abstract>::line_number::22
<abstract> We find that very small caches whose sizes do not increase  </abstract>::line_number::23
<abstract> with the problem or machine size are adequate for all but two of  </abstract>::line_number::24
<abstract> the application classes. Even in the two exceptions, the working  </abstract>::line_number::25
<abstract> sets scale quite slowly with problem size, and the cache sizes  </abstract>::line_number::26
<abstract> needed for problems that will be run in the foreseeable future  </abstract>::line_number::27
<abstract> are small. We also find that relatively fine-grained machines,  </abstract>::line_number::28
<abstract> with large numbers of processors and quite small amounts of  </abstract>::line_number::29
<abstract> memory per processor, are appropriate for all the applications.   </abstract>::line_number::30
<intro>  1 Introduction  </intro>::line_number::31

<title>  Modeling Communication in Parallel Algorithms:  </title>::line_number::0
<title> A Fruitful Interaction between Theory and Systems?   </title>::line_number::1
<author>  Jaswinder Pal Singh * , Edward Rothberg , and Anoop Gupta *   </author>::line_number::2
<affiliation>  * Computer Systems Laboratory Intel Supercomputer Systems  </affiliation>::line_number::3
<address> Stanford University   14924 NW Greenbrier Pkwy, CO6-09  </address>::line_number::4
<address> Stanford, CA 94305 Beaverton, OR 97006   </address>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Recently, several theoretical models of parallel architectures have been proposed to replace the PRAM as the model  </abstract>::line_number::7
<abstract> that is presented to an algorithm designer. A primary focus of  </abstract>::line_number::8
<abstract> the new models is to include the cost of interprocessor communication, which is increasingly important in modern parallel  </abstract>::line_number::9
<abstract> architectures. We argue that modeling the communication costs  </abstract>::line_number::10
<abstract> in the architecture or system is only one part of the problem.  </abstract>::line_number::11
<abstract> The other, and usually much more difficult, part is modeling  </abstract>::line_number::12
<abstract> the communication properties of the algorithm itself, which  </abstract>::line_number::13
<abstract> provides necessary inputs into the architectural model to determine overall complexity. In this context, we make three main  </abstract>::line_number::14
<abstract> points in this paper: (i) It is incomplete to describe communication without regard to its relationship with replication. We  </abstract>::line_number::15
<abstract> propose a description of the communication-replication relationship in terms of the working set hierarchy of an algorithm.  </abstract>::line_number::16
<abstract> (ii) Both inherent communication and the communication-replication relationship can be very difficult to model in irregular, dynamic computations that are crucial in many real-world  </abstract>::line_number::17
<abstract> applications. We present some examples that demonstrate this  </abstract>::line_number::18
<abstract> difficulty. (iii) We believe that substantial leverage can be  </abstract>::line_number::19
<abstract> obtained in this effort from the computer systems community,  </abstract>::line_number::20
<abstract> which can provide a hierarchy of simulation and profiling  </abstract>::line_number::21
<abstract> toolsfrom abstract to detailedtailored to the needs of the  </abstract>::line_number::22
<abstract> algorithm designers. We propose an initial set of simulation  </abstract>::line_number::23
<abstract> tools, and we discuss possible future refinements to this set.   </abstract>::line_number::24
<intro>  1 Introduction  </intro>::line_number::25

<pubnum>  Technical Report TR-514-96.   </pubnum>::line_number::0
<title>  Irregular Applications under Software Shared Memory   </title>::line_number::1
<author>  Liviu Iftode, Jaswinder Pal Singh and Kai Li   </author>::line_number::2
<affiliation>  Department of Computer Science  </affiliation>::line_number::3
<affiliation> Princeton University   </affiliation>::line_number::4
<address>  Princeton, NJ 08544   </address>::line_number::5
<email>  liv,jps,li@cs.princeton.edu   </email>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> Shared Virtual Memory (SVM) provides an inexpensive way to support the popular shared address  </abstract>::line_number::8
<abstract> space programming model on networks of workstations or personal computers. Despite recent advances  </abstract>::line_number::9
<abstract> in SVM systems, their performance for all but coarse-grained or regular applications is not well understood.  </abstract>::line_number::10
<abstract> Nor is there an understanding of whether and how  </abstract>::line_number::11
<abstract> fine-grained, irregular programs should be written differently for SVM, with its large granularities of communication and coherence, than for the more familiar  </abstract>::line_number::12
<abstract> hardware coherent at cache line granularity. In this  </abstract>::line_number::13
<abstract> paper we try to understand the performance and programming issues for emerging, irregular applications  </abstract>::line_number::14
<abstract> on SVM systems. We examine performance on both  </abstract>::line_number::15
<abstract> an aggressive all-software system as well as one with a  </abstract>::line_number::16
<abstract> little hardware support in the network interface. We  </abstract>::line_number::17
<abstract> also present approaches to improve the performance  </abstract>::line_number::18
<abstract> of irregular applications at both the programming and  </abstract>::line_number::19
<abstract> the system level. As a result of our experiences, we  </abstract>::line_number::20
<abstract> identify a set of guidelines and techniques that pertain  </abstract>::line_number::21
<abstract> specifically to programming SVM systems, beyond the  </abstract>::line_number::22
<abstract> guidelines commonly used for programming hardware-coherent systems as well. We also present a further  </abstract>::line_number::23
<abstract> relaxation of the memory consistency model, called  </abstract>::line_number::24
<abstract> scope consistency, which is particularly effective for  </abstract>::line_number::25
<abstract> such applications.   </abstract>::line_number::26
<intro>  1 Introduction  </intro>::line_number::27

<title>  Network Services for  </title>::line_number::0
<title> Multi-User Virtual Environments   </title>::line_number::1
<author>  Thomas A. Funkhouser   </author>::line_number::2
<affiliation>  AT&T Bell Laboratories   </affiliation>::line_number::3
<address>  Murray Hill, NJ   </address>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> This paper describes network services to support  </abstract>::line_number::6
<abstract> large multi-user virtual environments. A client-server design is proposed in which multiple servers  </abstract>::line_number::7
<abstract> coordinate execution, manage communication, offload processing, and provide persistent storage for  </abstract>::line_number::8
<abstract> their clients. Using this design, it is possible to support real-time features, such as collision detection,  </abstract>::line_number::9
<abstract> voice bridging, persistent updates, physical simulation, and autonomous agents, that would be difficult to implement for large virtual environments  </abstract>::line_number::10
<abstract> with a peer-to-peer design. The paper includes a  </abstract>::line_number::11
<abstract> description of services being implemented in RING,  </abstract>::line_number::12
<abstract> a client-server system for interaction between many  </abstract>::line_number::13
<abstract> users in large virtual environments.   </abstract>::line_number::14
<intro>  1 Introduction  </intro>::line_number::15

<title>  Database and Display Algorithms for  </title>::line_number::0
<title> Interactive Visualization of Architectural Models   </title>::line_number::1
<author>  by  </author>::line_number::2
<author> Thomas Allen Funkhouser   </author>::line_number::3
<degree>  B.S. (Stanford University) 1983  </degree>::line_number::4
<degree> M.S. (University of California at Los Angeles) 1989  </degree>::line_number::5
<degree> A dissertation submitted in partial satisfaction of the  </degree>::line_number::6
<degree> requirements for the degree of  </degree>::line_number::7
<degree> Doctor of Philosophy  </degree>::line_number::8
<degree> in   </degree>::line_number::9
<affiliation>  Computer Science   </affiliation>::line_number::10
<degree>  in the  </degree>::line_number::11
<degree> GRADUATE DIVISION  </degree>::line_number::12
<degree> of the   </degree>::line_number::13
<affiliation>  UNIVERSITY of CALIFORNIA at BERKELEY   </affiliation>::line_number::14
<degree>  Committee in charge:  </degree>::line_number::15
<degree> Professor Carlo H. Sequin , Chair  </degree>::line_number::16
<degree> Professor Lawrence Rowe  </degree>::line_number::17
<degree> Professor Jean Pierre Protzen   </degree>::line_number::18
<date>  1993   </date>::line_number::19
<page>  +PAGE+  </page>::line_number::20

<title>  Simulating the Madness of Crowds:  </title>::line_number::0
<title> Price Bubbles in an Auction-Mediated Robot Market   </title>::line_number::1
<author>  Ken Steiglitz and Daniel Shapiro   </author>::line_number::2
<affiliation>  Dept. of Computer Science, Princeton University   </affiliation>::line_number::3
<address>  Princeton, NJ 08544   </address>::line_number::4
<date>  May 5, 1997   </date>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> We simulate a multiagent market with production, consumption, and exchange  </abstract>::line_number::7
<abstract> mediated by a sealed-bid double auction. Marked price bubbles and subsequent  </abstract>::line_number::8
<abstract> crashes occur when value-based (fundamentals-driven) and trend-based traders are  </abstract>::line_number::9
<abstract> both present, and the market equilibrium price is ramped up exogenously. Similarly,  </abstract>::line_number::10
<abstract> negative price bubbles and recoveries occur when the equilibrium price is ramped  </abstract>::line_number::11
<abstract> down. Because the simulated market is auction-mediated, we can observe the operations of traders during these events, and study the interactions that produce and  </abstract>::line_number::12
<abstract> resolve bubbles. Some preliminary circuit-breaker experiments are described, in which  </abstract>::line_number::13
<abstract> bubbles are interrupted during their formation.   </abstract>::line_number::14
<intro>  1 Introduction </intro>::line_number::15
<intro>  </intro>::line_number::16

<pubnum>  DIMACS Technical Report 98-10   </pubnum>::line_number::0
<date>  February 1998   </date>::line_number::1
<title>  Patience is a Virtue: The Effect of Delay on  </title>::line_number::2
<title> Competitiveness for Admission Control   </title>::line_number::3
<author>  by  </author>::line_number::4
<author> Michael H. Goldwasser 1   </author>::line_number::5
<affiliation>  Department of Computer Science  </affiliation>::line_number::6
<affiliation> Princeton University   </affiliation>::line_number::7
<address>  Princeton, NJ 08544   </address>::line_number::8
<email>  wass@cs.princeton.edu   </email>::line_number::9
<note>  1 Permanent Member  </note>::line_number::10
<note> DIMACS is a partnership of Rutgers University, Princeton University, AT&T Labs-Research,  </note>::line_number::11
<note> Bell Labs and Bellcore.  </note>::line_number::12
<note> DIMACS is an NSF Science and Technology Center, funded under contract STC-91-19999;  </note>::line_number::13
<note> and also receives support from the New Jersey Commission on Science and Technology.   </note>::line_number::14
<page>  +PAGE+  </page>::line_number::15

<title>  An Evolutionary Approach to  </title>::line_number::0
<title> Combinatorial Optimization Problems   </title>::line_number::1
<author>  Sami Khuri   </author>::line_number::2
<affiliation>  Department of Mathematics & Computer Science  </affiliation>::line_number::3
<affiliation> San Jose State University   </affiliation>::line_number::4
<address>  One Washington Square  </address>::line_number::5
<address> San Jose, CA 95192-0103, U.S.A.   </address>::line_number::6
<email>  khuri@sjsumcs.sjsu.edu   </email>::line_number::7
<author>  Thomas Back and Jorg Heitkotter   </author>::line_number::8
<affiliation>  Department of Computer Science  </affiliation>::line_number::9
<affiliation> University of Dortmund  </affiliation>::line_number::10
<affiliation> Systems Analysis Research Group, LSXI   </affiliation>::line_number::11
<address>  D-44221 Dortmund, Germany   </address>::line_number::12
<email>  fbaeck,jokeg@ls11.informatik.uni-dortmund.de   </email>::line_number::13
<note>  Copyright c 1993 ACM Press. All rights reserved.  </note>::line_number::14
<note> To appear in the proceedings of CSC'94  </note>::line_number::15
<note> Phoenix Arizona, March 8-10, 1994.   </note>::line_number::16
<abstract>  Abstract: The paper reports on the application of genetic  </abstract>::line_number::17
<abstract> algorithms, probabilistic search algorithms based on the  </abstract>::line_number::18
<abstract> model of organic evolution, to NP-complete combinatorial  </abstract>::line_number::19
<abstract> optimization problems. In particular, the subset sum, maximum cut, and minimum tardy task problems are considered.  </abstract>::line_number::20
<abstract> Except for the fitness function, no problem-specific changes  </abstract>::line_number::21
<abstract> of the genetic algorithm are required in order to achieve results of high quality even for the problem instances of size  </abstract>::line_number::22
<abstract> 100 used in the paper. For constrained problems, such as the  </abstract>::line_number::23
<abstract> subset sum and the minimum tardy task, the constraints are  </abstract>::line_number::24
<abstract> taken into account by incorporating a graded penalty term  </abstract>::line_number::25
<abstract> into the fitness function. Even for large instances of these  </abstract>::line_number::26
<abstract> highly multimodal optimization problems, an iterated application of the genetic algorithm is observed to find the global  </abstract>::line_number::27
<abstract> optimum within a number of runs. As the genetic algorithm  </abstract>::line_number::28
<abstract> samples only a tiny fraction of the search space, these results  </abstract>::line_number::29
<abstract> are quite encouraging.   </abstract>::line_number::30
<intro>  1 Introduction  </intro>::line_number::31

<title>  Investigating  </title>::line_number::0
<title> Genetic Algorithms  </title>::line_number::1
<title> for Scheduling   </title>::line_number::2
<author>  Hsiao-Lan Fang   </author>::line_number::3
<degree>  MSc Dissertation   </degree>::line_number::4
<affiliation>  Department of Artificial Intelligence  </affiliation>::line_number::5
<affiliation> University of Edinburgh   </affiliation>::line_number::6
<date>  1992   </date>::line_number::7
<page>  +PAGE+  </page>::line_number::8

<title>  Navigation in Three Dimensional Spaces   </title>::line_number::0
<pubnum>  CS-590Z   </pubnum>::line_number::1
<author>  Carlos Gonzalez Ochoa Aleman   </author>::line_number::2
<date>  May 23, 1994   </date>::line_number::3
<abstract>  Abstract  </abstract>::line_number::4
<abstract> Current graphic hardware have helped to develop scientific visualization tools,  </abstract>::line_number::5
<abstract> but this progress has not level with the magnitude of data genereted in some areas needing to be visualized. Techniques to navigate data have been developed,  </abstract>::line_number::6
<abstract> including new hardware and algorithms to improve the rendering speed and quality.  </abstract>::line_number::7
<abstract> This paper will describe the issues of navigation, current display and interaction  </abstract>::line_number::8
<abstract> technology, and algorithms. At the end a set of problems yet to be solved will be  </abstract>::line_number::9
<abstract> discussed   </abstract>::line_number::10
<intro>  1 Introduction  </intro>::line_number::11

<title>  A Color-based Technique for Measuring Visible Loss for Use  </title>::line_number::0
<title> in Image Data Communication 1   </title>::line_number::1
<author>  Melliyal Annamalai, Aurobindo Sundaram and Bharat Bhargava   </author>::line_number::2
<affiliation>  Department of Computer Sciences  </affiliation>::line_number::3
<affiliation> Purdue University   </affiliation>::line_number::4
<address>  W. Lafayette, IN 47906, USA   </address>::line_number::5
<email>  fmelli,auro,bbg@cs.purdue.edu   </email>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> The concept of the global information infrastructure and specifically that of the World  </abstract>::line_number::8
<abstract> Wide Web (WWW) has led to users accessing data of different media including images  </abstract>::line_number::9
<abstract> and video data over a wide area network. These data objects have sizes the order of  </abstract>::line_number::10
<abstract> megabytes and communication time is very large. The data size can be reduced without  </abstract>::line_number::11
<abstract> losing information by applying loss-inducing techniques and this will lead to reduction in  </abstract>::line_number::12
<abstract> communication time. Several loss-inducing techniques have been developed and each image  </abstract>::line_number::13
<abstract> is treated differently by each technique. In some cases an acceptable quality of the image  </abstract>::line_number::14
<abstract> is obtained and in some cases it is not. In this paper we develop a color-based technique  </abstract>::line_number::15
<abstract> to quantify the data loss when a loss-inducing technique is applied to an image. This will  </abstract>::line_number::16
<abstract> result in estimating whether the resulting image is indistinguishable from the original with  </abstract>::line_number::17
<abstract> respect to the human eye. We illustrate its use to classify images according to the loss they  </abstract>::line_number::18
<abstract> can tolerate. This avoids redundant communication of a high quality image when a lower  </abstract>::line_number::19
<abstract> quality image can satisfy the application resulting in the conservation and better usage  </abstract>::line_number::20
<abstract> of network resources. We present the technique, the communication time saved, and an  </abstract>::line_number::21
<abstract> experimental evaluation to prove the validity of the technique.   </abstract>::line_number::22
<intro>  1 Introduction  </intro>::line_number::23

<title>  AFEC: An Adaptive Forward Error-Correction  </title>::line_number::0
<title> Protocol and Its Analysis   </title>::line_number::1
<author>  Kihong Park   </author>::line_number::2
<affiliation>  Department of Computer Sciences  </affiliation>::line_number::3
<affiliation> Purdue University   </affiliation>::line_number::4
<address>  West Lafayette, IN 47907   </address>::line_number::5
<email>  park@cs.purdue.edu   </email>::line_number::6
<pubnum>  CSD-TR 97-038   </pubnum>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> This paper presents an adaptive protocol for packet-level forward error-correction in dynamic networks. The objective is to facilitate best-effort real-time applications whose timing  </abstract>::line_number::9
<abstract> constraints rule out the use of retransmission-based ARQ schemes. The degree of redundancy  </abstract>::line_number::10
<abstract> is adjusted as a function of network state, decreasing when the network is well-behaved and  </abstract>::line_number::11
<abstract> increasing when it is not. The control problem is nontrivial due to the fact that increased redundancy, beyond a certain level, backfires resulting in self-induced congestion which impedes  </abstract>::line_number::12
<abstract> the timely recovery of information at the receiver.  </abstract>::line_number::13
<abstract> In the first part of the paper, we present a comprehensive analysis of the control problem  </abstract>::line_number::14
<abstract> associated with dynamic forward error-correction, concentrating on a particular protocol called  </abstract>::line_number::15
<abstract> Adaptive Forward Error-Correction (AFEC). We show that instabilities can arise from two  </abstract>::line_number::16
<abstract> distinct sources|desired operating point location and network delay|and we give solutions to  </abstract>::line_number::17
<abstract> handle them. The first causal factor is intimately tied to optimality, making its achievement  </abstract>::line_number::18
<abstract> potentially perilous in the context of QoS-greedy applications.  </abstract>::line_number::19
<abstract> The second part of the paper presents simulation results that confirm the qualitative dynamics predicted by the analysis. We quantitatively estimate the redundancy-recovery rate function  </abstract>::line_number::20
<abstract> which relates redundancy to the quality of service rendered at the receiver. We show under what  </abstract>::line_number::21
<abstract> conditions the curve's shape is unimodal and to what degree. We compare the performance of  </abstract>::line_number::22
<abstract> AFEC against a static FEC protocol in which the redundancy factor is fixed. We show that  </abstract>::line_number::23
<abstract> AFEC exhibits superior performance when the network is subject to structural changes that  </abstract>::line_number::24
<abstract> persist for nonnegligible durations. Under short-range dependent traffic conditions, AFEC is  </abstract>::line_number::25
<abstract> able to closely match the performance of optimum static FEC but not exceed it.   </abstract>::line_number::26
<page>  +PAGE+  </page>::line_number::27

<title>  PYTHIA: A Knowledge Based System  </title>::line_number::0
<title> for Intelligent Scientific Computing   </title>::line_number::1
<author>  Sanjiva Weerawarana, Elias N. Houstis, John R. Rice, Anupam Joshi   </author>::line_number::2
<affiliation>  Purdue University   </affiliation>::line_number::3
<author>  and  </author>::line_number::4
<author> Catherine E. Houstis   </author>::line_number::5
<affiliation>  University of Crete   </affiliation>::line_number::6
<keyword>  Categories and Subject Descriptors: I.2.1 [Artificial Intelligence]: Applications and Expert  </keyword>::line_number::7
<keyword> Systems; G.1.8 [Numerical Analysis]: Partial Differential Equations  </keyword>::line_number::8
<keyword> General Terms: Knowledge Based Systems  </keyword>::line_number::9
<keyword> Additional Key Words and Phrases: Computational Intelligence, Knowledge Based Systems, Partial Differential Equations, Performance Evaluation, Problem Solving Environments   </keyword>::line_number::10
<abstract>  1. ABSTRACT  </abstract>::line_number::11
<abstract> Domain specific Problem Solving Environments (PSEs) are the key new ingredients that will aid in the widespread use of Computational Science & Engineering  </abstract>::line_number::12
<abstract> (CS&E) systems. Each PSE consists of a well defined library that supports the  </abstract>::line_number::13
<abstract> numerical and symbolic solution of certain mathematical model(s) characterizing a  </abstract>::line_number::14
<abstract> specific discipline, together with an easy to use software environment. This environment should ideally interact with the user in a language "natural" to the associated  </abstract>::line_number::15
<abstract> discipline, and provide a high level abstraction of the underlying, computationally  </abstract>::line_number::16
<abstract> complex, model. However, it appears that almost all extant PSEs assume that  </abstract>::line_number::17
<abstract> the user is familiar with the specific functionality/applicability of the PSE. Their  </abstract>::line_number::18
<abstract> primary design objective is to support some form of high level programming with  </abstract>::line_number::19
<abstract> predefined state-of-the-art algorithmic infrastructure. As the functionality of these  </abstract>::line_number::20
<abstract> systems increases, the user is expected to make complex decisions in the parametric space of the algorithmic infrastructure supported by the PSE. In this paper  </abstract>::line_number::21
<abstract> we describe a knowledge based system, PYTHIA, to automate this decision making process and aid in providing a high level abstraction to the user. Specifically,  </abstract>::line_number::22
<abstract> PYTHIA addresses the problem of (parameter, algorithm) pair selection within a  </abstract>::line_number::23
<abstract> scientific computing domain assuming some minimum user specified computational  </abstract>::line_number::24
<abstract> objectives and some characteristics of the given problem. PYTHIA's framework  </abstract>::line_number::25
<abstract> and methodology is general and applicable to any class of scientific problems and   </abstract>::line_number::26
<note>  Work supported in part by AFOSR award 91-F49620, NSF awards CCR 86-19817, CCR 92-02536,  </note>::line_number::27
<note> and ASC 9404859.   </note>::line_number::28
<note>  Authors' addresses:   S. Weerawarana, E.N. Houstis, J.R. Rice and A. Joshi:   Department of Computer Sciences, Purdue University,   West Lafayette, IN 47907, USA;   C.E. Houstis:   Department of  </note>::line_number::29
<address> Computer Science, University of Crete,   Heraklion, Greece.   </address>::line_number::30
<page>  +PAGE+  </page>::line_number::31

<title>  On the Collapse of the q-Gram Filtration   </title>::line_number::0
<author>  E. SUTINEN   </author>::line_number::1
<affiliation>  University of Helsinki,   Finland   </affiliation>::line_number::2
<author>  W. SZPANKOWSKI   </author>::line_number::3
<affiliation>  Purdue University,   U.S.A.   </affiliation>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> In the approximate pattern matching problem, the text area to be searched  </abstract>::line_number::6
<abstract> for an occurrence of a pattern can be pruned by applying a filtration condition. A q-gram based filtration condition defines potential text areas in terms  </abstract>::line_number::7
<abstract> of pattern q-grams, i.e., strings of length q. A text area will be checked by  </abstract>::line_number::8
<abstract> an accurate method only if the set of the q-grams in the text area satisfies a  </abstract>::line_number::9
<abstract> certain condition. One hopes that the filtration limits the number of checks  </abstract>::line_number::10
<abstract> to a minimum, thus making the algorithm quite efficient. However, computer experiments show that the filtration method works fine for cases when  </abstract>::line_number::11
<abstract> the allowed error level k is relatively small compared to the pattern length,  </abstract>::line_number::12
<abstract> but loses its efficiency quite sharply with an increasing k. This is a phase  </abstract>::line_number::13
<abstract> transition phenomenon that is quite often observed in nature. In this paper,  </abstract>::line_number::14
<abstract> we present a theoretical explanation for this phenomenon which will excuse  </abstract>::line_number::15
<abstract> us to introduce advanced mathematical analysis based on certain languages,  </abstract>::line_number::16
<abstract> correlation polynomials, generating functions and complex analysis. It is our  </abstract>::line_number::17
<abstract> view that nothing can be more exciting and rewarding than finding a theoretical justification for an abrupt manifestation of nature.   </abstract>::line_number::18
<keyword>  Keywords: Algorithm Analysis, Approximate Pattern Matching.   </keyword>::line_number::19
<intro>  1 Introduction  </intro>::line_number::20

<title>  Authorship Analysis: Identifying The  </title>::line_number::0
<title> Author of a Program 1   </title>::line_number::1
<author>  Ivan Krsul   </author>::line_number::2
<affiliation>  The COAST Project  </affiliation>::line_number::3
<affiliation> Department of Computer Sciences  </affiliation>::line_number::4
<affiliation> Purdue University   </affiliation>::line_number::5
<address>  West Lafayette, IN 47907-1398   </address>::line_number::6
<email>  krsul@cs.purdue.edu   </email>::line_number::7
<date>  May 3, 1994   </date>::line_number::8
<pubnum>  Technical Report CSD-TR-94-030   </pubnum>::line_number::9
<note>  1 This paper was originally written as a Master's thesis at Purdue University.   </note>::line_number::10
<page>  +PAGE+  </page>::line_number::11

<title>  Efficient Disk Allocation for Fast Similarity Searching   </title>::line_number::0
<author>  Sunil Prabhakar Divyakant Agrawal Amr El Abbadi   </author>::line_number::1
<affiliation>  Department of Computer Science  </affiliation>::line_number::2
<affiliation> University of California   </affiliation>::line_number::3
<address>  Santa Barbara  </address>::line_number::4
<address> CA 93106, U.S.A.   </address>::line_number::5
<email>  fsunilp,agrawal,amrg@cs.ucsb.edu   </email>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> As databases increasingly integrate non-textual information  </abstract>::line_number::8
<abstract> it is becoming necessary to support efficient similarity searching in addition to range searching. Recently, declustering  </abstract>::line_number::9
<abstract> techniques have been proposed for improving the performance of similarity searches through parallel I/O. In this  </abstract>::line_number::10
<abstract> paper, we propose a new scheme which provides good declus-tering for similarity searching. In particular, it does global  </abstract>::line_number::11
<abstract> declustering as opposed to local declustering, exploits the  </abstract>::line_number::12
<abstract> availability of extra disks and does not limit the partitioning of the data space. Our technique is based upon the  </abstract>::line_number::13
<abstract> Cyclic declustering schemes which were developed for range  </abstract>::line_number::14
<abstract> and partial match queries. We establish, in general, that  </abstract>::line_number::15
<abstract> Cyclic declustering techniques outperform previously proposed techniques.   </abstract>::line_number::16
<note>  Appeared in Proc. 10th ACM Symposium on Parallel Algorithms and Architectures (SPAA '98), Puerto Vallarta, Mexico   </note>::line_number::17
<intro>  1 Introduction  </intro>::line_number::18

<title>  A Coarse-Grained Parallel  </title>::line_number::0
<title> QR-Factorization Algorithm for  </title>::line_number::1
<title> Sparse Least Squares Problems   </title>::line_number::2
<author>  Tz. Ostromsky P. C. Hansen Z. Zlatev    </author>::line_number::3
<abstract>  Abstract  </abstract>::line_number::4
<abstract> A sparse QR-factorization algorithm SPARQR for coarse-grained parallel  </abstract>::line_number::5
<abstract> computations is described. The coefficient matrix, which is assumed to be  </abstract>::line_number::6
<abstract> general sparse, is reordered in an attempt to bring as many zero elements in  </abstract>::line_number::7
<abstract> the lower left corner as possible. The reordered matrix is then partitioned into  </abstract>::line_number::8
<abstract> block rows, and Givens plane rotations are applied in each block-row. These are  </abstract>::line_number::9
<abstract> independent tasks and can be done in parallel. Row and column permutations  </abstract>::line_number::10
<abstract> are carried out within the diagonal blocks in an attempt to preserve better the  </abstract>::line_number::11
<abstract> sparsity of the matrix.  </abstract>::line_number::12
<abstract> The algorithm can be used for solving least squares problems either directly  </abstract>::line_number::13
<abstract> or combined with an iterative method (preconditioned conjugate gradients are  </abstract>::line_number::14
<abstract> used). Small non-zero elements can optionally be dropped in the latter case.  </abstract>::line_number::15
<abstract> This leads to a better preservation of the sparsity and, therefore, to a faster  </abstract>::line_number::16
<abstract> factorization. The price which has to be paid is some loss of accuracy. The  </abstract>::line_number::17
<abstract> iterative method is used to regain the accuracy lost during the factorization.  </abstract>::line_number::18
<abstract> Numerical results from several experiments with matrices from the well-known Harwell-Boeing collection as well as with some larger sparse matrices are  </abstract>::line_number::19
<abstract> presented in this work. An SGI Power Challenge computer with 16 processors  </abstract>::line_number::20
<abstract> has been used in the experiments.   </abstract>::line_number::21
<keyword>  Keywords: coarse-grained parallelism, least squares problem, QR-factorization,  </keyword>::line_number::22
<keyword> general sparse matrix, drop-tolerance, reordering, partitioning, block algorithm.   </keyword>::line_number::23
<affiliation>  Purdue University, Department of Computer Science,   </affiliation>::line_number::24
<address>  West Lafayette, IN 47907, USA   </address>::line_number::25
<email>  e-mail: tto@cs.purdue.edu   </email>::line_number::26
<affiliation>  Institute of Mathematical Modelling, Technical University of Denmark,   </affiliation>::line_number::27
<address>  Bldg. 305, DK-2800 Lyngby, Denmark   </address>::line_number::28
<email>  e-mail: pch@imm.dtu.dk   </email>::line_number::29
<affiliation>  National Environmental Research Institute,   Frederiksborgvej 399, DK-4000 Roskilde, Denmark   </affiliation>::line_number::30
<email>  e-mail: luzz@sun2.dmu.dk   </email>::line_number::31
<page>  +PAGE+  </page>::line_number::32

<title>  Efficient Finite-State Approximation of Context  </title>::line_number::0
<title> Free Grammars   </title>::line_number::1
<author>  C.M. Rood   </author>::line_number::2
<affiliation>  Computer Laboratory  </affiliation>::line_number::3
<affiliation> University of Cambridge   </affiliation>::line_number::4
<email>  cmr1001@cl.cam.ac.uk   </email>::line_number::5
<abstract>  Abstract. This paper introduces a novel method for constructing finite-state machines recognising context free (CF)  </abstract>::line_number::6
<abstract> grammars. The method utilizes the idea of a path through  </abstract>::line_number::7
<abstract> a finite-state machine (FSM). Certain paths form the basis  </abstract>::line_number::8
<abstract> for an unfolding process which is applied to the LR(0) characteristic finite-state machine (CFSM) corresponding to the  </abstract>::line_number::9
<abstract> grammar. The next section discusses the approximation algorithm, including this unfolding process, in more detail, and  </abstract>::line_number::10
<abstract> section 3 introduces the concept of an unfolding criterion.  </abstract>::line_number::11
<abstract> Section 4 proves the soundness of the approximation method,  </abstract>::line_number::12
<abstract> and its exactness to arbitrary, fixed recursive depths. Section  </abstract>::line_number::13
<abstract> 5 presents initial computational figures resulting from an implementation of the method. A variation of the method that  </abstract>::line_number::14
<abstract> is more computationally feasible is discussed. The final section compares the method with existing research on finite-state approximation of CF grammars, and presents preliminary conclusions regarding the method.   </abstract>::line_number::15
<intro>  1 THE APPROXIMATION  </intro>::line_number::16

<title>  Evaluating the Performance of Software Distributed Shared Memory  </title>::line_number::0
<title> as a Target for Parallelizing Compilers   </title>::line_number::1
<author>  Alan L. Cox , Sandhya Dwarkadas , Honghui Lu and Willy Zwaenepoel    </author>::line_number::2
<affiliation>  Rice University   </affiliation>::line_number::3
<address>  Houston, TX 77005-1892   </address>::line_number::4
<email>  falc, hhl, willyg@cs.rice.edu   </email>::line_number::5
<affiliation>  University of Rochester   </affiliation>::line_number::6
<address>  Rochester, NY14627-0226   </address>::line_number::7
<email>  sandhya@cs.rochester.edu   </email>::line_number::8
<abstract>  Abstract  </abstract>::line_number::9
<abstract> In this paper, we evaluate the use of software distributed  </abstract>::line_number::10
<abstract> shared memory (DSM) on a message passing machine as  </abstract>::line_number::11
<abstract> the target for a parallelizing compiler. We compare this approach to compiler-generated message passing, hand-coded  </abstract>::line_number::12
<abstract> software DSM, and hand-coded message passing. For this  </abstract>::line_number::13
<abstract> comparison, we use six applications: four that are regular  </abstract>::line_number::14
<abstract> and two that are irregular.  </abstract>::line_number::15
<abstract> Our results are gathered on an 8-node IBM SP/2 using the TreadMarks software DSM system. We use the APR  </abstract>::line_number::16
<abstract> shared-memory (SPF) compiler to generate the shared memory programs, and the APR XHPF compiler to generate message passing programs. The hand-coded message passing  </abstract>::line_number::17
<abstract> programs run with the IBM PVMe optimized message passing library. On the regular programs, both the compiler-generated and the hand-coded message passing outperform  </abstract>::line_number::18
<abstract> the SPF/TreadMarks combination: the compiler-generated  </abstract>::line_number::19
<abstract> message passing by 5.5% to 40%, and the hand-coded  </abstract>::line_number::20
<abstract> message passing by 7.5% to 49%. On the irregular programs, the SPF/TreadMarks combination outperforms the  </abstract>::line_number::21
<abstract> compiler-generated message passing by 38% and 89%, and  </abstract>::line_number::22
<abstract> only slightly underperforms the hand-coded message passing, differing by 4.4% and 16%. We also identify the factors  </abstract>::line_number::23
<abstract> that account for the performance differences, estimate their  </abstract>::line_number::24
<abstract> relative importance, and describe methods to improve the  </abstract>::line_number::25
<abstract> performance.   </abstract>::line_number::26
<intro>  1. Introduction  </intro>::line_number::27

<title>  Carlsberg: A Distributed Execution Environment  </title>::line_number::0
<title> Providing Coherent Shared Memory and  </title>::line_number::1
<title> Integrated Message Passing   </title>::line_number::2
<note>  A Position/Work-in-Progress Paper presented at  </note>::line_number::3
<note> Nordic Workshop on Programming Environment Research, NWPER'94,  </note>::line_number::4
<note> Lund, Sweden, June, 1994   </note>::line_number::5
<author>  Povl T. Koch Robert J. Fowler   </author>::line_number::6
<affiliation>  Department of Computer Science, University of Copenhagen (DIKU)   </affiliation>::line_number::7
<address>  Universitetsparken 1, 2100 Copenhagen, Denmark   </address>::line_number::8
<phone>  Tel: +45 35 32 14 18 Fax: +45 35 32 14 01   E-mail: koch,fowler@diku.dk   </phone>::line_number::9
<abstract>  Abstract  </abstract>::line_number::10
<abstract> The Carlsberg prototype is a distributed operating system designed to provide efficient support for distributed-parallel applications on a cluster of high-performance workstations. A unique feature of Carlsberg is the integration of  </abstract>::line_number::11
<abstract> coherent shared memory, multithreading, and message passing in one system.  </abstract>::line_number::12
<abstract> In this paper we discuss the motivation for the Carlsberg system and we present  </abstract>::line_number::13
<abstract> aspects of its design.   </abstract>::line_number::14
<intro>  1 Introduction  </intro>::line_number::15

<note>  8th SIAM Conference on Parallel Processing for Scientific Computing, Minneapolis, MN, March 1997.   </note>::line_number::0
<title>  On the Accuracy of Anderson's Fast N-body Algorithm   </title>::line_number::1
<author>  Yu Charlie Hu S. Lennart Johnsson    </author>::line_number::2
<abstract>  Abstract  </abstract>::line_number::3
<abstract> We present an empirical study of the accuracy-cost tradeoffs of Anderson's method.  </abstract>::line_number::4
<abstract> The various parameters that control the degree of approximation of the computational  </abstract>::line_number::5
<abstract> elements and the separateness of interacting computational elements govern both the  </abstract>::line_number::6
<abstract> arithmetic complexity and the accuracy of the method. Our experiment shows that for  </abstract>::line_number::7
<abstract> a given error requirement, using a near-field containing only nearest neighbor boxes  </abstract>::line_number::8
<abstract> and a hierarchy depth that minimizes the number of arithmetic operations minimizes  </abstract>::line_number::9
<abstract> the total number of arithmetic operations.   </abstract>::line_number::10
<intro>  1 Introduction  </intro>::line_number::11

<note>  Reprinted from International Journal in Computer Simulation, Vol. 1, pp. 31-58 (1991)   </note>::line_number::0
<title>  The Efficient Simulation of Parallel Computer Systems   </title>::line_number::1
<author>  R. G. Covington   </author>::line_number::2
<affiliation>  Jet Propulsion Laboratory,   125-233  </affiliation>::line_number::3
<affiliation> 4800 Oak Grove Drive  </affiliation>::line_number::4
<affiliation> Pasadena, CA 91109   </affiliation>::line_number::5
<author>  S. Dwarkadas, J. R. Jump, and J. B. Sinclair   </author>::line_number::6
<affiliation>  Department of Electrical and Computer Engineering  </affiliation>::line_number::7
<affiliation> Rice University   </affiliation>::line_number::8
<address>  Houston, Texas 77251   </address>::line_number::9
<author>  S. Madala +L + </author>::line_number::10
<affiliation>  Coherent Systems, Inc.   </affiliation>::line_number::11
<address>  1000 Bay Area Blvd., Suite 206  </address>::line_number::12
<address> Houston, TX 77058   </address>::line_number::13
<abstract>  Abstract: An ongoing research project involves the design and evaluation of a software system  </abstract>::line_number::14
<abstract> for simulating parallel computers. A major goal in the development of this system was to avoid the  </abstract>::line_number::15
<abstract> high overhead associated with the conventional instruction-level simulation of sequential  </abstract>::line_number::16
<abstract> computers, but to retain the accuracy of that technique derived from its use of the execution of real  </abstract>::line_number::17
<abstract> programs. The resulting system is program-driven, but the overhead is significantly reduced by  </abstract>::line_number::18
<abstract> profiling the program to get timing estimates for its basic blocks, which are then used at run time to  </abstract>::line_number::19
<abstract> generate process execution times dynamically while avoiding a detailed emulation of each  </abstract>::line_number::20
<abstract> instruction's execution. A number of experiments dealing with message-passing computer  </abstract>::line_number::21
<abstract> systems have been performed in order to determine the level of accuracy that can be expected from  </abstract>::line_number::22
<abstract> its performance predictions and to measure its overhead.   </abstract>::line_number::23
<keyword>  Index Terms - Architecture models, efficiency, parallel computers, parallel programs,  </keyword>::line_number::24
<keyword> performance, simulation, testbed, validation.   </keyword>::line_number::25
<note>  This research was supported by Texas Instruments Grant No. TI720845RJ, NSF/ONR Grant No. N00014-87-K  </note>::line_number::26
<note> 0324, SDSU/SDIO Contract No. N66001-85-D-0203, NASA Grant No. NAG 0-208, and a Shell Doctoral  </note>::line_number::27
<note> Fellowship.   </note>::line_number::28
<page>  +PAGE+  </page>::line_number::29

<affiliation>  RICE UNIVERSITY   </affiliation>::line_number::0
<title>  Synchronization, Coherence, and Consistency for  </title>::line_number::1
<title> High Performance Shared-Memory  </title>::line_number::2
<title> Multiprocessing   </title>::line_number::3
<author>  by  </author>::line_number::4
<author> Sandhya Dwarkadas   </author>::line_number::5
<degree>  A Thesis Submitted  </degree>::line_number::6
<degree> in Partial Fulfillment of the  </degree>::line_number::7
<degree> Requirements for the Degree  </degree>::line_number::8
<degree> Doctor of Philosophy  </degree>::line_number::9
<degree> Approved, Thesis Committee:  </degree>::line_number::10
<degree> J Robert Jump, Co-Chairman  </degree>::line_number::11
<degree> Professor  </degree>::line_number::12
<degree> Electrical and Computer Engineering  </degree>::line_number::13
<degree> James B. Sinclair, Co-Chairman  </degree>::line_number::14
<degree> Associate Professor  </degree>::line_number::15
<degree> Electrical and Computer Engineering  </degree>::line_number::16
<degree> John K. Bennett  </degree>::line_number::17
<degree> Assistant Professor  </degree>::line_number::18
<degree> Electrical and Computer Engineering  </degree>::line_number::19
<degree> Ken Kennedy  </degree>::line_number::20
<degree> Professor  </degree>::line_number::21
<degree> Computer Science  </degree>::line_number::22
<degree> Houston, Texas   </degree>::line_number::23
<date>  September, 1992   </date>::line_number::24
<page>  +PAGE+  </page>::line_number::25

<title>  Theoretical Foundations of Association Rules   </title>::line_number::0
<author>  Mohammed J. Zaki and Mitsunori Ogihara    </author>::line_number::1
<affiliation>  Computer Science Department, University of Rochester,   Rochester NY 14627   </affiliation>::line_number::2
<email>  fzaki,ogiharag@cs.rochester.edu   </email>::line_number::3
<abstract>  Abstract  </abstract>::line_number::4
<abstract> In this paper we describe a formal framework for the problem of mining association rules. The theoretical foundation is based on the field of formal concept analysis. A concept is composed of closed subsets of attributes (itemsets)  </abstract>::line_number::5
<abstract> and objects (transactions). We show that all frequent itemsets are uniquely determined by the frequent concepts. We  </abstract>::line_number::6
<abstract> further show how this lattice-theoretic framework can be used to find a small rule generating set, from which one can  </abstract>::line_number::7
<abstract> infer all other association rules.   </abstract>::line_number::8
<intro>  1 Introduction  </intro>::line_number::9

<title>  On GDM's: Geometrically Deformed Models for the Extraction of Closed  </title>::line_number::0
<title> Shapes from Volume Data   </title>::line_number::1
<author>  By  </author>::line_number::2
<author> James Vradenburg Miller   </author>::line_number::3
<degree>  A Thesis Submitted to the Graduate  </degree>::line_number::4
<affiliation> Faculty of   Rensselaer Polytechnic Institute   </affiliation>::line_number::5
<degree>  in Partial Fulfillment of the  </degree>::line_number::6
<degree> Requirements for the Degree of  </degree>::line_number::7
<degree> Master of Science  </degree>::line_number::8
<degree> Approved:  </degree>::line_number::9
<degree> Dr. Michael J. Wozny  </degree>::line_number::10
<degree> Thesis Adviser   </degree>::line_number::11
<affiliation>  Rensselaer Polytechnic Institute   </affiliation>::line_number::12
<address>  Troy, New York   </address>::line_number::13
<date>  December 1990   </date>::line_number::14
<page>  +PAGE+  </page>::line_number::15

<title>  Modeling and the Adaptive Solution of  </title>::line_number::0
<title> CVD Fiber-Coating Processes   </title>::line_number::1
<author>  S. Adjerid, J. E. Flaherty, J. B. Hudson, and M. S. Shephard   </author>::line_number::2
<affiliation>  Scientific Computation Research Center  </affiliation>::line_number::3
<affiliation> Rensselaer Polytechnic Institute   </affiliation>::line_number::4
<address>  Troy, New York 12180, USA   </address>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> We develop a mathematical model for the coating of ceramic fibers by chemical vapor  </abstract>::line_number::7
<abstract> deposition (CVD) in cylindrical hot- or cold-walled reactors. The model couples the  </abstract>::line_number::8
<abstract> Navier-Stokes equations for the mixture of a carrier gas and precursor species, an energy  </abstract>::line_number::9
<abstract> equation for the gaseous mixture, a convection-diffusion system for the reacting precursor  </abstract>::line_number::10
<abstract> species, a fiber coating model, and a fiber heat conduction equation. The system is heated  </abstract>::line_number::11
<abstract> by a combination of conduction, convection, and radiation.  </abstract>::line_number::12
<abstract> The partial differential system resulting from this model is solved by adaptive finite element software using automatic mesh refinement and coarsening on a quadtree-structured  </abstract>::line_number::13
<abstract> mesh. The results of parameter studies indicate the effectiveness of using adaptive solution techniques with CVD applications and also suggest some guidance for improving  </abstract>::line_number::14
<abstract> the process.   </abstract>::line_number::15
<intro>  1 Introduction  </intro>::line_number::16

<title>  Automated Design Optimization for the P2 and P8  </title>::line_number::0
<title> Hypersonic Inlets   </title>::line_number::1
<author>  Vijay Shukla , Andrew Gelsey , Mark Schwabacher   </author>::line_number::2
<author> Donald Smith , Doyle D. Knight   </author>::line_number::3
<affiliation>  Rutgers, the State University of New Jersey   </affiliation>::line_number::4
<address>  New Brunswick, NJ 08903   </address>::line_number::5
<date>  February 20, 1997   </date>::line_number::6
<note>  To appear in Journal of Aircraft, Vol 34, No. 2, March-April 1997  </note>::line_number::7
<note> Copyright c by Vijay Shukla, Andrew Gelsey, Mark Schwabacher, Donald Smith and Doyle D. Knight.   </note>::line_number::8
<abstract>  Abstract  </abstract>::line_number::9
<abstract> An automated design methodology incorporating industry-standard Navier-Stokes  </abstract>::line_number::10
<abstract> codes and a gradient-based optimizer has been developed. This system is used to redesign the well-known NASA P2 and P8 hypersonic inlets. First, the Navier-Stokes  </abstract>::line_number::11
<abstract> simulations of the original P2 and P8 inlet designs are validated using numerical convergence studies and comparison with wind-tunnel experimental data for the original  </abstract>::line_number::12
<abstract> inlets published by NASA in the early 1970s. Second, the P2 and P8 inlets are redesigned with the objective of canceling the cowl shock (and, in the case of the P8  </abstract>::line_number::13
<abstract> inlet, the additional cowl-generated compression) at the centerbody by appropriate  </abstract>::line_number::14
<abstract> contouring of the centerbody boundary. The original inlets were intended to achieve  </abstract>::line_number::15
<abstract> these same objectives, but detailed experimental measurements indicated that a substantial reflected shock system was present. The choice of the objective function, which  </abstract>::line_number::16
<abstract> is used to drive the optimization, has a significant impact on the final design. Several  </abstract>::line_number::17
<abstract> different formulations for the objective function have been employed, and improvements of 60% to 90% in the objective function have been achieved. This automated  </abstract>::line_number::18
<abstract> design system represents one of the first successful combinations of numerical optimization methods with Reynolds-averaged Navier-Stokes fluid dynamics simulation for high  </abstract>::line_number::19
<abstract> speed inlets, and demonstrates a new area in which High Performance Computing may  </abstract>::line_number::20
<abstract> have considerable impact on problems of military and industrial significance.   </abstract>::line_number::21
<affiliation>  Postdoctoral Research Associate, Dept. of Mechanical and Aerospace Engineering. AIAA Member.  </affiliation>::line_number::22
<affiliation> Assistant Professor, Computer Science Dept. AIAA Member.  </affiliation>::line_number::23
<affiliation> Graduate Student, Computer Science Dept.  </affiliation>::line_number::24
<affiliation> Assistant Professor, Computer Science Dept.  </affiliation>::line_number::25
<affiliation> Professor, Dept. of Mechanical and Aerospace Engineering. AIAA Associate Fellow.   </affiliation>::line_number::26
<page>  +PAGE+  </page>::line_number::27

<note>  To be presented at the AAAI/ICML 1998 Workshop on Predicting the Future: AI Approaches to Time-Series Analysis 1   </note>::line_number::0
<title>  Predicting Sequences of User Actions   </title>::line_number::1
<author>  Brian D. Davison and Haym Hirsh   </author>::line_number::2
<affiliation>  Department of Computer Science  </affiliation>::line_number::3
<affiliation> Rutgers, The State University of New Jersey   </affiliation>::line_number::4
<address>  New Brunswick, NJ 08903 USA   </address>::line_number::5
<email>  fdavison,hirshg@cs.rutgers.edu   </email>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> People display regularities in almost everything they do. This  </abstract>::line_number::8
<abstract> paper proposes characteristics of an idealized algorithm that,  </abstract>::line_number::9
<abstract> when applied to sequences of user actions, would allow a user  </abstract>::line_number::10
<abstract> interface to adapt over time to an individual's pattern of use.  </abstract>::line_number::11
<abstract> We describe a simple predictive method with these characteristics and show its predictive accuracy on a large dataset of  </abstract>::line_number::12
<abstract> UNIX commands to be at least as good as others that have  </abstract>::line_number::13
<abstract> been considered, while using fewer computational and memory resources.   </abstract>::line_number::14
<intro>  Motivation  </intro>::line_number::15

<title>  Towards a Cost-Effective Parallel Data Mining Approach   </title>::line_number::0
<author>  Zoltan Jarai, Aashu Virmani, Liviu Iftode   </author>::line_number::1
<affiliation>  Department of Computer Science  </affiliation>::line_number::2
<affiliation> Rutgers University   </affiliation>::line_number::3
<address>  Piscataway, NJ 08854   </address>::line_number::4
<email>  fjarai,avirmanig@paul.rutgers.edu, iftode@cs.rutgers.edu   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Massive rule induction has recently emerged as one of the  </abstract>::line_number::7
<abstract> powerful data mining techniques. The problem is known to  </abstract>::line_number::8
<abstract> be exponential in the size of the attributes, and given its ever  </abstract>::line_number::9
<abstract> increasing use, can greatly benefit from parallelization.  </abstract>::line_number::10
<abstract> In this paper, we study cost-effective approaches to paral-lelize rule generation algorithms. In particular, we consider  </abstract>::line_number::11
<abstract> the propositional rule generation algorithm of the Discovery  </abstract>::line_number::12
<abstract> Board system, and present our design and implementation of  </abstract>::line_number::13
<abstract> a parallel algorithm for the same task. We then present some  </abstract>::line_number::14
<abstract> early performance results of our parallelization scheme on  </abstract>::line_number::15
<abstract> hardware and software distributed shared memory multiprocessors.   </abstract>::line_number::16
<intro>  1 Introduction  </intro>::line_number::17

<title>  Intelligent Model Selection for Hillclimbing Search in  </title>::line_number::0
<title> Computer-Aided Design   </title>::line_number::1
<author>  Thomas Ellman John Keane Mark Schwabacher   </author>::line_number::2
<affiliation>  Department of Computer Science, Hill Center for Mathematical Sciences  </affiliation>::line_number::3
<address> Rutgers University,   New Brunswick, NJ 08903   </address>::line_number::4
<email>  fellman,keane,schwabacg@cs.rutgers.edu   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Models of physical systems can differ according to  </abstract>::line_number::7
<abstract> computational cost, accuracy and precision, among  </abstract>::line_number::8
<abstract> other things. Depending on the problem solving  </abstract>::line_number::9
<abstract> task at hand, different models will be appropriate. Several investigators have recently developed  </abstract>::line_number::10
<abstract> methods of automatically selecting among multiple models of physical systems. Our research is  </abstract>::line_number::11
<abstract> novel in that we are developing model selection  </abstract>::line_number::12
<abstract> techniques specifically suited to computer-aided de  </abstract>::line_number::13
<abstract> sign. Our approach is based on the idea that artifact performance models for computer-aided design  </abstract>::line_number::14
<abstract> should be chosen in light of the design decisions  </abstract>::line_number::15
<abstract> they are required to support. We have developed  </abstract>::line_number::16
<abstract> a technique called "Gradient Magnitude Model Selection" (GMMS), which embodies this principle.  </abstract>::line_number::17
<abstract> GMMS operates in the context of a hillclimbing  </abstract>::line_number::18
<abstract> search process. It selects the simplest model that  </abstract>::line_number::19
<abstract> meets the needs of the hillclimbing algorithm in  </abstract>::line_number::20
<abstract> which it operates. We are using the domain of sailing yacht design as a testbed for this research. We  </abstract>::line_number::21
<abstract> have implemented GMMS and used it in hillclimb-ing search to decide between a computationally expensive potential-flow program and an algebraic  </abstract>::line_number::22
<abstract> approximation to analyze the performance of sailing yachts. Experimental tests show that GMMS  </abstract>::line_number::23
<abstract> makes the design process faster than it would be if  </abstract>::line_number::24
<abstract> the most expensive model were used for all design  </abstract>::line_number::25
<abstract> evaluations. GMMS achieves this performance improvement with little or no sacrifice in the quality  </abstract>::line_number::26
<abstract> of the resulting design.   </abstract>::line_number::27
<intro>  1. Introduction  </intro>::line_number::28

<title>  Why Should Architectural Principles be  </title>::line_number::0
<title> Enforced?   </title>::line_number::1
<author>  Naftaly H. Minsky    </author>::line_number::2
<email>  minsky@cs.rutgers.edu   </email>::line_number::3
<affiliation>  Department of Computer Science  </affiliation>::line_number::4
<affiliation> Rutgers University   </affiliation>::line_number::5
<address>  New Brunswick, NJ, 08903 USA   </address>::line_number::6
<date>  August 12, 1998   </date>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> There is an emerging consensus that an explicit architectural model  </abstract>::line_number::9
<abstract> would be invaluable for large evolving software systems, providing them  </abstract>::line_number::10
<abstract> with a framework within which such a system can be reasoned about and  </abstract>::line_number::11
<abstract> maintained. But the great promise of architectural models has not been  </abstract>::line_number::12
<abstract> fulfilled so far, due to a gap between the model and the system it purports  </abstract>::line_number::13
<abstract> to describe. It is our contention that this gap is best bridged if the model  </abstract>::line_number::14
<abstract> is not just stated, but is enforced.  </abstract>::line_number::15
<abstract> This gives rise to a concept enforced architectural model |or, a law |  </abstract>::line_number::16
<abstract> which is explored in this paper. We argue that this model has two major beneficial consequences: First, by bridging the above mentioned gap  </abstract>::line_number::17
<abstract> between an architectural model and the actual system, an enforced architectural model provides a truly reliable framework within which a system  </abstract>::line_number::18
<abstract> can be reasoned about and maintained. Second, our model provides software developers with a carefully circumscribed flexibility in molding the  </abstract>::line_number::19
<abstract> law of a project, during its evolutionary lifetime|while maintaining certain architectural principles as invariant of evolution.   </abstract>::line_number::20
<keyword>  Keywords: architectural model, law-governed software, evolution, in  </keyword>::line_number::21
<keyword> variants of evolution, firewalls, protection.   </keyword>::line_number::22
<note>  Work supported in part by NSF grants No. CCR-9308773   </note>::line_number::23
<page>  +PAGE+  </page>::line_number::24

<title>  Imposing The Law of Demeter and Its Variations   </title>::line_number::0
<author>  Partha pratim Pal    </author>::line_number::1
<email>  partha@cs.rutgers.edu   </email>::line_number::2
<author>  Naftaly H. Minsky    </author>::line_number::3
<email>  minsky@cs.rutgers.edu   </email>::line_number::4
<affiliation>  Department of Computer Science  </affiliation>::line_number::5
<affiliation> Rutgers University   </affiliation>::line_number::6
<address>  New Brunswick, NJ 08903   </address>::line_number::7
<date>  February 28, 1996   </date>::line_number::8
<abstract>  Abstract  </abstract>::line_number::9
<abstract> The Law of Demeter [4] is accepted as a useful design principle that  </abstract>::line_number::10
<abstract> promotes tightly encapsulated classes and reduced coupling. Principles  </abstract>::line_number::11
<abstract> like this are routinely adopted in real-life projects, however neither the  </abstract>::line_number::12
<abstract> programming languages nor the existing environments provide enough  </abstract>::line_number::13
<abstract> support for effective realization of these principles. It is our thesis  </abstract>::line_number::14
<abstract> that broad structural principles should be formally specified, strictly  </abstract>::line_number::15
<abstract> enforced, and relaxed whenever relaxation is in order. In this paper  </abstract>::line_number::16
<abstract> we show how this can be done under our darwin-E environment using,  </abstract>::line_number::17
<abstract> the Law of Demeter as an illustration.   </abstract>::line_number::18
<keyword>  keywords: Law of Demeter, Law-Governed Architecture, Software  </keyword>::line_number::19
<keyword> Engineering Principles, Enforcement.   </keyword>::line_number::20
<intro>  1 Introduction  </intro>::line_number::21

<title>  Learning Novel Domains Through Curiosity and Conjecture   </title>::line_number::0
<author>  Paul D. Scott & Shaul Markovitch   </author>::line_number::1
<affiliation>  Center for Machine Intelligence   </affiliation>::line_number::2
<address>  2001,Commonwealth Blvd.,  </address>::line_number::3
<address> Ann Arbor, Michigan 48105   </address>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> This paper describes DIDO, a system we have  </abstract>::line_number::6
<abstract> developed to carry out exploratory learning of  </abstract>::line_number::7
<abstract> unfamiliar domains without assistance from an  </abstract>::line_number::8
<abstract> external teacher. The program incorporates novel  </abstract>::line_number::9
<abstract> approaches to experience generation and representation  </abstract>::line_number::10
<abstract> generation. The experience generator uses a heuristic  </abstract>::line_number::11
<abstract> based on Shannon's uncertainty function to find  </abstract>::line_number::12
<abstract> informative examples. The representation generator  </abstract>::line_number::13
<abstract> makes conjectures on the basis of small amounts of  </abstract>::line_number::14
<abstract> evidence and retracts them if they prove to be wrong  </abstract>::line_number::15
<abstract> or useless. A number of experiments are described  </abstract>::line_number::16
<abstract> which demonstrate that the system can distribute its  </abstract>::line_number::17
<abstract> learning resources to steadily acquire a good  </abstract>::line_number::18
<abstract> representation of the whole of a domain, and that the  </abstract>::line_number::19
<abstract> system can readily acquire both disjunctive and  </abstract>::line_number::20
<abstract> conjunctive concepts even in the presence of noise.   </abstract>::line_number::21
<intro>  1. Introduction  </intro>::line_number::22

<title>  Distributed parallel shooting for BVODEs   </title>::line_number::0
<author>  K.L. Chow and W.H. Enright   </author>::line_number::1
<affiliation>  Department of Computer Science, University of Toronto   </affiliation>::line_number::2
<email>  E-mail : chow@cs.toronto.edu and enright@cs.toronto.edu   </email>::line_number::3
<abstract>  Abstract  </abstract>::line_number::4
<abstract> Many important scientific problems can be formulated as systems of ordinary differential equations with two-point boundary value constraints (BVODE). Multiple shooting  </abstract>::line_number::5
<abstract> is one of the most widely used numerical techniques for solving BVODE problems.  </abstract>::line_number::6
<abstract> In this work, we present a new distributed parallel numerical algorithm for BVODEs  </abstract>::line_number::7
<abstract> which is based on multiple shooting. We investigate the numerical stability of this  </abstract>::line_number::8
<abstract> new distributed algorithm and identify difficulties that can arise. We propose a new  </abstract>::line_number::9
<abstract> parallel iterative refinement scheme to cope with some specific numerical difficulties  </abstract>::line_number::10
<abstract> identified in our investigation. Computational experience is presented to demonstrate  </abstract>::line_number::11
<abstract> the potential effectiveness of our approach.   </abstract>::line_number::12
<keyword>  Keywords: Distributed parallel algorithm, boundary value problems, multiple shooting   </keyword>::line_number::13
<intro>  1 Introduction  </intro>::line_number::14

<title>  Practical PAC Learning   </title>::line_number::0
<author>  Dale Schuurmans   </author>::line_number::1
<affiliation>  Department of Computer Science  </affiliation>::line_number::2
<affiliation> University of Toronto   </affiliation>::line_number::3
<address>  Toronto, Ontario M5S 1A4, Canada   </address>::line_number::4
<email>  dale@cs.toronto.edu   </email>::line_number::5
<author>  Russell Greiner   </author>::line_number::6
<affiliation>  Siemens Corporate Research   </affiliation>::line_number::7
<address>  Princeton, NJ 08540, USA   </address>::line_number::8
<email>  greiner@scr.siemens.com   </email>::line_number::9
<note>  Appears in  </note>::line_number::10
<note> Proceedings of the Fourteenth International Conference on Artificial Intelligence (IJCAI-95),  </note>::line_number::11
<note> Montreal, August 1995.   </note>::line_number::12
<abstract>  Abstract  </abstract>::line_number::13
<abstract> We present new strategies for "probably approximately correct" (pac) learning that use  </abstract>::line_number::14
<abstract> fewer training examples than previous approaches. The idea is to observe training examples one-at-a-time and decide "on-line" when to  </abstract>::line_number::15
<abstract> return a hypothesis, rather than collect a large  </abstract>::line_number::16
<abstract> fixed-size training sample. This yields sequential learning procedures that pac-learn by observing a small random number of examples.  </abstract>::line_number::17
<abstract> We provide theoretical bounds on the expected  </abstract>::line_number::18
<abstract> training sample size of our procedure | but establish its efficiency primarily by a series of experiments which show sequential learning actually uses many times fewer training examples in  </abstract>::line_number::19
<abstract> practice. These results demonstrate that pac-learning can be far more efficiently achieved in  </abstract>::line_number::20
<abstract> practice than previously thought.   </abstract>::line_number::21
<intro>  1 Introduction  </intro>::line_number::22

<title>  Continuous sigmoidal belief networks  </title>::line_number::0
<title> trained using slice sampling   </title>::line_number::1
<author>  Brendan J. Frey   </author>::line_number::2
<affiliation>  Department of Computer Science, University of Toronto   </affiliation>::line_number::3
<address>  6 King's College Road, Toronto, Canada M5S 1A4   </address>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> Real-valued random hidden variables can be useful for modelling  </abstract>::line_number::6
<abstract> latent structure that explains correlations among observed variables. I propose a simple unit that adds zero-mean Gaussian noise  </abstract>::line_number::7
<abstract> to its input before passing it through a sigmoidal squashing function. Such units can produce a variety of useful behaviors, ranging  </abstract>::line_number::8
<abstract> from deterministic to binary stochastic to continuous stochastic. I  </abstract>::line_number::9
<abstract> show how "slice sampling" (Neal 1996) can be used for inference  </abstract>::line_number::10
<abstract> and learning in top-down networks of these units and demonstrate  </abstract>::line_number::11
<abstract> learning on two simple problems.   </abstract>::line_number::12
<intro>  1 Introduction  </intro>::line_number::13

<title>  Learning Useful Horn Approximations   </title>::line_number::0
<author>  Russell Greiner    </author>::line_number::1
<address>  755 College Road East   </address>::line_number::2
<affiliation>  Siemens Corporate Research   </affiliation>::line_number::3
<address>  Princeton, NJ 08540   </address>::line_number::4
<email>  greiner@learning.siemens.com   </email>::line_number::5
<author>  Dale Schuurmans   </author>::line_number::6
<affiliation>  Department of Computer Science  </affiliation>::line_number::7
<affiliation> University of Toronto   </affiliation>::line_number::8
<address>  Toronto, Ontario M5S 1A4   </address>::line_number::9
<email>  dale@cs.toronto.edu   </email>::line_number::10
<abstract>  Abstract  </abstract>::line_number::11
<abstract> While the task of answering queries from an  </abstract>::line_number::12
<abstract> arbitrary propositional theory is intractable in  </abstract>::line_number::13
<abstract> general, it can typically be performed efficiently  </abstract>::line_number::14
<abstract> if the theory is Horn. This suggests that it  </abstract>::line_number::15
<abstract> may be more efficient to answer queries using a "Horn approximation"; i.e., a horn theory that is semantically similar to the original  </abstract>::line_number::16
<abstract> theory. The utility of any such approximation  </abstract>::line_number::17
<abstract> depends on how often it produces answers to  </abstract>::line_number::18
<abstract> the queries that the system actually encounters;  </abstract>::line_number::19
<abstract> we therefore seek an approximation whose expected "coverage" is maximal. Unfortunately,  </abstract>::line_number::20
<abstract> there are several obstacles to achieving this goal  </abstract>::line_number::21
<abstract> in practice: (i) The optimal approximation depends on the query distribution, which is typically not known a priori; (ii) identifying the optimal approximation is intractable, even given  </abstract>::line_number::22
<abstract> the query distribution; and (iii) the optimal approximation might be too large to guarantee  </abstract>::line_number::23
<abstract> tractable inference. This paper presents an approach that overcomes (or side-steps) each of  </abstract>::line_number::24
<abstract> these obstacles. We define a learning process,  </abstract>::line_number::25
<abstract> AdComp, that uses observed queries to estimate the query distribution "online", and then  </abstract>::line_number::26
<abstract> uses these estimates to hill-climb, efficiently,  </abstract>::line_number::27
<abstract> in the space of size-bounded Horn approximations, until reaching one that is, with provably  </abstract>::line_number::28
<abstract> high probability, effectively at a local optimum.   </abstract>::line_number::29
<note>  Appears in the  </note>::line_number::30
<note> Proceedings of the Third International Conference on Knowledge Representation and Reasoning,  </note>::line_number::31
<note> 25-29 October 1992, Cambridge, MA.   </note>::line_number::32
<intro>  1 Introduction  </intro>::line_number::33

<title>  Powers of Trees   </title>::line_number::0
<author>  Paul E. Kearney and Derek G. Corneil   </author>::line_number::1
<affiliation>  Department of Computer Science, University of Toronto,   </affiliation>::line_number::2
<address>  Toronto ON, CANADA M5S 1A4   </address>::line_number::3
<email>  kearney@cs.toronto.edu  </email>::line_number::4
<email> dgc@cs.toronto.edu   </email>::line_number::5
<abstract>  Abstract. We present the first polynomial algorithm for recognizing tree powers. A graph G  </abstract>::line_number::6
<abstract> is a tree power if there is a tree T and a positive integer k such that T k ~ = G where x and are  </abstract>::line_number::7
<abstract> adjacent in T k if and only if d T (x; ) k. We also show that a natural extension of tree power  </abstract>::line_number::8
<abstract> recognition is NP-complete, namely, given a graph G and a positive integer r, determine if  </abstract>::line_number::9
<abstract> there is a tree power within r edges of G.   </abstract>::line_number::10
<intro>  1 Introduction  </intro>::line_number::11

<title>  Coding Segments Inside and Outside the Chromosome   </title>::line_number::0
<author>  Thomas Haynes   </author>::line_number::1
<affiliation>  Department of Computer Science  </affiliation>::line_number::2
<affiliation> Wichita State University   </affiliation>::line_number::3
<address>  Wichita, KS 67260   </address>::line_number::4
<email>  E-mail: haynes@cs.twsu.edu   </email>::line_number::5
<phone>  Phone: (316) 978-3925   </phone>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> Coding segments are those sub-segments of the chromosome which contribute either positively or  </abstract>::line_number::8
<abstract> negatively to the fitness evaluation of the chromosome. We extract coding segments from chromosomes  </abstract>::line_number::9
<abstract> and we investigate the sharing of coding segments both inside and outside of the chromosome. We  </abstract>::line_number::10
<abstract> find duplication of coding segments inside the chromosomes provides a back-up mechanism for the  </abstract>::line_number::11
<abstract> search heuristics. We further find local search in a collective memory of coding segments outside of the  </abstract>::line_number::12
<abstract> chromosome, collective adaptation, enables the search heuristic to represent partial solutions which are  </abstract>::line_number::13
<abstract> larger than realistic chromosomes lengths and to express the solution outside of the chromosome.   </abstract>::line_number::14
<page>  +PAGE+  </page>::line_number::15

<title>  Learning to Select Useful Landmarks   </title>::line_number::0
<author>  Russell Greiner   </author>::line_number::1
<affiliation>  Siemens Corporate Research   </affiliation>::line_number::2
<address>  Princeton, NJ 08540   </address>::line_number::3
<email>  greiner@learning.siemens.com   </email>::line_number::4
<author>  Ramana Isukapalli   </author>::line_number::5
<affiliation>  Department of Computer Science  </affiliation>::line_number::6
<affiliation> Rutgers University   </affiliation>::line_number::7
<email>  ramana@cs.rutgers.edu   </email>::line_number::8
<note>  Appears in the  </note>::line_number::9
<note> Proceedings of the Twelfth National Conference on Artificial Intelligence (AAAI-94),  </note>::line_number::10
<note> Seattle, Washington, July 1994.   </note>::line_number::11
<abstract>  Abstract  </abstract>::line_number::12
<abstract> To navigate effectively, an autonomous agent must be  </abstract>::line_number::13
<abstract> able to quickly and accurately determine its current  </abstract>::line_number::14
<abstract> location. Given an initial estimate of its position (perhaps based on dead-reckoning) and an image taken of  </abstract>::line_number::15
<abstract> a known environment, our agent first attempts to locate a set of landmarks (real-world objects at known  </abstract>::line_number::16
<abstract> locations), then uses their angular separation to obtain an improved estimate of its current position. Unfortunately, some landmarks may not be visible, or  </abstract>::line_number::17
<abstract> worse, may be confused with other landmarks, resulting in both time wasted in searching for invisible landmarks, and in further errors in the agent's estimate of  </abstract>::line_number::18
<abstract> its position. To address these problems, we propose a  </abstract>::line_number::19
<abstract> method that uses previous experiences to learn a selection function that, given the set of landmarks that  </abstract>::line_number::20
<abstract> might be visible, returns the subset which can reliably  </abstract>::line_number::21
<abstract> be found correctly, and so provide an accurate registration of the agent's position. We use statistical techniques to prove that the learned selection function is,  </abstract>::line_number::22
<abstract> with high probability, effectively at a local optimal in  </abstract>::line_number::23
<abstract> the space of such functions. This report also presents  </abstract>::line_number::24
<abstract> empirical evidence, using real-world data, that demonstrate the effectiveness of our approach.   </abstract>::line_number::25
<intro>  1. Introduction  </intro>::line_number::26

<title>  Support for Implementation of Evolutionary  </title>::line_number::0
<title> Concurrent Systems in Concurrent  </title>::line_number::1
<title> Programming Languages   </title>::line_number::2
<author>  Raju Pandey 1 and J. C. Browne 2   </author>::line_number::3
<affiliation>  1 Computer Science Department, University of California,   Davis, CA 95616    2 Department of Computer Sciences, The University of Texas,   Austin, TX 78712   </affiliation>::line_number::4
<abstract>  Abstract. In many concurrent programming languages, concurrent programs are difficult to extend and modify: small changes in a concurrent  </abstract>::line_number::5
<abstract> program may require re-implementations of a large number of its components. In this paper a novel concurrent program composition mechanism  </abstract>::line_number::6
<abstract> is presented in which implementations of computations and synchronizations are completely separated. Separation of implementations facilitates  </abstract>::line_number::7
<abstract> extensions and modifications of programs by allowing one to change implementations of both computations and synchronizations. The paper  </abstract>::line_number::8
<abstract> also describes a concurrent programming model and a programming lan  </abstract>::line_number::9
<abstract> guage that support the proposed approach.   </abstract>::line_number::10
<intro>  1 Introduction  </intro>::line_number::11

<title>  A VARIABLE TIME STEP METHOD FOR AN AGE-DEPENDENT  </title>::line_number::0
<title> POPULATION MODEL WITH NONLINEAR DIFFUSION   </title>::line_number::1
<author>  BRUCE P. AYATI    </author>::line_number::2
<abstract>  Abstract. We propose a method for solving a model of age-dependent population diusion  </abstract>::line_number::3
<abstract> with random dispersal. This method, unlike previous methods, allows for variable time steps and  </abstract>::line_number::4
<abstract> independent age and time discretizations. We use a moving age discretization that transforms the  </abstract>::line_number::5
<abstract> problem to a system of parabolic equations. The system is then solved by backward dierences in  </abstract>::line_number::6
<abstract> time and a Galerkin approximation in space; the equations that need to be solved at each step treat  </abstract>::line_number::7
<abstract> each age group separately. A priori L 2 error estimates are obtained by an energy analysis. These  </abstract>::line_number::8
<abstract> estimates are superconvergent in the age variable. We present a postprocessing technique which  </abstract>::line_number::9
<abstract> capitalizes on the superconvergence.   </abstract>::line_number::10
<keyword>  Key words. population dynamics, age-dependence, nonlinear diusion, variable time steps,  </keyword>::line_number::11
<keyword> superconvergence, postprocessing.  </keyword>::line_number::12
<keyword> AMS subject classitcations. 35Q80, 65M06, 65M15, 65M60, 92D25.   </keyword>::line_number::13
<intro>  1. Introduction. In this paper, we consider a numerical method for solving an  </intro>::line_number::14

<note>  ISSN 1360-1725   </note>::line_number::0
<title>  The Test Matrix Toolbox for Matlab (Version 3.0)   </title>::line_number::1
<author>  N. J. Higham   </author>::line_number::2
<pubnum>  Numerical Analysis Report No. 276   </pubnum>::line_number::3
<date>  September 1995   </date>::line_number::4
<note>  Manchester Centre for Computational Mathematics  </note>::line_number::5
<note> Numerical Analysis Reports  </note>::line_number::6
<note> DEPARTMENTS OF MATHEMATICS  </note>::line_number::7
<note> Reports available from:   </note>::line_number::8
<affiliation>  Department of Mathematics  </affiliation>::line_number::9
<affiliation> University of Manchester   </affiliation>::line_number::10
<address>  Manchester M13 9PL  </address>::line_number::11
<address> England   </address>::line_number::12
<note>  And over the World-Wide Web from URLs   </note>::line_number::13
<web>  http://www.ma.man.ac.uk/MCCM/MCCM.html  </web>::line_number::14
<web> ftp://ftp.ma.man.ac.uk/pub/narep   </web>::line_number::15
<page>  +PAGE+  </page>::line_number::16

<title>  User-Defined Aggregates  </title>::line_number::0
<title> for Logical Data Languages   </title>::line_number::1
<author>  Haixun Wang and Carlo Zaniolo   </author>::line_number::2
<affiliation>  Computer Science Department  </affiliation>::line_number::3
<affiliation> University of California at Los Angeles   </affiliation>::line_number::4
<address>  Los Angeles, CA 90095   </address>::line_number::5
<email>  hxwang@cs.ucla.edu zaniolo@cs.ucla.edu   </email>::line_number::6
<abstract>  Abstract. A new wave of data-intensive and knowledge-based applications|such as data  </abstract>::line_number::7
<abstract> mining and decision support|require the introduction of complex application-specific aggregate functions. In this paper, we propose extensions for deductive database systems to  </abstract>::line_number::8
<abstract> support these new applications. We develop constructs, formal semantics, and implementation techniques for user-defined aggregates, and describe their realization in an extended  </abstract>::line_number::9
<abstract> LDL++ system recently built at UCLA. With these extensions, the system can support online aggregation, roll-ups for data cubing, temporal aggregates for time-series, iceberg queries,  </abstract>::line_number::10
<abstract> and other recently proposed operators used in decision support and data mining procedures.  </abstract>::line_number::11
<abstract> We then discuss the application of this technology to other DBMSs, and in particular to the  </abstract>::line_number::12
<abstract> SQL3 specifications that support the notion of user-defined aggregates. We show that SQL3  </abstract>::line_number::13
<abstract> suffers from limitations that severely restrict its use in new applications; thus we propose  </abstract>::line_number::14
<abstract> simple extensions similar to those used for LDL++ to overcome such limitations.   </abstract>::line_number::15
<intro>  1 Introduction  </intro>::line_number::16

<title>  Greedy Algorithms in  </title>::line_number::0
<title> Greedy with Choice and Negation    </title>::line_number::1
<author>  Sergio Greco Carlo Zaniolo   </author>::line_number::2
<affiliation>  Dip: Elettr: Informatica Sist: Computer Science Dept:  </affiliation>::line_number::3
<affiliation> Universita della Calabria Univ: of California at Los Angeles   </affiliation>::line_number::4
<address>  87030 Rende; Italy LosAngeles; CA 90024   </address>::line_number::5
<email>  greco@si:deis:unical:it zaniolo@cs:ucla:edu   </email>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> In the design of algorithms, the greedy paradigm provides a powerful tool for solving  </abstract>::line_number::8
<abstract> efficiently classical computational problems, within the framework of procedural languages. However, expressing these algorithms within the declarative framework of logic-based languages has proved to be a difficult research challenge. In this paper, we extend the framework of Datalog-like languages to obtain simple declarative formulations  </abstract>::line_number::9
<abstract> for such problems, and propose effective implementation techniques to ensure computational complexities comparable to those of procedural formulations. These advances are  </abstract>::line_number::10
<abstract> achieved through the use of the choice construct, that has semantics reducible to that of  </abstract>::line_number::11
<abstract> programs with negation under stable model semantics. Then we extend the fixpoint-based  </abstract>::line_number::12
<abstract> semantics of choice programs with preference annotations to guide search strategies and  </abstract>::line_number::13
<abstract> simple logic-based formulations of classical greedy algorithms.   </abstract>::line_number::14
<intro>  1 Introduction  </intro>::line_number::15

<title>  Semantics-based Failure Recovery in Distributed Systems  </title>::line_number::0
<title> with Optimistic Message Logging    </title>::line_number::1
<author>  Hong Va Leong Divyakant Agrawal    </author>::line_number::2
<affiliation>  Department of Computer Science  </affiliation>::line_number::3
<affiliation> University of California   </affiliation>::line_number::4
<address>  Santa Barbara, CA 93106   </address>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Recovery from failures is important in distributed computing. A common technique to support  </abstract>::line_number::7
<abstract> recovery is asynchronous checkpointing, coupled with optimistic message logging. These schemes have  </abstract>::line_number::8
<abstract> low overheads during failure-free operations and can provide an acceptable degree of fault-tolerance.  </abstract>::line_number::9
<abstract> Central to these protocols is the determination of a maximal consistent global state, which is recoverable.  </abstract>::line_number::10
<abstract> Message semantics is not exploited in most existing recovery protocols to determine the recoverable state.  </abstract>::line_number::11
<abstract> We propose to identify messages that are not influential in the computation through message semantics.  </abstract>::line_number::12
<abstract> These messages can be logically removed from the computation without changing its meaning or result.  </abstract>::line_number::13
<abstract> In this paper, we illustrate with examples how the removal of these messages improves the theoretical  </abstract>::line_number::14
<abstract> maximal consistent global state. Taking semantics into account, recovery protocols are then developed  </abstract>::line_number::15
<abstract> to realize the idea. The semantics in object-oriented databases is adapted to special processes acting as  </abstract>::line_number::16
<abstract> servers for further improvements. This technique can also be applied to ensure a more timely commitment  </abstract>::line_number::17
<abstract> for output in a distributed computation.   </abstract>::line_number::18
<keyword>  Keywords: message semantics, commutativity, recovery, optimistic message logging, asynchronous  </keyword>::line_number::19
<keyword> checkpointing   </keyword>::line_number::20
<note>  An abridged version of this paper appears in the Proceedings of the 14th International Conference on Distributed Computing  </note>::line_number::21
<note> Systems as Using Message Semantics to Reduce Rollback in Optimistic Message Logging Recovery Schemes.  </note>::line_number::22
<note> This research is supported in part by the NSF under grant number IRI-9117094.   </note>::line_number::23
<page>  +PAGE+  </page>::line_number::24

<title>  Run-time Compilation for Parallel Sparse Matrix Computations   </title>::line_number::0
<author>  Cong Fu and Tao Yang   </author>::line_number::1
<affiliation>  Department of Computer Science  </affiliation>::line_number::2
<affiliation> University of California,   </affiliation>::line_number::3
<address>  Santa Barbara, CA 93106.   </address>::line_number::4
<web>  http://www.cs.ucsb.edu/f~cfu,~tyangg   </web>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Run-time compilation techniques have been shown effective  </abstract>::line_number::7
<abstract> for automating the parallelization of loops with unstructured  </abstract>::line_number::8
<abstract> indirect data accessing patterns. However, it is still an open  </abstract>::line_number::9
<abstract> problem to efficiently parallelize sparse matrix factorizations  </abstract>::line_number::10
<abstract> commonly used in iterative numerical problems. The difficulty is that a factorization process contains irregularly-interleaved communication and computation with varying  </abstract>::line_number::11
<abstract> granularities and it is hard to obtain scalable performance  </abstract>::line_number::12
<abstract> on distributed memory machines. In this paper, we present  </abstract>::line_number::13
<abstract> an inspector/executor approach for parallelizing such applications by embodying automatic graph scheduling techniques to optimize interleaved communication and computation. We describe a run-time system called RAPID that  </abstract>::line_number::14
<abstract> provides a set of library functions for specifying irregular  </abstract>::line_number::15
<abstract> data objects and tasks that access these objects. The system  </abstract>::line_number::16
<abstract> extracts a task dependence graph from data access patterns,  </abstract>::line_number::17
<abstract> and executes tasks efficiently on a distributed memory machine. We discuss a set of optimization strategies used in  </abstract>::line_number::18
<abstract> this system and demonstrate the application of this system  </abstract>::line_number::19
<abstract> in parallelizing sparse Cholesky and LU factorizations.   </abstract>::line_number::20
<intro>  1 Introduction  </intro>::line_number::21

<pubnum>  TRCS 97-02   </pubnum>::line_number::0
<title>  A New Framework for Image Invariants using Basis Expansion    </title>::line_number::1
<author>  Yuan-Fang Wang   </author>::line_number::2
<affiliation>  Department of Computer Science  </affiliation>::line_number::3
<affiliation> University of California   </affiliation>::line_number::4
<address>  Santa Barbara, CA 93106   </address>::line_number::5
<email>  E-mail: yfwang@cs.ucsb.edu   </email>::line_number::6
<web>  Web: http://www.cs.ucsb.edu/ yfwang   </web>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> We propose a general framework for computing invariant features from images. The proposed  </abstract>::line_number::9
<abstract> approach is based on a simple concept of basis expansion. It is widely applicable to many popular  </abstract>::line_number::10
<abstract> basis representations, such as wavelets [4, 5, 24, 25], short-time Fourier analysis [15, 30], and  </abstract>::line_number::11
<abstract> splines [2, 6, 33]. Exploiting formulations that use both global and local information about  </abstract>::line_number::12
<abstract> shape and color, the new approach is neither strictly global nor local. It has the advantage of  </abstract>::line_number::13
<abstract> tolerating a certain degree of occlusion (unlike global analysis) and does not require estimating  </abstract>::line_number::14
<abstract> high-order derivatives in computing invariants (unlike local analysis), whence is more robust.  </abstract>::line_number::15
<abstract> Furthermore, it enables a quasi-localized, hierarchical shape analysis which is not possible with  </abstract>::line_number::16
<abstract> other known invariant techniques. Unlike most current research on image invariants which  </abstract>::line_number::17
<abstract> concentrates on either geometry or illumination invariants, the proposed framework is very  </abstract>::line_number::18
<abstract> general and produces invariants which are insensitive to rigid motion, general affine transform,  </abstract>::line_number::19
<abstract> changes of parameterization and scene illumination, and perspective transform.   </abstract>::line_number::20
<intro>  1 Introduction  </intro>::line_number::21

<title>  A SUIF Java Compiler   </title>::line_number::0
<author>  Holger M. Kienle   </author>::line_number::1
<email>  kienle@cs.uscb.edu   </email>::line_number::2
<pubnum>  Technical Report TRCS98-18   </pubnum>::line_number::3
<date>  August, 1998   </date>::line_number::4
<page>  +PAGE+  </page>::line_number::5

<title>  Jade: A High-Level, Machine-Independent Language for Parallel  </title>::line_number::0
<title> Programming   </title>::line_number::1
<author>  Martin C. Rinard, Daniel J. Scales and Monica S. Lam   </author>::line_number::2
<affiliation>  Computer Systems Laboratory  </affiliation>::line_number::3
<address> Stanford University,   CA 94305   </address>::line_number::4
<intro>  1 Introduction  </intro>::line_number::5

<title>  EXPLOITING COMMUTING OPERATIONS IN PARALLELIZING  </title>::line_number::0
<title> SERIAL PROGRAMS   </title>::line_number::1
<author>  PEDRO DINIZ AND MARTIN RINARD   </author>::line_number::2
<affiliation>  DEPARTMENT OF COMPUTER SCIENCE  </affiliation>::line_number::3
<affiliation> UNIVERSITY OF CALIFORNIA, SANTA BARBARA   </affiliation>::line_number::4
<address>  SANTA BARBARA, CA 93106   </address>::line_number::5
<abstract>  Abstract. Two operations commute if the result of their execution is independent of the order in which they execute. Commuting operations can be executed  </abstract>::line_number::6
<abstract> concurrently provided they execute atomically on the objects they access. Statically  </abstract>::line_number::7
<abstract> recognizing commuting operations is of great interest because they increase the amount  </abstract>::line_number::8
<abstract> of concurrency a compiler can exploit. In this document we introduce commutativity  </abstract>::line_number::9
<abstract> analysis anew technique for automatically parallelizing serial programs. We then  </abstract>::line_number::10
<abstract> conduct a feasibility study of existing scientific applications as to the existence and  </abstract>::line_number::11
<abstract> exploitability of commuting operations. We study the commuting operations present  </abstract>::line_number::12
<abstract> in one such application the Barnes-Hut hierarchical N-body algorithm. We then  </abstract>::line_number::13
<abstract> parallelize this application using knowledge of commuting operations and present performance results of the parallel code for a shared-memory multiprocessor.   </abstract>::line_number::14
<intro>  1. Introduction.  </intro>::line_number::15

<title>  A Concurrency Mechanism For Sequential Eiffel   </title>::line_number::0
<author>  Murat Karaorman John Bruno   </author>::line_number::1
<affiliation>  Department of Computer Science  </affiliation>::line_number::2
<affiliation> University of California   </affiliation>::line_number::3
<address>  Santa Barbara, CA 93106   </address>::line_number::4
<email>  Email: murat@cs.ucsb.edu, bruno@cs.ucsb.edu   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> This paper describes a set of classes designed to  </abstract>::line_number::7
<abstract> facilitate concurrent programming using the sequential object-oriented language EIFFEL. The design and  </abstract>::line_number::8
<abstract> implementation presented here is the application of a  </abstract>::line_number::9
<abstract> more general Concurrency Model we have built to introduce concurrency to sequential OOPLs. The model  </abstract>::line_number::10
<abstract> views concurrency as a well-defined, inheritable property of objects specified in the class CONCURRENCY,  </abstract>::line_number::11
<abstract> and provides a methodology using inheritance to write  </abstract>::line_number::12
<abstract> concurrent object-orient applications. Key ideas involved in the methodology are: active objects, extensibility of protocols, synchronization programming,  </abstract>::line_number::13
<abstract> data-driven synchronization with asynchronous message passing.  </abstract>::line_number::14
<abstract> The novel feature of our work is in its describing  </abstract>::line_number::15
<abstract> concurrency in the context of sequential programming  </abstract>::line_number::16
<abstract> and using a object-oriented design methodology to describe and implement it.  </abstract>::line_number::17
<abstract> We illustrate the usefulness and expressiveness of  </abstract>::line_number::18
<abstract> the concurrency mechanism by presenting examples  </abstract>::line_number::19
<abstract> and analyzing them. The ability to express powerful  </abstract>::line_number::20
<abstract> synchronization constraints as reusable software components emerges as a strong point of our implementation.   </abstract>::line_number::21
<note>  This research has been supported by the Lawrence Liver-more National Labs; grant no: ISCR/LLNL 89-22,90-22   </note>::line_number::22
<intro>  1 INTRODUCTION  </intro>::line_number::23

<title>  Scintilla: Cluster Computing with SCI   </title>::line_number::0
<author>  Max Ibel, Klaus E. Schauser, Chris J. Scheiman, and Michael Schmitt   </author>::line_number::1
<affiliation>  Department of Computer Science  </affiliation>::line_number::2
<affiliation> University of California, Santa Barbara   </affiliation>::line_number::3
<address>  Santa Barbara, CA 93106   </address>::line_number::4
<email>  fibel,schauser,chriss,schmittmg@cs.ucsb.edu   </email>::line_number::5
<web>  http://www.cs.ucsb.edu/research/scintilla   </web>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> The Scintilla project at UCSB studies SCI-based cluster  </abstract>::line_number::8
<abstract> computing. The Scalable Coherent Interface (SCI) is a  </abstract>::line_number::9
<abstract> recent communication standard for cluster interconnects.  </abstract>::line_number::10
<abstract> We focus on non-coherent SCI, using our cluster setup  </abstract>::line_number::11
<abstract> of SBus-based and PCI-based workstations connected via  </abstract>::line_number::12
<abstract> Dolphin SCI adapters. Our motivation for choosing SCI as  </abstract>::line_number::13
<abstract> network fabric is the very low latency and high bandwidth.  </abstract>::line_number::14
<abstract> We study how to map a variety of programming models efficiently onto the SCI hardware, focusing on message  </abstract>::line_number::15
<abstract> passing and global address space support, implementing  </abstract>::line_number::16
<abstract> Active Messages and Split-C. We present implementation  </abstract>::line_number::17
<abstract> trade-offs, present performance measurements and compare the PCI and SBus adapters.  </abstract>::line_number::18
<abstract> We found that the user-level load/store programming interface of SCI is very convenient to use, achieves low latencies, and is fully virtualized, simultaneously supporting  </abstract>::line_number::19
<abstract> multiple parallel programs and communication channels.  </abstract>::line_number::20
<abstract> On the other hand, neither of the programming models  </abstract>::line_number::21
<abstract> studied maps directly to SCI. Issues such as notification,  </abstract>::line_number::22
<abstract> atomic operations, and virtual address space limitations  </abstract>::line_number::23
<abstract> represent major implementation challenges, which we address with a combination of compiler and run-time support. Overall, we found the SCI network a good substrate  </abstract>::line_number::24
<abstract> for high-performance cluster computing.   </abstract>::line_number::25
<intro>  1 Introduction  </intro>::line_number::26

<title>  Run-time Techniques for Exploiting Irregular Task  </title>::line_number::0
<title> Parallelism on Distributed Memory Architectures    </title>::line_number::1
<author>  Cong Fu and Tao Yang   </author>::line_number::2
<affiliation>  Department of Computer Science  </affiliation>::line_number::3
<affiliation> University of California   </affiliation>::line_number::4
<address>  Santa Barbara, CA 93106   </address>::line_number::5
<email>  fcfu,tyangg@cs.ucsb.edu   </email>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> Automatic scheduling for directed acyclic graphs (DAG) and its applications for coarse-grained irregular problems such as large n-body simulation have been studied in the literature.  </abstract>::line_number::8
<abstract> However solving irregular problems with mixed granularities such as sparse matrix factorization  </abstract>::line_number::9
<abstract> is challenging since it requires efficient run-time support to execute a DAG schedule. In this  </abstract>::line_number::10
<abstract> paper, we investigate run-time optimization techniques for executing general asynchronous  </abstract>::line_number::11
<abstract> DAG schedules on distributed memory machines. Our solution tightly integrates the run-time  </abstract>::line_number::12
<abstract> scheme with a fast communication mechanism to eliminate unnecessary overhead in message  </abstract>::line_number::13
<abstract> buffering and copying. We discuss a consistency model incorporating the above optimizations,  </abstract>::line_number::14
<abstract> and taking advantage of task dependence properties to ensure the correctness of execution.  </abstract>::line_number::15
<abstract> We demonstrate the applications of this scheme in sparse factorizations and triangular solver  </abstract>::line_number::16
<abstract> for which actual speedups are hard to obtain. Our experiments on Meiko CS-2 show that the  </abstract>::line_number::17
<abstract> automatically scheduled code has achieved scalable performance for these problems and the  </abstract>::line_number::18
<abstract> run-time overhead is small compared to the total execution time.   </abstract>::line_number::19
<intro>  1 Introduction  </intro>::line_number::20

<affiliation>  UNIVERSITY of CALIFORNIA  </affiliation>::line_number::0
<affiliation> Santa Barbara   </affiliation>::line_number::1
<title>  Design and Implementation of a System to Support Integration of  </title>::line_number::2
<title> Autonomous Database Systems   </title>::line_number::3
<degree>  A thesis submitted in partial satisfaction of the  </degree>::line_number::4
<degree> requirements for the degree of  </degree>::line_number::5
<degree> Master of Science  </degree>::line_number::6
<degree> in  </degree>::line_number::7
<degree> Computer Science   </degree>::line_number::8
<author>  by  </author>::line_number::9
<author> Tze Kwan Lau   </author>::line_number::10
<degree>  Committee in charge:  </degree>::line_number::11
<degree> Professor Jianwen Su, Chair  </degree>::line_number::12
<degree> Professor Oscar Ibarra  </degree>::line_number::13
<degree> Professor Amr El Abbadi   </degree>::line_number::14
<date>  December 1998   </date>::line_number::15
<page>  +PAGE+  </page>::line_number::16

<title>  The Institution of order-sorted equational logic   </title>::line_number::0
<author>  Grigore Ro~su   </author>::line_number::1
<affiliation>  University of Bucharest, Faculty of Mathematics,  </affiliation>::line_number::2
<affiliation> Department of Computer Science   </affiliation>::line_number::3
<address>  Str. Academiei 14, R70109, ROMANIA   </address>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> The paper provides an organisation of order-sorted equational logic as  </abstract>::line_number::6
<abstract> an Institution.   </abstract>::line_number::7
<intro>  1 Introduction  </intro>::line_number::8

<note>  Appears in Journal of the ACM, Vol. 39, No. 1, January 1992, pp. 214-233. Prelimanary version  </note>::line_number::0
<note> in Proceedings of the 20th Annual Symposium on Theory of Computing, ACM, 1988.   </note>::line_number::1
<title>  How to Sign Given Any Trapdoor Permutation   </title>::line_number::2
<author>  Mihir Bellare Silvio Micali    </author>::line_number::3
<date>  January 1992   </date>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> We present a digital signature scheme which is based on the existence of any trapdoor  </abstract>::line_number::6
<abstract> permutation. Our scheme is secure in the strongest possible natural sense: namely, it is secure  </abstract>::line_number::7
<abstract> against existential forgery under adaptive chosen message attack.   </abstract>::line_number::8
<affiliation>  Department of Computer Science & Engineering,   Mail Code 0114,   University of California at San Diego,   9500  </affiliation>::line_number::9
<email> Gilman Drive, La Jolla, CA 92093.   E-mail: mihir@cs.ucsd.edu.   Work done while author was at MIT, supported in  </email>::line_number::10
<email> part by NSF grant CCR-87-19689.   </email>::line_number::11
<affiliation>  MIT Laboratory for Computer Science,   545 Technology Square, Cambridge, MA 02139.   Supported in part by  </affiliation>::line_number::12
<affiliation> NSF grant DCR-84-13577 and ARO grant DAALO3-86-K-0171.   </affiliation>::line_number::13
<page>  +PAGE+  </page>::line_number::14

<title>  The Relative Complexity of NP Search Problems   </title>::line_number::0
<author>  Paul Beame    </author>::line_number::1
<affiliation>  Computer Science and Engineering  </affiliation>::line_number::2
<affiliation> University of Washington   </affiliation>::line_number::3
<email>  beame@cs.washington.edu   </email>::line_number::4
<author>  Stephen Cook    </author>::line_number::5
<affiliation>  Computer Science Dept.  </affiliation>::line_number::6
<affiliation> University of Toronto   </affiliation>::line_number::7
<email>  sacook@cs.toronto.edu   </email>::line_number::8
<author>  Jeff Edmonds    </author>::line_number::9
<affiliation>  I.C.S.I.   </affiliation>::line_number::10
<address>  Berkeley, CA 94704-1198   </address>::line_number::11
<email>  edmonds@icsi.berkeley.edu   </email>::line_number::12
<author>  Russell Impagliazzo x   </author>::line_number::13
<affiliation>  Computer Science and Engineering  </affiliation>::line_number::14
<affiliation> UC, San Diego   </affiliation>::line_number::15
<address>  9500 Gilman Drive  </address>::line_number::16
<address> La Jolla, CA 92093-0114   </address>::line_number::17
<email>  russell@cs.ucsd.edu   </email>::line_number::18
<author>  Toniann Pitassi -   </author>::line_number::19
<affiliation>  Mathematics and Computer Science  </affiliation>::line_number::20
<affiliation> University of Pittsburgh   </affiliation>::line_number::21
<email>  toni@cs.pitt.edu   </email>::line_number::22
<abstract>  Abstract  </abstract>::line_number::23
<abstract> Papadimitriou introduced several classes of NP search problems based on combinatorial principles which guarantee the  </abstract>::line_number::24
<abstract> existence of solutions to the problems. Many interesting  </abstract>::line_number::25
<abstract> search problems not known to be solvable in polynomial  </abstract>::line_number::26
<abstract> time are contained in these classes, and a number of them  </abstract>::line_number::27
<abstract> are complete problems. We consider the question of the relative complexity of these search problem classes. We prove  </abstract>::line_number::28
<abstract> several separations which show that in a generic relativized  </abstract>::line_number::29
<abstract> world, the search classes are distinct and there is a standard  </abstract>::line_number::30
<abstract> search problem in each of them that is not computation-ally equivalent to any decision problem. (Naturally, absolute separations would imply that P 6= NP.) Our separation  </abstract>::line_number::31
<abstract> proofs have interesting combinatorial content and go to the  </abstract>::line_number::32
<abstract> heart of the combinatorial principles on which the classes are  </abstract>::line_number::33
<abstract> based. We derive one result via new lower bounds on the  </abstract>::line_number::34
<abstract> degrees of polynomials asserted to exist by Hilbert's Null-stellensatz over finite fields.   </abstract>::line_number::35
<note>  Research supported by NSF grants CCR-8858799 and CCR-9303017  </note>::line_number::36
<note> Research supported by an NSERC operating grant and the Information Technology Research Centre  </note>::line_number::37
<note> Supported by an NSF postdoctoral fellowship and by a Canadian  </note>::line_number::38
<note> NSERC postdoctoral fellowship  </note>::line_number::39
<note> x Research Supported by NSF YI Award CCR-92-570979, Sloan  </note>::line_number::40
<note> Research Fellowship BR-3311, grant #93025 of the joint US-Czechoslovak Science and Technology Program, and USA-Israel BSF  </note>::line_number::41
<note> Grant 92-00043  </note>::line_number::42
<note> Research supported by an NSF postdoctoral fellowship and by  </note>::line_number::43
<note> NSF Grant CCR-9457782   </note>::line_number::44
<intro>  1 Introduction  </intro>::line_number::45

<pubnum>  TR - UCSD - CS96-484   </pubnum>::line_number::0
<title>  Mapping Parallel Applications to  </title>::line_number::1
<title> Distributed Heterogeneous Systems   </title>::line_number::2
<author>  Silvia M. Figueira 1 and Francine Berman 2   </author>::line_number::3
<affiliation>  Department of Computer Science and Engineering  </affiliation>::line_number::4
<affiliation> University of California, San Diego   </affiliation>::line_number::5
<email>  -silvia,berman-@cs.ucsd.edu   </email>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> Fast networks have made it possible to coordinate distributed heterogeneous CPU,  </abstract>::line_number::8
<abstract> memory and storage resources to provide a powerful platform for executing high-performance applications. However, the performance of parallel applications on such  </abstract>::line_number::9
<abstract> systems is highly dependent on the mapping of application tasks to machines. In this  </abstract>::line_number::10
<abstract> paper, we propose a mapping strategy for applications formed by multiple tasks targeted  </abstract>::line_number::11
<abstract> to heterogeneous platforms. We first define a mapping model, the match-tree, which  </abstract>::line_number::12
<abstract> reects the data movement and conversion costs of distributed algorithms and allows for  </abstract>::line_number::13
<abstract> alternative implementations of individual tasks on different machines. We then define the  </abstract>::line_number::14
<abstract> find-mapping and split-partition algorithms, based on the match-tree model, to  </abstract>::line_number::15
<abstract> determine the best allocation of tasks to resources in heterogeneous systems. We  </abstract>::line_number::16
<abstract> illustrate the use of these algorithms with a sample distributed application.   </abstract>::line_number::17
<intro>  1 Introduction  </intro>::line_number::18

<title>  Almost All Regular Graphs are  </title>::line_number::0
<title> Hamiltonian   </title>::line_number::1
<author>  R. W. Robinson   </author>::line_number::2
<affiliation>  Computer Science Department  </affiliation>::line_number::3
<affiliation> University of Georgia   </affiliation>::line_number::4
<address>  Athens, GA 30602, U.S.A.   </address>::line_number::5
<author>  N. C. Wormald    </author>::line_number::6
<affiliation>  Department of Mathematics  </affiliation>::line_number::7
<affiliation> University of Melbourne   </affiliation>::line_number::8
<address>  Parkville, VIC 3052, Australia   </address>::line_number::9
<abstract>  Abstract  </abstract>::line_number::10
<abstract> In a previous paper the authors showed that almost all labelled  </abstract>::line_number::11
<abstract> cubic graphs are hamiltonian. In the present paper, this result is  </abstract>::line_number::12
<abstract> used to show that almost all r-regular graphs are hamiltonian for any  </abstract>::line_number::13
<abstract> fixed r 3, by an analysis of the distribution of 1-factors in random  </abstract>::line_number::14
<abstract> regular graphs. Moreover, almost all such graphs are r-edge-colourable  </abstract>::line_number::15
<abstract> if they have an even number of vertices. Similarly, almost all r-regular  </abstract>::line_number::16
<abstract> bipartite graphs are hamiltonian and r-edge-colourable for fixed r 3.   </abstract>::line_number::17
<note>  Research supported by the Australian Research Council   </note>::line_number::18
<page>  +PAGE+  </page>::line_number::19

<title>  Learning to Schedule Straight-Line Code   </title>::line_number::0
<author>  J. Eliot B. Moss   </author>::line_number::1
<affiliation>  Dept. of Comp. Sci.  </affiliation>::line_number::2
<affiliation> Univ. of Mass.   </affiliation>::line_number::3
<address>  Amherst, MA 01003   </address>::line_number::4
<author>  Paul E. Utgoff   </author>::line_number::5
<affiliation>  Dept. of Comp. Sci.  </affiliation>::line_number::6
<affiliation> Univ. of Mass.   </affiliation>::line_number::7
<address>  Amherst, MA 01003   </address>::line_number::8
<author>  John Cavazos   </author>::line_number::9
<affiliation>  Dept. of Comp. Sci.  </affiliation>::line_number::10
<affiliation> Univ. of Mass.   </affiliation>::line_number::11
<address>  Amherst, MA 01003   </address>::line_number::12
<author>  Doina Precup   </author>::line_number::13
<affiliation>  Dept. of Comp. Sci.  </affiliation>::line_number::14
<affiliation> Univ. of Mass.   </affiliation>::line_number::15
<address>  Amherst, MA 01003   </address>::line_number::16
<author>  Darko Stefanovi c   </author>::line_number::17
<affiliation>  Dept. of Comp. Sci.  </affiliation>::line_number::18
<affiliation> Univ. of Mass.   </affiliation>::line_number::19
<address>  Amherst, MA 01003   </address>::line_number::20
<author>  Carla Brodley   </author>::line_number::21
<affiliation>  Sch. of Elec. and Comp. Eng.  </affiliation>::line_number::22
<affiliation> Purdue University   </affiliation>::line_number::23
<address>  W. Lafayette, IN 47907   </address>::line_number::24
<author>  David Scheeff   </author>::line_number::25
<affiliation>  Sch. of Elec. and Comp. Eng.  </affiliation>::line_number::26
<affiliation> Purdue University   </affiliation>::line_number::27
<address>  W. Lafayette, IN 47907   </address>::line_number::28
<abstract>  Abstract  </abstract>::line_number::29
<abstract> Execution speed of programs on modern computer architectures is sensitive, by a factor of two or more, to the order in which instructions  </abstract>::line_number::30
<abstract> are presented to the processor. To realize potential execution efficiency,  </abstract>::line_number::31
<abstract> it is now customary for an optimizing compiler to employ a heuristic  </abstract>::line_number::32
<abstract> algorithm for instruction scheduling. These algorithms are painstakingly  </abstract>::line_number::33
<abstract> hand-crafted, which is expenseive and time-consuming. We show how  </abstract>::line_number::34
<abstract> to cast the instruction scheduling problem as a learning task, so that one  </abstract>::line_number::35
<abstract> obtains the heuristic scheduling algorithm automatically. Our focus is the  </abstract>::line_number::36
<abstract> narrower problem of scheduling straight-line code, also known as a basic  </abstract>::line_number::37
<abstract> block of instructions. Our empirical results show that just a few features  </abstract>::line_number::38
<abstract> are adequate for quite good performance at this task for a real modern  </abstract>::line_number::39
<abstract> processor, and that any of several supervised learning methods perform  </abstract>::line_number::40
<abstract> nearly optimally with respect to the features used.   </abstract>::line_number::41
<keyword>  Category: Applications (compiler optimization)   </keyword>::line_number::42
<note>  Original: This work has not been submitted elsewhere.  </note>::line_number::43
<note> Presentation: We prefer oral presentation.  </note>::line_number::44
<note> Contact author: Eliot Moss   </note>::line_number::45
<page>  +PAGE+  </page>::line_number::46

<title>  Multi-time Models for Temporally Abstract  </title>::line_number::0
<title> Planning   </title>::line_number::1
<author>  Doina Precup, Richard S. Sutton   </author>::line_number::2
<affiliation>  University of Massachusetts   </affiliation>::line_number::3
<address>  Amherst, MA 01003   </address>::line_number::4
<email>  fdprecupjrichg@cs.umass.edu   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Planning and learning at multiple levels of temporal abstraction is a key  </abstract>::line_number::7
<abstract> problem for artificial intelligence. In this paper we summarize an approach to this problem based on the mathematical framework of Markov  </abstract>::line_number::8
<abstract> decision processes and reinforcement learning. Current model-based reinforcement learning is based on one-step models that cannot represent  </abstract>::line_number::9
<abstract> common-sense higher-level actions, such as going to lunch, grasping an  </abstract>::line_number::10
<abstract> object, or flying to Denver. This paper generalizes prior work on temporally abstract models [Sutton, 1995] and extends it from the prediction  </abstract>::line_number::11
<abstract> setting to include actions, control, and planning. We introduce a more  </abstract>::line_number::12
<abstract> general form of temporally abstract model, the multi-time model, and establish its suitability for planning and learning by virtue of its relationship  </abstract>::line_number::13
<abstract> to the Bellman equations. This paper summarizes the theoretical framework of multi-time models and illustrates their potential advantages in a  </abstract>::line_number::14
<abstract> gridworld planning task.   </abstract>::line_number::15
<intro>  The need for hierarchical  </intro>::line_number::16

<title>  Intra-Option Learning about Temporally Abstract Actions   </title>::line_number::0
<author>  Richard S. Sutton   </author>::line_number::1
<affiliation>  Department of Computer Science  </affiliation>::line_number::2
<affiliation> University of Massachusetts   </affiliation>::line_number::3
<address>  Amherst, MA 01003-4610   </address>::line_number::4
<email>  rich@cs.umass.edu   </email>::line_number::5
<author>  Doina Precup   </author>::line_number::6
<affiliation>  Department of Computer Science  </affiliation>::line_number::7
<affiliation> University of Massachusetts   </affiliation>::line_number::8
<address>  Amherst, MA 01003-4610   </address>::line_number::9
<email>  dprecup@cs.umass.edu   </email>::line_number::10
<author>  Satinder Singh   </author>::line_number::11
<affiliation>  Department of Computer Science  </affiliation>::line_number::12
<affiliation> University of Colorado   </affiliation>::line_number::13
<address>  Boulder, CO 80309-0430   </address>::line_number::14
<email>  baveja@cs.colorado.edu   </email>::line_number::15
<abstract>  Abstract  </abstract>::line_number::16
<abstract> Several researchers have proposed modeling  </abstract>::line_number::17
<abstract> temporally abstract actions in reinforcement  </abstract>::line_number::18
<abstract> learning by the combination of a policy and a termination condition, which we refer to as an option. Value functions over options and models of  </abstract>::line_number::19
<abstract> options can be learned using methods designed  </abstract>::line_number::20
<abstract> for semi-Markov decision processes (SMDPs).  </abstract>::line_number::21
<abstract> However, all these methods require an option to  </abstract>::line_number::22
<abstract> be executed to termination. In this paper we explore methods that learn about an option from  </abstract>::line_number::23
<abstract> small fragments of experience consistent with  </abstract>::line_number::24
<abstract> that option, even if the option itself is not executed. We call these methods intra-option learning methods because they learn from experience  </abstract>::line_number::25
<abstract> within an option. Intra-option methods are sometimes much more efficient than SMDP methods because they can use off-policy temporal-difference mechanisms to learn simultaneously  </abstract>::line_number::26
<abstract> about all the options consistent with an experience, not just the few that were actually executed. In this paper we present intra-option learning methods for learning value functions over options and for learning multi-time models of the  </abstract>::line_number::27
<abstract> consequences of options. We present computational examples in which these new methods  </abstract>::line_number::28
<abstract> learn much faster than SMDP methods and learn  </abstract>::line_number::29
<abstract> effectively when SMDP methods cannot learn at  </abstract>::line_number::30
<abstract> all. We also sketch a convergence proof for intra  </abstract>::line_number::31
<abstract> option value learning.   </abstract>::line_number::32
<intro>  1 Introduction  </intro>::line_number::33

<title>  A Method Providing Identity Privacy to Mobile Users during  </title>::line_number::0
<title> Authentication   </title>::line_number::1
<author>  Didier Samfat, Refik Molva   </author>::line_number::2
<affiliation>  Institut Eurecom   </affiliation>::line_number::3
<address>  2229 Route des Cr^etes  </address>::line_number::4
<address> BP 193 - Sophia Antipolis FRANCE   </address>::line_number::5
<email>  fsamfat, molvag@eurecom.fr   </email>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> The increasing development of mobile networks  </abstract>::line_number::8
<abstract> raises new security requirements and concerns. In addition to the basic need of authentication, confidentiality and key distribution services, a new problem involving privacy is the unauthorized tracking of users'  </abstract>::line_number::9
<abstract> migration. In other words, accessing any information  </abstract>::line_number::10
<abstract> related to the mobile user's location data without his  </abstract>::line_number::11
<abstract> consent, is a serious violation of his privacy. Moreover, if no care is taken, the disclosure of the mobile  </abstract>::line_number::12
<abstract> user real identity may appear during the authentication process. The basic solution to this problem is the  </abstract>::line_number::13
<abstract> use of aliases which insure non-traceability by hiding  </abstract>::line_number::14
<abstract> the user's real identity and also his relationship with  </abstract>::line_number::15
<abstract> domain authorities. In this paper we provide a classification of the different degrees of non-traceability and  </abstract>::line_number::16
<abstract> present a new efficient method for the computation of  </abstract>::line_number::17
<abstract> aliases. This technique can be used during authentication of mobile users and thus avoids the drawbacks of  </abstract>::line_number::18
<abstract> existing solutions such as GSM and CDPD.   </abstract>::line_number::19
<intro>  1 Introduction  </intro>::line_number::20

<title>  Composite Model Checking with Type Specific  </title>::line_number::0
<title> Symbolic Encodings    </title>::line_number::1
<author>  Tevfik Bultan Richard Gerber   </author>::line_number::2
<affiliation>  Department of Computer Science  </affiliation>::line_number::3
<address> University of Maryland,   College Park, MD 20742, USA   </address>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> We present a new symbolic model checking technique, which analyzes temporal properties in multi-typed transition systems. Specifically, the method uses multiple type-specific data encodings to represent  </abstract>::line_number::6
<abstract> system states, and it carries out fixpoint computations via the corresponding type-specific symbolic  </abstract>::line_number::7
<abstract> operations. In essence, different symbolic encodings are unified into one composite model checker. Any  </abstract>::line_number::8
<abstract> type-specific language can be included in this framework provided that the language is closed under  </abstract>::line_number::9
<abstract> Boolean connectives, propositions can be checked for satisfiability, and relational images can be computed.  </abstract>::line_number::10
<abstract> Our technique relies on conjunctive partitioning of transition relations of atomic events based on variable  </abstract>::line_number::11
<abstract> types involved, which allows independent computation of one-step pre- and post-conditions for each  </abstract>::line_number::12
<abstract> variable type.  </abstract>::line_number::13
<abstract> In this paper we demonstrate the effectiveness of our method on a nontrivial data-transfer protocol,  </abstract>::line_number::14
<abstract> which contains a mixture of integer and Boolean-valued variables. The protocol operates over an unreliable channel that can lose, duplicate or reorder messages. Moreover, the protocol's send and receive  </abstract>::line_number::15
<abstract> window sizes are not specified in advance; rather, they are represented as symbolic constants. The resulting system was automatically verified using our composite model checking approach, in concert with  </abstract>::line_number::16
<abstract> a conservative approximation technique.   </abstract>::line_number::17
<note>  This research is supported in part by ONR grant N00014-94-10228 and NSF CCR-9619808.   </note>::line_number::18
<page>  +PAGE+  </page>::line_number::19

<title>  Mobile-End Transport Protocol:  </title>::line_number::0
<title> An Alternative to TCP/IP Over Wireless Links    </title>::line_number::1
<author>  Kuang-Yeh Wang   </author>::line_number::2
<affiliation>  Department of Computer Science  </affiliation>::line_number::3
<affiliation> University of Maryland   </affiliation>::line_number::4
<address>  College Park, MD 20742   </address>::line_number::5
<email>  kwang@cs.umd.edu   </email>::line_number::6
<author>  Satish K. Tripathi   </author>::line_number::7
<affiliation>  Bourns College of Engineering  </affiliation>::line_number::8
<affiliation> University of California   </affiliation>::line_number::9
<address>  Riverside, CA 92521-0425   </address>::line_number::10
<email>  tripathi@engr.ucr.edu   </email>::line_number::11
<abstract>  Abstract  </abstract>::line_number::12
<abstract> Unlike wired links, wireless network bandwidth is highly limited  </abstract>::line_number::13
<abstract> and the channel usually suffers from frequent and bursty loss due  </abstract>::line_number::14
<abstract> to its vulnerability to various kinds of interference. At the same  </abstract>::line_number::15
<abstract> time, the traditional TCP with its congestion control is well known  </abstract>::line_number::16
<abstract> for its poor performance over wireless links. This paper proposes  </abstract>::line_number::17
<abstract> a new protocol that (1) replaces TCP/IP over the wireless link by  </abstract>::line_number::18
<abstract> a simpler protocol with smaller headers, if the link is the last hop  </abstract>::line_number::19
<abstract> along a data path, (2) shifts functions needed to communicate with  </abstract>::line_number::20
<abstract> an Internet host using TCP/IP from the mobile host to the base  </abstract>::line_number::21
<abstract> station, so that the distinct wireless link is hidden from the outside Internet, and (3) exploits link-layer acknowledgments and re-transmissions to quickly recover losses over the wireless link. Our  </abstract>::line_number::22
<abstract> simulation results show a substantial performance improvement  </abstract>::line_number::23
<abstract> achieved by the new protocol.   </abstract>::line_number::24
<intro>  1 Introduction  </intro>::line_number::25

<title>  Ratio Rules:  </title>::line_number::0
<title> A New Paradigm for Fast, Quantifiable Data Mining   </title>::line_number::1
<author>  Flip Korn, Alexandros Labrinidis, Yannis Kotidis   </author>::line_number::2
<affiliation>  Department of Computer Science  </affiliation>::line_number::3
<affiliation> University of Maryland   </affiliation>::line_number::4
<address>  College Park, MD 20742   </address>::line_number::5
<email>  fflip,labrinid,kotidisg@cs.umd.edu   </email>::line_number::6
<author>  Christos Faloutsos    </author>::line_number::7
<affiliation>  Computer Science Department  </affiliation>::line_number::8
<affiliation> Carnegie Mellon University   </affiliation>::line_number::9
<address>  Pittsburgh, PA 15213   </address>::line_number::10
<email>  christos@cs.cmu.edu   </email>::line_number::11
<abstract>  Abstract  </abstract>::line_number::12
<abstract> Association Rule Mining algorithms operate  </abstract>::line_number::13
<abstract> on a data matrix (e.g., customers fi products)  </abstract>::line_number::14
<abstract> to derive association rules [2, 23]. We propose a new paradigm, namely, Ratio Rules,  </abstract>::line_number::15
<abstract> which are quantifiable in that we can measure  </abstract>::line_number::16
<abstract> the "goodness" of a set of discovered rules.  </abstract>::line_number::17
<abstract> We propose to use the "guessing error" as a  </abstract>::line_number::18
<abstract> measure of the "goodness", that is, the root-mean-square error of the reconstructed values  </abstract>::line_number::19
<abstract> of the cells of the given matrix, when we pretend that they are unknown. Another contribution is a novel method to guess missing/hidden values from the Ratio Rules that  </abstract>::line_number::20
<abstract> our method derives. For example, if somebody bought $10 of milk and $3 of bread, our  </abstract>::line_number::21
<abstract> rules can "guess" the amount spent on, say,  </abstract>::line_number::22
<abstract> butter. Thus, we can perform a variety of important tasks such as forecasting, answering  </abstract>::line_number::23
<abstract> "what-if" scenarios, detecting outliers, and visualizing the data. Moreover, we show how to  </abstract>::line_number::24
<abstract> compute Ratio Rules in a single pass over the  </abstract>::line_number::25
<abstract> dataset with small memory requirements (a  </abstract>::line_number::26
<abstract> few small matrices), in contrast to traditional  </abstract>::line_number::27
<abstract> association rule mining methods that require  </abstract>::line_number::28
<abstract> multiple passes and/or large memory. Experiments   </abstract>::line_number::29
<note>  Work performed while at the University of Maryland. This  </note>::line_number::30
<note> research was partially funded by the Institute for Systems Research (ISR), and by the National Science Foundation under  </note>::line_number::31
<note> Grants No. EEC-94-02384, IRI-9205273 and IRI-9625428.  </note>::line_number::32
<note> Permission to copy without fee all or part of this material is  </note>::line_number::33
<note> granted provided that the copies are not made or distributed for  </note>::line_number::34
<note> direct commercial advantage, the VLDB copyright notice and  </note>::line_number::35
<note> the title of the publication and its date appear, and notice is  </note>::line_number::36
<note> given that copying is by permission of the Very Large Data Base  </note>::line_number::37
<note> Endowment. To copy otherwise, or to republish, requires a fee  </note>::line_number::38
<note> and/or special permission from the Endowment.  </note>::line_number::39
<note> Proceedings of the 24th VLDB Conference  </note>::line_number::40
<note> New York, USA, 1998   </note>::line_number::41
<abstract>  on several real datasets (e.g., basketball and baseball statistics, biological data)  </abstract>::line_number::42
<abstract> demonstrate that the proposed method consistently achieves a "guessing error" of up to  </abstract>::line_number::43
<abstract> 5 times less than the straightforward competi  </abstract>::line_number::44
<abstract> tor.   </abstract>::line_number::45
<intro>  1 Introduction  </intro>::line_number::46

<note>  To appear in Proc. AAAI'97   </note>::line_number::0
<title>  Dynamic Abstraction Planning   </title>::line_number::1
<author>  Robert P. Goldman, David J. Musliner, Kurt D. Krebsbach, Mark S. Boddy   </author>::line_number::2
<affiliation>  Automated Reasoning Group  </affiliation>::line_number::3
<affiliation> Honeywell Technology Center   </affiliation>::line_number::4
<address>  3660 Technology Drive  </address>::line_number::5
<address> Minneapolis, MN 55418   </address>::line_number::6
<email>  fgoldman,musliner,krebsbac,boddyg@htc.honeywell.com   </email>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> This paper describes Dynamic Abstraction Planning  </abstract>::line_number::9
<abstract> (DAP), an abstraction planning technique that improves the efficiency of state-enumeration planners for  </abstract>::line_number::10
<abstract> real-time embedded systems such as CIRCA. Abstraction is used to remove detail from the state representation, reducing both the size of the state space that  </abstract>::line_number::11
<abstract> must be explored to produce a plan and the size of the  </abstract>::line_number::12
<abstract> resulting plan. The intuition behind this approach is  </abstract>::line_number::13
<abstract> simple: in some situations, certain world features are  </abstract>::line_number::14
<abstract> important, while in other situations those same features are not important.  </abstract>::line_number::15
<abstract> By automatically selecting the appropriate level of abstraction at each step during the planning process,  </abstract>::line_number::16
<abstract> DAP can significantly reduce the size of the search  </abstract>::line_number::17
<abstract> space. Furthermore, the planning process can supply  </abstract>::line_number::18
<abstract> initial plans that preserve safety but might, on further  </abstract>::line_number::19
<abstract> refinement, do a better job of goal achievement. DAP  </abstract>::line_number::20
<abstract> can also terminate with an executable abstract plan,  </abstract>::line_number::21
<abstract> which may be much smaller than the corresponding  </abstract>::line_number::22
<abstract> plan expanded to precisely-defined states. Preliminary  </abstract>::line_number::23
<abstract> results show dramatic improvements in planning speed  </abstract>::line_number::24
<abstract> and scalability.   </abstract>::line_number::25
<intro>  Introduction  </intro>::line_number::26

<note>  Appears in Working Notes of the NASA Workshop on Planning and Scheduling for Space  </note>::line_number::0
<note> Oxnard, CA, October 1997   </note>::line_number::1
<title>  CIRCA and the Cassini Saturn Orbit Insertion:  </title>::line_number::2
<title> Solving a Prepositioning Problem   </title>::line_number::3
<author>  David J. Musliner and Robert P. Goldman   </author>::line_number::4
<affiliation>  Automated Reasoning Group  </affiliation>::line_number::5
<affiliation> Honeywell Technology Center   </affiliation>::line_number::6
<address>  3660 Technology Drive  </address>::line_number::7
<address> Minneapolis, MN 55418   </address>::line_number::8
<email>  fmusliner,goldmang@htc.honeywell.com   </email>::line_number::9
<intro>  Introduction  </intro>::line_number::10

<title>  Quantum Computing | A treatise   </title>::line_number::0
<author>  Prabhat Kumar   </author>::line_number::1
<date>  October 24, 1996   </date>::line_number::2
<abstract>  Abstract  </abstract>::line_number::3
<abstract> Quantum computing has witnessed a surge of activity recently owing  </abstract>::line_number::4
<abstract> to some very exciting discoveries on both the theoretical and practical  </abstract>::line_number::5
<abstract> fronts. In this overview, we sketch an account of the developments in  </abstract>::line_number::6
<abstract> this scientifically intriguing field, starting in the early 80's when the first  </abstract>::line_number::7
<abstract> questions about the computability of quantum processes were raised,  </abstract>::line_number::8
<abstract> and which led to the formal definitions of a Quantum Computer and a  </abstract>::line_number::9
<abstract> Quantum Complexity Theory. Peter Shor's recent remarkable discovery of quantum algorithms to solve the problems of integer factoring  </abstract>::line_number::10
<abstract> and discrete log computing, which are believed to be extremely hard to  </abstract>::line_number::11
<abstract> solve efficiently on classical computers, is a compelling demonstration  </abstract>::line_number::12
<abstract> of the suspected superiority of quantum computing over the classical  </abstract>::line_number::13
<abstract> model that is in use today. We discuss one of his algorithms and the  </abstract>::line_number::14
<abstract> implications it has for classical cryptography. We discuss some of the  </abstract>::line_number::15
<abstract> latest work in this field which has brought us yet closer to achieving a  </abstract>::line_number::16
<abstract> physical realization of a quantum computer. Whenever it happens, if it  </abstract>::line_number::17
<abstract> happens, it would be yet another revolution in the field of computing,  </abstract>::line_number::18
<abstract> and maybe the biggest one to date.   </abstract>::line_number::19
<intro>  1 Birth of Quantum Computing  </intro>::line_number::20

<title>  Within the Letter of the Law: open-textured planning   </title>::line_number::0
<author>  Kathryn E. Sanders    </author>::line_number::1
<affiliation>  Department of Computer Science  </affiliation>::line_number::2
<affiliation> University of Maryland   </affiliation>::line_number::3
<address>  College Park, MD 20742   </address>::line_number::4
<email>  sanders@cs.umd.edu   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Most case-based reasoning systems have used a  </abstract>::line_number::7
<abstract> single "best" or "most similar" case as the basis  </abstract>::line_number::8
<abstract> for a solution. For many problems, however,  </abstract>::line_number::9
<abstract> there is no single exact solution. Rather, there  </abstract>::line_number::10
<abstract> is a range of acceptable answers. We use cases  </abstract>::line_number::11
<abstract> not only as a basis for a solution, but also to  </abstract>::line_number::12
<abstract> indicate the boundaries within which a solution  </abstract>::line_number::13
<abstract> can be found. We solve problems by choosing  </abstract>::line_number::14
<abstract> some point within those boundaries.  </abstract>::line_number::15
<abstract> In this paper, I discuss this use of cases with  </abstract>::line_number::16
<abstract> illustrations from chiron, a system I have implemented in the domain of personal income  </abstract>::line_number::17
<abstract> tax planning.   </abstract>::line_number::18
<intro>  1 Introduction  </intro>::line_number::19

<title>  A Comparison of Content-Based Image/Video Retrieval  </title>::line_number::0
<title> Systems   </title>::line_number::1
<author>  Fatma Ozcan   </author>::line_number::2
<date>  December 15, 1997   </date>::line_number::3
<abstract>  Abstract  </abstract>::line_number::4
<abstract> Recently, content-based retrieval of images and video has become a hot research area. The reason for this  </abstract>::line_number::5
<abstract> is the need for effective and efficient techniques, that meet user requirements, to access large volumes of digital  </abstract>::line_number::6
<abstract> images and video data. In [GR 95], previous approaches to content-based retrieval is said to have taken two  </abstract>::line_number::7
<abstract> directions. In the first approach, image contents are modeled as a set of attributes extracted manually and  </abstract>::line_number::8
<abstract> managed within the framework of conventional database-management systems. The second approach depends  </abstract>::line_number::9
<abstract> on an integrated feature-extraction/object-recognition subsystem to overcome the limitations of attribute-based retrieval. However, it has been also stated that [GR 95] recent content-based image retrieval systems  </abstract>::line_number::10
<abstract> recognized the need for synergy between these two approaches.  </abstract>::line_number::11
<abstract> There has been numerous efforts to build content-based image retrieval systems. These include, Chabot  </abstract>::line_number::12
<abstract> [OS 95], SCORE [ATY 95, ATY 96], CONIVAS [AD 96], Photobook [PPS 93], CANDID [KCH 95], JACOB  </abstract>::line_number::13
<abstract> [ALDV 96, LA 96], VisualSEEk [SC 96] and QBIC [FSN+ 95]. In the first place, these systems differ in their  </abstract>::line_number::14
<abstract> querying capabilities. Images could be retrieved through the use of color, texture, sketch, shape, volume,  </abstract>::line_number::15
<abstract> spatial constraints, browsing, motion, text and domain concepts. Current approaches to content-based image  </abstract>::line_number::16
<abstract> retrieval also differ in terms of image features extracted, their level of abstraction and the degree of domain  </abstract>::line_number::17
<abstract> independence. In this paper, a comparative survey on these systems is conducted to figure out design tradeoffs  </abstract>::line_number::18
<abstract> and different approaches to content-based image retrieval. Furthermore, a taxonomy of content-based retrieval  </abstract>::line_number::19
<abstract> systems, as well as a generic architecture, is provided.   </abstract>::line_number::20
<intro>  1 Introduction  </intro>::line_number::21

<title>  Efficiently Supporting Ad Hoc Queries in Large Datasets of Time  </title>::line_number::0
<title> Sequences   </title>::line_number::1
<author>  Flip Korn    </author>::line_number::2
<affiliation>  Dept. of Computer Science  </affiliation>::line_number::3
<affiliation> University of Maryland   </affiliation>::line_number::4
<address>  College Park, MD 20742   </address>::line_number::5
<email>  flip@cs.umd.edu   </email>::line_number::6
<author>  H. V. Jagadish   </author>::line_number::7
<affiliation>  AT&T Laboratories   </affiliation>::line_number::8
<address>  Florham Park, NJ 07932   </address>::line_number::9
<email>  jag@research.att.com   </email>::line_number::10
<author>  Christos Faloutsos    </author>::line_number::11
<affiliation>  Dept. of Computer Science and  </affiliation>::line_number::12
<affiliation> Inst. for Systems Research  </affiliation>::line_number::13
<affiliation> University of Maryland   </affiliation>::line_number::14
<address>  College Park, MD 20742   </address>::line_number::15
<email>  christos@cs.umd.edu   </email>::line_number::16
<abstract>  Abstract  </abstract>::line_number::17
<abstract> Ad hoc querying is difficult on very large datasets, since it  </abstract>::line_number::18
<abstract> is usually not possible to have the entire dataset on disk.  </abstract>::line_number::19
<abstract> While compression can be used to decrease the size of the  </abstract>::line_number::20
<abstract> dataset, compressed data is notoriously difficult to index  </abstract>::line_number::21
<abstract> or access.  </abstract>::line_number::22
<abstract> In this paper we consider a very large dataset comprising multiple distinct time sequences. Each point in the  </abstract>::line_number::23
<abstract> sequence is a numerical value. We show how to compress  </abstract>::line_number::24
<abstract> such a dataset into a format that supports ad hoc querying, provided that a small error can be tolerated when the  </abstract>::line_number::25
<abstract> data is uncompressed. Experiments on large, real world  </abstract>::line_number::26
<abstract> datasets (AT&T customer calling patterns) show that the  </abstract>::line_number::27
<abstract> proposed method achieves an average of less than 5% error  </abstract>::line_number::28
<abstract> in any data value after compressing to a mere 2.5% of the  </abstract>::line_number::29
<abstract> original space (i.e., a 40:1 compression ratio), with these  </abstract>::line_number::30
<abstract> numbers not very sensitive to dataset size. Experiments  </abstract>::line_number::31
<abstract> on aggregate queries achieved a 0.5% reconstruction error  </abstract>::line_number::32
<abstract> with a space requirement under 2%.   </abstract>::line_number::33
<intro>  1 Introduction  </intro>::line_number::34

<title>  How to Be a Good  </title>::line_number::0
<title> Graduate Student  </title>::line_number::1
<title> Advisor   </title>::line_number::2
<author>  Marie desJardins   </author>::line_number::3
<email>  marie@erg.sri.com   </email>::line_number::4
<date>  March 1994   </date>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> This paper attempts to raise some issues that  </abstract>::line_number::7
<abstract> are important for graduate students to be successful and to get as much out of the process  </abstract>::line_number::8
<abstract> as possible, and for advisors who wish to help  </abstract>::line_number::9
<abstract> their students be successful. The intent is not  </abstract>::line_number::10
<abstract> to provide prescriptive advice no formulas for  </abstract>::line_number::11
<abstract> finishing a thesis or twelve-step programs for becoming a better advisor are given but to raise  </abstract>::line_number::12
<abstract> awareness on both sides of the advisor-student  </abstract>::line_number::13
<abstract> relationship as to what the expectations are and  </abstract>::line_number::14
<abstract> should be for this relationship, what a graduate  </abstract>::line_number::15
<abstract> student should expect to accomplish, common  </abstract>::line_number::16
<abstract> problems, and where to go if the advisor is not  </abstract>::line_number::17
<abstract> forthcoming.   </abstract>::line_number::18
<intro>  1 Introduction  </intro>::line_number::19

<note>  To appear, Computer Aided Design, 1995 or 1996   </note>::line_number::0
<title>  GENERATING REDESIGN SUGGESTIONS TO REDUCE SETUP COST:  </title>::line_number::1
<title> A STEP TOWARDS AUTOMATED REDESIGN   </title>::line_number::2
<author>  Diganta Das   </author>::line_number::3
<affiliation>  Mechanical Engr. Dept. and  </affiliation>::line_number::4
<affiliation> Institute for Systems Research,  </affiliation>::line_number::5
<affiliation> University of Maryland   </affiliation>::line_number::6
<address>  College Park, MD 20742   </address>::line_number::7
<email>  diganta@cs.umd.edu   </email>::line_number::8
<author>  Satyandra K. Gupta   </author>::line_number::9
<affiliation>  The Robotics Institute  </affiliation>::line_number::10
<affiliation> Carnegie Mellon University   </affiliation>::line_number::11
<address>  Pittsburgh, PA 15213   </address>::line_number::12
<email>  skgupta@isl1.ri.cmu.edu   </email>::line_number::13
<author>  Dana S. Nau   </author>::line_number::14
<affiliation>  Dept. of Computer Science and  </affiliation>::line_number::15
<affiliation> Institute for Systems Research,  </affiliation>::line_number::16
<affiliation> University of Maryland   </affiliation>::line_number::17
<address>  College Park, MD 20742   </address>::line_number::18
<email>  nau@cs.umd.edu   </email>::line_number::19
<abstract>  Abstract  </abstract>::line_number::20
<abstract> All mechanical designs pass through a series of formal and informal redesign steps, involving the analysis of functionality, manufacturability, cost and other life-cycle factors. The  </abstract>::line_number::21
<abstract> speed and efficacy of these steps has a major influence on the lead time of the product from  </abstract>::line_number::22
<abstract> conceptualization to launching. In this paper we propose a methodology for automatically  </abstract>::line_number::23
<abstract> generating redesign suggestions for reducing setup costs for machined parts.  </abstract>::line_number::24
<abstract> Given an interpretation of the design as a collection of machinable features, our approach  </abstract>::line_number::25
<abstract> is to generate alternate machining features by making geometric changes to the original  </abstract>::line_number::26
<abstract> features, and add them to the feature set of the original part to create an extended feature  </abstract>::line_number::27
<abstract> set. The designer may provide restrictions on the design indicating the type and extent of  </abstract>::line_number::28
<abstract> modifications allowed on certain faces and volumes, in which case all redesign suggestions  </abstract>::line_number::29
<abstract> generated by our approach honor those restrictions.  </abstract>::line_number::30
<abstract> By taking combinations of features from the extended feature set generated above, we can  </abstract>::line_number::31
<abstract> generate modified versions of the original design that still satisfy the designer's intent. By  </abstract>::line_number::32
<abstract> considering precedence constraints and approach directions for the machining operations as  </abstract>::line_number::33
<abstract> well as simple fixturability constraints, we can estimate the setup time that will be required  </abstract>::line_number::34
<abstract> for each design. Any modified design whose setup time is less than that of the original  </abstract>::line_number::35
<abstract> design can be presented to the designer as a possible way to modify the original design.   </abstract>::line_number::36
<page>  +PAGE+  </page>::line_number::37

<title>  Transport and Display Mechanisms For Multimedia  </title>::line_number::0
<title> Conferencing Across Packet-Switched Networks *   </title>::line_number::1
<author>  K. Jeffay, D.L. Stone, F.D. Smith   </author>::line_number::2
<affiliation>  University of North Carolina at Chapel Hill  </affiliation>::line_number::3
<affiliation> Department of Computer Science   </affiliation>::line_number::4
<address>  Chapel Hill, NC 27599-3175 USA   </address>::line_number::5
<email>  -jeffay,stone,smithfd-@cs.unc.edu   </email>::line_number::6
<date>  September, 1993   </date>::line_number::7
<abstract>  Abstract: A transport protocol that supports real-time communication of  </abstract>::line_number::8
<abstract> audio/video frames across campus-area packet switched networks is presented.  </abstract>::line_number::9
<abstract> It is a best effort protocol that attempts to ameliorate the effect of jitter, load  </abstract>::line_number::10
<abstract> variation, and packet loss, to provide low latency, synchronized audio and video  </abstract>::line_number::11
<abstract> communications. This goal is realized through four transport and display  </abstract>::line_number::12
<abstract> mechanisms, and a real-time implementation of these mechanisms that  </abstract>::line_number::13
<abstract> integrates operating system services ( e.g., scheduling and resource allocation,  </abstract>::line_number::14
<abstract> and device management) with network communication services ( e.g., transport  </abstract>::line_number::15
<abstract> protocols), and with application code ( e.g., display routines). The four  </abstract>::line_number::16
<abstract> mechanisms are: a facility for varying the synchronization between audio and  </abstract>::line_number::17
<abstract> video to achieve continuous audio in the face of jitter, a network congestion  </abstract>::line_number::18
<abstract> monitoring mechanism that is used to control audio/video latency, a queueing  </abstract>::line_number::19
<abstract> mechanism at the sender that is used to maximize frame throughput without  </abstract>::line_number::20
<abstract> unnecessarily increasing latency, and a forward error correction mechanism for  </abstract>::line_number::21
<abstract> transmitting audio frames multiple times to ameliorate the effects of packet loss  </abstract>::line_number::22
<abstract> in the network. The effectiveness of these techniques is demonstrated by  </abstract>::line_number::23
<abstract> measuring the performance of the protocol when transmitting audio and video  </abstract>::line_number::24
<abstract> across congested networks.   </abstract>::line_number::25
<note>  Published in: Computer Networks and ISDN Systems,  </note>::line_number::26
<note> Vol. 26, No. 10, (July 1994) pp. 1281-1304.  </note>::line_number::27
<note> * This work supported in parts by grants from the National Science Foundation (numbers CCR-9110938 and ICI  </note>::line_number::28
<note> 9015443), and by the Digital Equipment Corporation and the IBM Corporation.   </note>::line_number::29
<page>  +PAGE+  </page>::line_number::30

<note>  To appear in 1996 ACM SIGMETRICS (Extended Version: UMass TR 95-98, Nov. 1995)   </note>::line_number::0
<title>  Supporting Stored Video: Reducing Rate Variability and End-to-End Resource  </title>::line_number::1
<title> Requirements through Optimal Smoothing    </title>::line_number::2
<author>  James D. Salehi, Zhi-Li Zhang, James F. Kurose, and Don Towsley   </author>::line_number::3
<affiliation>  Department of Computer Science, University of Massachusetts,   Amherst MA 01003, USA   </affiliation>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> VBR compressed video is known to exhibit significant, multiple-  </abstract>::line_number::6
<abstract> time-scale bit rate variability. In this paper, we consider the transmission of stored video from a server to a client across a high speed  </abstract>::line_number::7
<abstract> network, and explore how the client buffer space can be used most  </abstract>::line_number::8
<abstract> effectively toward reducing the variability of the transmitted bit  </abstract>::line_number::9
<abstract> rate.  </abstract>::line_number::10
<abstract> We present two basic results. First, we present an optimal  </abstract>::line_number::11
<abstract> smoothing algorithm for achieving the greatest possible reduction  </abstract>::line_number::12
<abstract> in rate variability when transmitting stored video to a client with  </abstract>::line_number::13
<abstract> given buffer size. We provide a formal proof of optimality, and  </abstract>::line_number::14
<abstract> demonstrate the performance of the algorithm on a set of long  </abstract>::line_number::15
<abstract> MPEG-1 encoded video traces. Second, we evaluate the impact  </abstract>::line_number::16
<abstract> of optimal smoothing on the network resources needed for video  </abstract>::line_number::17
<abstract> transport, under two network service models: Deterministic Guar-  </abstract>::line_number::18
<abstract> anteed service [1, 11] and Renegotiated CBR (RCBR) service [9, 8].  </abstract>::line_number::19
<abstract> Under both models, we find the impact of optimal smoothing to be  </abstract>::line_number::20
<abstract> dramatic.   </abstract>::line_number::21
<intro>  1 Introduction  </intro>::line_number::22

<title>  Alleviating Priority Inversion and Non-determinism  </title>::line_number::0
<title> in Real-time CORBA ORB Core Architectures   </title>::line_number::1
<author>  Douglas C. Schmidt, Sumedh Mungee, and Aniruddha Gokhale   </author>::line_number::2
<email>  fschmidt,sumedh,gokhaleg@cs.wustl.edu   </email>::line_number::3
<affiliation>  Department of Computer Science, Washington University   </affiliation>::line_number::4
<address>  St. Louis, MO 63130, USA    </address>::line_number::5
<note>  This paper has been submitted to the 4 th IEEE Real-time  </note>::line_number::6
<note> Technology and Applications Symposium (RTAS), Denver,  </note>::line_number::7
<note> Colorado, June 3-5, 1998.   </note>::line_number::8
<abstract>  Abstract  </abstract>::line_number::9
<abstract> There is increasing demand to extend CORBA to support  </abstract>::line_number::10
<abstract> applications with stringent real-time requirements. However, conventional CORBA Object Request Brokers (ORBs)  </abstract>::line_number::11
<abstract> exhibit substantial priority inversion and non-determinism,  </abstract>::line_number::12
<abstract> which makes them unsuitable for applications with deterministic real-time requirements. This paper focuses on software  </abstract>::line_number::13
<abstract> architectures that help to alleviate priority inversion and non-determinism in real-time CORBA ORBs. It also illustrates empirically why conventional ORBs do not yet support real-time  </abstract>::line_number::14
<abstract> quality of service.   </abstract>::line_number::15
<keyword>  Keywords: Real-time CORBA Object Request Broker, QoS-enabled OO Middleware, Performance Measurements   </keyword>::line_number::16
<intro>  1 Introduction  </intro>::line_number::17

<title>  Reducing False Sharing on Shared Memory Multiprocessors  </title>::line_number::0
<title> through Compile Time Data Transformations   </title>::line_number::1
<author>  Tor E. Jeremiassen   </author>::line_number::2
<affiliation>  AT&T Bell Laboratories    </affiliation>::line_number::3
<address>  600 Mountain Ave.  </address>::line_number::4
<address> Murray Hill, New Jersey 07974   </address>::line_number::5
<email>  tor@research.att.com   </email>::line_number::6
<author>  Susan J. Eggers   </author>::line_number::7
<affiliation>  Department of Computer Science and Engineering  </affiliation>::line_number::8
<affiliation> University of Washington   </affiliation>::line_number::9
<address>  Seattle, Washington 98195   </address>::line_number::10
<email>  eggers@cs.washington.edu   </email>::line_number::11
<abstract>  Abstract  </abstract>::line_number::12
<abstract> We have developed compiler algorithms that analyze explicitly parallel programs and restructure their shared data to  </abstract>::line_number::13
<abstract> reduce the number of false sharing misses. The algorithms  </abstract>::line_number::14
<abstract> analyze per-process shared data accesses, pinpoint the data  </abstract>::line_number::15
<abstract> structures that are susceptible to false sharing and choose  </abstract>::line_number::16
<abstract> an appropriate transformation to reduce it. The transformations either group data that is accessed by the same processor or separate individual data items that are shared.  </abstract>::line_number::17
<abstract> This paper evaluates that technique. We show through  </abstract>::line_number::18
<abstract> simulation that our analysis successfully identifies the data  </abstract>::line_number::19
<abstract> structures that are responsible for most false sharing misses,  </abstract>::line_number::20
<abstract> and then transforms them without unduly decreasing spatial  </abstract>::line_number::21
<abstract> locality. The reduction in false sharing positively impacts  </abstract>::line_number::22
<abstract> both execution time and program scalability when executed  </abstract>::line_number::23
<abstract> on a KSR2. Both factors combine to increase the maximum  </abstract>::line_number::24
<abstract> achievable speedup for all programs, more than doubling  </abstract>::line_number::25
<abstract> it for several. Despite being able to only approximate actual inter-processor memory accesses, the compiler-directed  </abstract>::line_number::26
<abstract> transformations always outperform programmer efforts to  </abstract>::line_number::27
<abstract> eliminate false sharing.   </abstract>::line_number::28
<intro>  1 Introduction  </intro>::line_number::29

<note>  To appear in Proceedings of the Twenty Third ACM SIGPLAN-SIGACT  </note>::line_number::0
<note> Symposium on Principles of Programming Languages, St. Petersburg  </note>::line_number::1
<note> Beach, Florida, January 21-24, 1996. c fl1996 ACM (see notice below).   </note>::line_number::2
<title>  Is it a Tree, a DAG, or a Cyclic Graph?  </title>::line_number::3
<title> A Shape Analysis for Heap-Directed Pointers in C   </title>::line_number::4
<author>  Rakesh Ghiya and Laurie J. Hendren   </author>::line_number::5
<affiliation>  School of Computer Science, McGill University   </affiliation>::line_number::6
<address>  Montreal, Quebec, CANADA H3A 2A7   </address>::line_number::7
<email>  fghiya,hendreng@cs.mcgill.ca   </email>::line_number::8
<abstract>  Abstract  </abstract>::line_number::9
<abstract> This paper reports on the design and implementation of a practical shape analysis for C. The purpose of the analysis is to aid in the disambiguation of  </abstract>::line_number::10
<abstract> heap-allocated data structures by estimating the shape  </abstract>::line_number::11
<abstract> (Tree, DAG, or Cyclic Graph) of the data structure accessible from each heap-directed pointer. This shape  </abstract>::line_number::12
<abstract> information can be used to improve dependence testing and in parallelization, and to guide the choice of  </abstract>::line_number::13
<abstract> more complex heap analyses.  </abstract>::line_number::14
<abstract> The method has been implemented as a context-sensitive interprocedural analysis in the McCAT compiler. Experimental results and observations are given  </abstract>::line_number::15
<abstract> for 16 benchmark programs. These results show that  </abstract>::line_number::16
<abstract> the analysis gives accurate and useful results for an  </abstract>::line_number::17
<abstract> important group of applications.   </abstract>::line_number::18
<intro>  1 Introduction and Related  </intro>::line_number::19

<title>  Compiler Support for Maintaining Cache  </title>::line_number::0
<title> Coherence Using Data Prefetching ?   </title>::line_number::1
<note>  (Extended Abstract)   </note>::line_number::2
<author>  Hock-Beng Lim 1 , Lynn Choi 2 and Pen-Chung Yew 3   </author>::line_number::3
<affiliation>  1 Center for Supercomputing R & D, Univ. of Illinois,   Urbana, IL 61801   </affiliation>::line_number::4
<affiliation>  2 Microprocessor Group, Intel Corporation,   Santa Clara, CA 95095   </affiliation>::line_number::5
<affiliation>  3 Dept. of Computer Science, Univ. of Minnesota,   Minneapolis, MN 55455   </affiliation>::line_number::6
<intro>  1 Introduction and Motivation  </intro>::line_number::7

<title>  INTEGRATING FINE-GRAINED MESSAGE PASSING IN CACHE COHERENT  </title>::line_number::0
<title> SHARED MEMORY MULTIPROCESSORS (*)   </title>::line_number::1
<author>  David K. Poulsen   </author>::line_number::2
<affiliation>  Kuck and Associates, Inc.   </affiliation>::line_number::3
<address>  1906 Fox Drive  </address>::line_number::4
<address> Champaign, IL 61821   </address>::line_number::5
<phone>  217-356-2288   </phone>::line_number::6
<email>  poulsen@kai.com   </email>::line_number::7
<author>  and  </author>::line_number::8
<author> Pen-Chung Yew   </author>::line_number::9
<affiliation>  Department of Computer Science  </affiliation>::line_number::10
<affiliation> University of Minnesota   </affiliation>::line_number::11
<address>  4-192 EE/CS Building  </address>::line_number::12
<address> 200 Union Street SE  </address>::line_number::13
<address> Minneapolis, MN 55455   </address>::line_number::14
<email>  yew@cs.umn.edu   </email>::line_number::15
<note>  (*) This work was supported in part by the National Science Foundation under grant nos. NSF MIP 93-07910 and  </note>::line_number::16
<note> NSF MIP 89-20891, the Department of Energy under grant no. DOE DE FG02-85ER25001, the National Security  </note>::line_number::17
<note> Agency, and an IBM Resident Study Fellowship.  </note>::line_number::18
<note> This work was performed while the authors were with the Center for Supercomputing Research and Development,  </note>::line_number::19
<note> University of Illinois at Urbana-Champaign, Urbana, IL 61801.   </note>::line_number::20
<page>  +PAGE+  </page>::line_number::21

<title>  Constraint-Based Animations   </title>::line_number::0
<author>  Allan Heydon Greg Nelson   </author>::line_number::1
<affiliation>  Digital Systems Research Center   </affiliation>::line_number::2
<address>  130 Lytton Ave., Palo Alto, CA 94301   </address>::line_number::3
<email>  fheydon,gnelsong@pa.dec.com   </email>::line_number::4
<note>  Copyright c fl1995, Digital Equipment Corporation. All right reserved.   </note>::line_number::5
<intro>  1. Introduction  </intro>::line_number::6

<title>  Dynamic Resource Management for Continuous  </title>::line_number::0
<title> Media Traffic over ATM Networks   </title>::line_number::1
<author>  Rose P. Tsang 1 , Paisal Keattithananant  </author>::line_number::2
<author> Taisheng Chang 3 , Jenwei Hsieh 3 , David H.C. Du 2   </author>::line_number::3
<affiliation>  Distributed Multimedia Center 3  </affiliation>::line_number::4
<affiliation> Computer Science Department  </affiliation>::line_number::5
<affiliation> University of Minnesota   </affiliation>::line_number::6
<address>  Minneapolis, MN 55455   </address>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> Real-time continuous media traffic, such as digital video and audio, is expected  </abstract>::line_number::9
<abstract> to comprise a large percentage of the network load on future high speed packet  </abstract>::line_number::10
<abstract> switch networks such as ATM. A major feature which distinguishes high speed  </abstract>::line_number::11
<abstract> networks from traditional slower speed networks is the large amount of data the  </abstract>::line_number::12
<abstract> network must manage. For efficient network usage, traffic control mechanisms are  </abstract>::line_number::13
<abstract> essential. Currently, most mechanisms for traffic control (such as flow control)  </abstract>::line_number::14
<abstract> have centered on the support of Available Bit Rate (ABR), i.e., non real-time,  </abstract>::line_number::15
<abstract> traffic. With regard to ATM, for ABR traffic, two major types of schemes which  </abstract>::line_number::16
<abstract> have been proposed are rate-control and credit-control schemes. Neither of these  </abstract>::line_number::17
<abstract> schemes are directly applicable to Real-time Variable Bit Rate (VBR) traffic such  </abstract>::line_number::18
<abstract> as continuous media traffic. Traffic control for continuous media traffic is an inherently difficult problem due to the time-sensitive nature of the traffic and its  </abstract>::line_number::19
<abstract> unpredictable burstiness. In this study, we present a scheme which controls traffic by dynamically allocating/de-allocating resources among competing VCs based  </abstract>::line_number::20
<abstract> upon their real-time requirements. This scheme incorporates a form of rate-control,  </abstract>::line_number::21
<abstract> real-time burst-level scheduling and link-link flow control. We show analytically potential performance improvements of our rate-control scheme and present a scheme  </abstract>::line_number::22
<abstract> for buffer dimensioning. We also present simulation results of our schemes and discuss the tradeoffs inherent in maintaining high network utilization and statistically  </abstract>::line_number::23
<abstract> guaranteeing many users' Quality of Service.   </abstract>::line_number::24
<keyword>  Keywords: Asynchronous Transfer Mode (ATM), dynamic traffic control, resource man  </keyword>::line_number::25
<keyword> agement, rate control, Real-time Variable Bit Rate traffic, continuous media traffic.   </keyword>::line_number::26
<note>  1 This work is supported in part by U S WEST Communications.  </note>::line_number::27

<note>  A short version of this paper appears in Supercomputing 1996   </note>::line_number::0
<note> The serial algorithms described in this paper are implemented by the  </note>::line_number::1
<note> `METIS: Unstructured Graph Partitioning and Sparse Matrix Ordering System'.  </note>::line_number::2
<web> METIS is available on WWW at URL:   http://www.cs.umn.edu/karypis/metis/metis.html   </web>::line_number::3
<title>  Parallel Multilevel k -way Partitioning Scheme for  </title>::line_number::4
<title> Irregular Graphs   </title>::line_number::5
<author>  George Karypis and Vipin Kumar   </author>::line_number::6
<affiliation>  University of Minnesota, Department of Computer Science   </affiliation>::line_number::7
<address>  Minneapolis, MN 55455,   Technical Report: 96-036   </address>::line_number::8
<email>  fkarypis, kumarg@cs.umn.edu   </email>::line_number::9
<note>  Last updated on October 24, 1996 at 9:02am   </note>::line_number::10
<abstract>  Abstract  </abstract>::line_number::11
<abstract> In this paper we present a parallel formulation of a multilevel k-way graph partitioning algorithm. The multilevel  </abstract>::line_number::12
<abstract> k-way partitioning algorithm reduces the size of the graph by collapsing vertices and edges (coarsening phase), finds  </abstract>::line_number::13
<abstract> a k-way partitioning of the smaller graph, and then it constructs a k-way partitioning for the original graph by projecting and refining the partition to successively finer graphs (uncoarsening phase). A key innovative feature of our  </abstract>::line_number::14
<abstract> parallel formulation is that it utilizes graph coloring to effectively parallelize both the coarsening and the refinement  </abstract>::line_number::15
<abstract> during the uncoarsening phase. Our algorithm is able to achieve a high degree of concurrency, while maintaining the  </abstract>::line_number::16
<abstract> high quality partitions produced by the serial algorithm. We test our scheme on a large number of graphs from finite  </abstract>::line_number::17
<abstract> element methods, and transportation domains. For graphs with a million vertices, our parallel formulation produces  </abstract>::line_number::18
<abstract> high quality 128-way partitions on 128 processors in a little over two seconds, on Cray T3D. Thus our parallel algorithm makes it feasible to perform frequent dynamic graph partition in adaptive computations without compromising  </abstract>::line_number::19
<abstract> quality.   </abstract>::line_number::20
<keyword>  Keywords: Parallel Graph Partitioning, Multilevel Partitioning Methods, Spectral Partitioning Methods,  </keyword>::line_number::21
<keyword> Kernighan-Lin Heuristic, Parallel Sparse Matrix Algorithms.   </keyword>::line_number::22
<note>  This work was supported by NSF CCR-9423082 and by Army Research Office contract DA/DAAH04-95-1-0538, and by Army High Performance Computing Research Center under the auspices of the Department of the Army, Army Research Laboratory cooperative agreement  </note>::line_number::23
<note> number DAAH04-95-2-0003/contract number DAAH04-95-C-0008, the content of which does not necessarily reflect the position or the policy of the government, and no official endorsement should be inferred. Access to computing facilities was provided by AHPCRC, Minnesota  </note>::line_number::24
<note> Supercomputer Institute, Cray Research Inc, and by the Pittsburgh Supercomputing Center. Related papers are available via WWW at URL:  </note>::line_number::25
<note> http://www.cs.umn.edu/karypis   </note>::line_number::26
<page>  +PAGE+  </page>::line_number::27

<title>  Optimizing Multi-Join Queries in Parallel Relational Databases   </title>::line_number::0
<author>  Jaideep Srivastava  </author>::line_number::1
<author> Gary Elsesser   </author>::line_number::2
<affiliation>  Computer Science Department  </affiliation>::line_number::3
<affiliation> University of Minnesota   </affiliation>::line_number::4
<address>  Minneapolis, MN 55455   </address>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Query optimization for parallel machines needs to  </abstract>::line_number::7
<abstract> consider machine architecture, processor and memory  </abstract>::line_number::8
<abstract> resources available, and different types of parallelism,  </abstract>::line_number::9
<abstract> making the search space much larger than the sequential case. In this paper our aim is to determine a plan  </abstract>::line_number::10
<abstract> that makes the execution of an individual query very  </abstract>::line_number::11
<abstract> fast, making minimizing parallel execution time the  </abstract>::line_number::12
<abstract> right objective. This creates the following circular dependence: a plan tree is needed for effective resource  </abstract>::line_number::13
<abstract> assignment, which is needed to estimate the parallel  </abstract>::line_number::14
<abstract> execution time, and this is needed for the cost-based  </abstract>::line_number::15
<abstract> search for a good plan tree. In this paper we propose  </abstract>::line_number::16
<abstract> a new search heuristic that breaks the cycle by constructing the plan tree layer by layer in a bottom-up  </abstract>::line_number::17
<abstract> manner. To select nodes at the next level, the lower  </abstract>::line_number::18
<abstract> and upper bounds on the execution time for plans consistent with the decisions made so far are estimated  </abstract>::line_number::19
<abstract> and are used to guide the search. A query plan representation for intra- and inter-operator parallelism,  </abstract>::line_number::20
<abstract> pipelining, and processor and memory assignment is  </abstract>::line_number::21
<abstract> proposed. Also proposed is a new approach to estimating the parallel execution time of a plan that considers  </abstract>::line_number::22
<abstract> sum and max of operators working sequentially and  </abstract>::line_number::23
<abstract> in parallel, respectively. The results obtained from a  </abstract>::line_number::24
<abstract> prototype optimizer are presented.   </abstract>::line_number::25
<intro>  1 Introduction  </intro>::line_number::26

<pubnum>  CS/TR-92-80   </pubnum>::line_number::0
<title>  The COOL architecture and abstractions for object-oriented  </title>::line_number::1
<title> distributed operating systems   </title>::line_number::2
<author>  Rodger Lea, Christian Jacquemot   </author>::line_number::3
<note>  approved by:  </note>::line_number::4
<note> distribution: COOL   </note>::line_number::5
<abstract>  abstract: Building distributed operating systems benefits from the micro-kernel approach by allowing better support for modularization. However, we believe  </abstract>::line_number::6
<abstract> that we need to take this support a step further. A more modular, or object  </abstract>::line_number::7
<abstract> oriented approach is needed if we wish to cross the barrier of complexity that  </abstract>::line_number::8
<abstract> is holding back distributed operating system development. The Chorus Ob  </abstract>::line_number::9
<abstract> ject Oriented Layer (COOL) is a layer built above the Chorus micro-kernel  </abstract>::line_number::10
<abstract> designed to extend the micro-kernel abstractions with support for object oriented systems. COOL v2, the second iteration of this layer provides generic  </abstract>::line_number::11
<abstract> support for clusters of objects, in a distributed virtual memory model. It is  </abstract>::line_number::12
<abstract> built as a layered system where the lowest layer support only clusters and the  </abstract>::line_number::13
<abstract> upper layers support objects.   </abstract>::line_number::14
<note>  c Chorus systemes, 1992  </note>::line_number::15
<note> c Chorus systemes, 1992 September 21, 1992   </note>::line_number::16
<page>  +PAGE+  </page>::line_number::17

<title>  Using PVS to Analyze Hierarchical State-Based Requirements for  </title>::line_number::0
<title> Completeness and Consistency    </title>::line_number::1
<author>  Mats P.E. Heimdahl   </author>::line_number::2
<affiliation>  University of Minnesota, Institute of Technology  </affiliation>::line_number::3
<address> Department of Computer Science,   4-192 EE/CS Bldg.  </address>::line_number::4
<address> Minneapolis, MN 55455   </address>::line_number::5
<email>  heimdahl@cs.umn.edu   </email>::line_number::6
<author>  Barbara J. Czerny   </author>::line_number::7
<affiliation>  Department of Computer Science,   A-714 Wells Hall   </affiliation>::line_number::8
<affiliation>  Michigan State University   </affiliation>::line_number::9
<address>  East Lansing, MI 48824   </address>::line_number::10
<email>  czerny@cps.msu.edu   </email>::line_number::11
<intro>  1 Introduction  </intro>::line_number::12

<title>  AN ALGORITHM FOR GENERATING EXECUTABLE  </title>::line_number::0
<title> ASSERTIONS FOR FAULT TOLERANCE    </title>::line_number::1
<author>  Martina Schollmeyer, Hanan Lutfiyya and Bruce McMillin   </author>::line_number::2
<pubnum>  CSC-92-01   </pubnum>::line_number::3
<date>  March 21, 1992   </date>::line_number::4
<affiliation>  Department of Computer Science  </affiliation>::line_number::5
<affiliation> University of Missouri at Rolla   </affiliation>::line_number::6
<address>  Rolla, Missouri 65401   </address>::line_number::7
<note>  This work was supported in part by the National Science Foundation under Grant Numbers MIP-8909749 and CDA-8820714, and in part by the AMOCO Faculty Development  </note>::line_number::8
<note> Program.   </note>::line_number::9
<page>  +PAGE+  </page>::line_number::10

<note>  To be presented at the 17th IEEE Real-Time Systems Symposium, December 1996.   </note>::line_number::0
<title>  A Framework for Implementing Objects and Scheduling Tasks in Lock-Free  </title>::line_number::1
<title> Real-Time Systems    </title>::line_number::2
<author>  James H. Anderson and Srikanth Ramamurthy   </author>::line_number::3
<affiliation>  Department of Computer Science, University of North Carolina at Chapel Hill   </affiliation>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> We present an integrated framework for developing real-time systems in which lock-free algorithms are employed to  </abstract>::line_number::6
<abstract> implement shared objects. There are two key objectives of  </abstract>::line_number::7
<abstract> our work. The first is to enable functionality for object sharing in lock-free real-time systems that is comparable to that  </abstract>::line_number::8
<abstract> in lock-based systems. Our main contribution toward this  </abstract>::line_number::9
<abstract> objective is an efficient approach for implementing multi-object lock-free operations and transactions. A second key  </abstract>::line_number::10
<abstract> objective of our work is to improve upon previously proposed  </abstract>::line_number::11
<abstract> scheduling conditions for tasks that share lock-free objects.  </abstract>::line_number::12
<abstract> When developing such conditions, the key issue is to bound  </abstract>::line_number::13
<abstract> the cost of operation interferences. We present a general  </abstract>::line_number::14
<abstract> approach for doing this, based on linear programming.   </abstract>::line_number::15
<intro>  1. Introduction  </intro>::line_number::16

<title>  Universal Constructions for Large Objects   </title>::line_number::0
<author>  James H. Anderson and Mark Moir   </author>::line_number::1
<affiliation>  Dept. of Computer Science, University of North Carolina at Chapel Hill   </affiliation>::line_number::2
<abstract>  Abstract  </abstract>::line_number::3
<abstract> We present lock-free and wait-free universal constructions for implementing large  </abstract>::line_number::4
<abstract> shared objects. Most previous universal constructions require processes to copy the  </abstract>::line_number::5
<abstract> entire object state, which is impractical for large objects. Previous attempts to  </abstract>::line_number::6
<abstract> address this problem require programmers to explicitly fragment large objects into  </abstract>::line_number::7
<abstract> smaller, more manageable pieces, paying particular attention to how such pieces are  </abstract>::line_number::8
<abstract> copied. In contrast, our constructions are designed to largely shield programmers  </abstract>::line_number::9
<abstract> from this fragmentation. Furthermore, for many objects, our constructions result  </abstract>::line_number::10
<abstract> in lower copying overhead than previous ones.  </abstract>::line_number::11
<abstract> Fragmentation is achieved in our constructions through the use of load-linked,  </abstract>::line_number::12
<abstract> store-conditional, and validate operations on a "large" multi-word shared variable.  </abstract>::line_number::13
<abstract> Before presenting our constructions, we show that these operations can be efficiently  </abstract>::line_number::14
<abstract> implemented from similar one-word primitives.   </abstract>::line_number::15
<intro>  1 Introduction  </intro>::line_number::16

<title>  View-Dependent Simplification Of Arbitrary Polygonal Environments   </title>::line_number::0
<author>  David Luebke, Carl Erikson   </author>::line_number::1
<affiliation>  Department of Computer Science  </affiliation>::line_number::2
<affiliation> University of North Carolina at Chapel Hill   </affiliation>::line_number::3
<abstract>  1. ABSTRACT  </abstract>::line_number::4
<abstract> Hierarchical dynamic simplification (HDS) is a new approach to  </abstract>::line_number::5
<abstract> the problem of simplifying arbitrary polygonal environments.  </abstract>::line_number::6
<abstract> HDS operates dynamically, retessellating the scene continuously  </abstract>::line_number::7
<abstract> as the users viewing position shifts, and adaptively, processing  </abstract>::line_number::8
<abstract> the entire database without first decomposing the environment  </abstract>::line_number::9
<abstract> into individual objects. The resulting system allows real-time  </abstract>::line_number::10
<abstract> display of very complex polygonal CAD models consisting of  </abstract>::line_number::11
<abstract> thousands of parts and hundreds of thousands of polygons. HDS  </abstract>::line_number::12
<abstract> supports various preprocessing algorithms and various runtime  </abstract>::line_number::13
<abstract> criteria, providing a general framework for dynamic view-dependent simplification.  </abstract>::line_number::14
<abstract> Briefly, HDS works by clustering vertices together in a  </abstract>::line_number::15
<abstract> hierarchical fashion. The simplification process continuously  </abstract>::line_number::16
<abstract> queries this hierarchy to generate a scene containing only those  </abstract>::line_number::17
<abstract> polygons that are important from the current viewpoint. When  </abstract>::line_number::18
<abstract> the volume of space associated with a vertex cluster occupies less  </abstract>::line_number::19
<abstract> than a userspecified amount of the screen, all vertices within  </abstract>::line_number::20
<abstract> that cluster are collapsed together and degenerate polygons  </abstract>::line_number::21
<abstract> filtered out. HDS maintains an active list of visible polygons for  </abstract>::line_number::22
<abstract> rendering. Since frame-to-frame movements typically involve  </abstract>::line_number::23
<abstract> small changes in viewpoint, and therefore modify the active list  </abstract>::line_number::24
<abstract> by only a few polygons, the method takes advantage of temporal  </abstract>::line_number::25
<abstract> coherence for greater speed.  </abstract>::line_number::26
<abstract> CR Categories: I.3.5 [Computer Graphics]: Computational Geometry and  </abstract>::line_number::27
<abstract> Object Modeling - surfaces and object representations.  </abstract>::line_number::28
<abstract> Additional Keywords: polygonal simplification, level of detail, view  </abstract>::line_number::29
<abstract> dependent rendering.   </abstract>::line_number::30
<intro>  2. INTRODUCTION  </intro>::line_number::31

<title>  Modeling and Parameter Estimation of the Human Index Finger   </title>::line_number::0
<author>  Robert N. Rohling and John M. Hollerbach   </author>::line_number::1
<affiliation>  Biorobotics Laboratory, McGill University   </affiliation>::line_number::2
<address>  3775 University St., Montreal, Quebec H3A 2B4   </address>::line_number::3
<abstract>  Abstract  </abstract>::line_number::4
<abstract> Precise teleoperation of dextrous robotic hands by  </abstract>::line_number::5
<abstract> hand masters requires an accurate human hand model.  </abstract>::line_number::6
<abstract> A kinematic model of a human index finger is developed as an example for human hand modeling. The  </abstract>::line_number::7
<abstract> parameters of the model are determined by open-loop  </abstract>::line_number::8
<abstract> kinematic calibration. Singular value decomposition is  </abstract>::line_number::9
<abstract> used as a tool for analyzing the kinematic model and  </abstract>::line_number::10
<abstract> the identification process. Accurate and reliable results are obtained only when the numerical condition  </abstract>::line_number::11
<abstract> is minimized through parameter scaling, model reduction and pose set selection. The identified kinematic  </abstract>::line_number::12
<abstract> parameters show the kinematic model and calibration  </abstract>::line_number::13
<abstract> procedure have an accuracy on the order of a few millimeters.   </abstract>::line_number::14
<intro>  1 Introduction  </intro>::line_number::15

<title>  A Dossier Driven Persistent Objects Facility   </title>::line_number::0
<author>  Robert Mecklenburg, Charles Clark, Gary Lindstrom and Benny Yih   </author>::line_number::1
<affiliation>  University of Utah Center for Software Science  </affiliation>::line_number::2
<affiliation> Department of Computer Science   </affiliation>::line_number::3
<address>  Salt Lake City, UT 84112   </address>::line_number::4
<email>  E-mail: fmecklen,clark,gary,yihg@cs.utah.edu   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> We describe the design and implementation of a persistent object storage facility  </abstract>::line_number::7
<abstract> based on a dossier driven approach. Objects are characterized by dossiers which describe both their language defined and "extra-linguistic" properties. These dossiers are  </abstract>::line_number::8
<abstract> generated by a C++ preprocessor in concert with an augmented, but completely C++  </abstract>::line_number::9
<abstract> compatible, class description language. The design places very few burdens on the application programmer and can be used without altering the data member layout of application objects or inheriting from special classes. The storage format is kept simple to allow  </abstract>::line_number::10
<abstract> the use of a variety of data storage backends. In addition, these dossiers can be used to  </abstract>::line_number::11
<abstract> implement (or augment) a run-time typing facility compatible with the proposed ANSI  </abstract>::line_number::12
<abstract> C++ standard. Finally, by providing a generic object to byte stream conversion the persistent object facility can also be used in conjunction with an interprocess communication  </abstract>::line_number::13
<abstract> facility to provide object-level communication between processes. 1   </abstract>::line_number::14
<intro>  1 Motivation  </intro>::line_number::15

<title>  The Next Frontier: Interactive and Closed Loop Performance  </title>::line_number::0
<title> Steering    </title>::line_number::1
<author>  Daniel A. Reed Christopher L. Elford  </author>::line_number::2
<author> Tara M. Madhyastha Evgenia Smirni  </author>::line_number::3
<author> Stephen E. Lamm   </author>::line_number::4
<email>  freed,elford,tara,esmirni,slammg@cs.uiuc.edu   </email>::line_number::5
<affiliation>  Department of Computer Science  </affiliation>::line_number::6
<affiliation> University of Illinois   </affiliation>::line_number::7
<address>  Urbana, Illinois 61801   </address>::line_number::8
<abstract>  Abstract  </abstract>::line_number::9
<abstract> Software for a growing number of problem domains  </abstract>::line_number::10
<abstract> has complex, time varying behavior and unpredictable  </abstract>::line_number::11
<abstract> resource demands (e.g., WWW servers and parallel input/output systems). While current performance analysis tools provide insights into application dynamics  </abstract>::line_number::12
<abstract> and the causes of poor performance, with a posteriori analysis one cannot adapt to temporally varying  </abstract>::line_number::13
<abstract> application resource demands and system responses.  </abstract>::line_number::14
<abstract> We believe that the solution to this performance optimization conundrum is integration of dynamic performance instrumentation and on-the-fly performance  </abstract>::line_number::15
<abstract> data reduction with real-time adaptive control mechanisms that select and configure resource management  </abstract>::line_number::16
<abstract> algorithms automatically, based on observed application behavior, or interactively, through high-modality  </abstract>::line_number::17
<abstract> virtual environments. We motivate this belief by first  </abstract>::line_number::18
<abstract> describing our experiences with performance analysis tools, input/output characterization, and WWW  </abstract>::line_number::19
<abstract> server analysis, and then sketching the design of interactive and closed loop adaptive control systems.   </abstract>::line_number::20
<intro>  1 Introduction  </intro>::line_number::21

<title>  Compilation of Constraint Systems to  </title>::line_number::0
<title> Procedural Parallel Programs   </title>::line_number::1
<author>  Ajita John and J. C. Browne   </author>::line_number::2
<affiliation>  Dept. of Computer Sciences  </affiliation>::line_number::3
<address> University of Texas,   Austin, TX 78712   </address>::line_number::4
<email>  fajohn,browneg@cs.utexas.edu   </email>::line_number::5
<abstract>  Abstract. This paper describes the first results from research 1 on the  </abstract>::line_number::6
<abstract> compilation of constraint systems into task level parallel programs in a  </abstract>::line_number::7
<abstract> procedural language. This is the only research, of which we are aware,  </abstract>::line_number::8
<abstract> which attempts to generate efficient parallel programs for numerical  </abstract>::line_number::9
<abstract> computations from constraint systems. Computations are expressed as  </abstract>::line_number::10
<abstract> constraint systems. A dependence graph is derived from the constraint  </abstract>::line_number::11
<abstract> system and a set of input variables. The dependence graph, which exploits the parallelism in the constraints, is mapped to the target language CODE, which represents parallel computation structures as generalized dependence graphs. Finally, parallel C programs are generated.  </abstract>::line_number::12
<abstract> The granularity of the derived dependence graphs depends upon the  </abstract>::line_number::13
<abstract> complexity of the operations represented in the type system of the constraint specification language. To extract parallel programs of appropriate granularity, the following features have been included: (i) modularity, (ii) operations over structured types as primitives, (iii) definition  </abstract>::line_number::14
<abstract> of sequential C functions. A prototype of the compiler has been implemented. The execution environment or software architecture is specified  </abstract>::line_number::15
<abstract> separately from the constraint system. The domain of matrix computations has been targeted for applications. Some examples have been  </abstract>::line_number::16
<abstract> programmed. Initial results are very encouraging.   </abstract>::line_number::17
<intro>  1 Introduction  </intro>::line_number::18

<title>  Optimal Wire-Sizing Formula Under the Elmore Delay Model   </title>::line_number::0
<author>  Chung-Ping Chen, Yao-Ping Chen, and D. F. Wong   </author>::line_number::1
<affiliation>  Department of Computer Sciences, University of Texas,   Austin, Texas 78712   </affiliation>::line_number::2
<abstract>  Abstract  </abstract>::line_number::3
<abstract> In this paper, we consider non-uniform wire-sizing. Given a  </abstract>::line_number::4
<abstract> wire segment of length L, let f(x) be the width of the wire  </abstract>::line_number::5
<abstract> at position x, 0 x L. We show that the optimal wire-sizing function that minimizes the Elmore delay through the  </abstract>::line_number::6
<abstract> wire is f(x) = ae bx , where a &gt; 0 and b &gt; 0 are constants  </abstract>::line_number::7
<abstract> that can be computed in O(1) time. In the case where lower  </abstract>::line_number::8
<abstract> bound (L &gt; 0) and upper bound (U &gt; 0) on the wire widths  </abstract>::line_number::9
<abstract> are given, we show that the optimal wire-sizing function f(x)  </abstract>::line_number::10
<abstract> is a truncated version of ae bx that can also be determined in  </abstract>::line_number::11
<abstract> O(1) time. Our wire-sizing formula can be iteratively applied  </abstract>::line_number::12
<abstract> to optimally size the wire segments in a routing tree.   </abstract>::line_number::13
<intro>  1 Introduction  </intro>::line_number::14

<note>  In Proceedings of the Eighth International Workshop  </note>::line_number::0
<note> on Qualitative Physics about Physical Systems (QR-94)  </note>::line_number::1
<note> Nara, Japan, 1994.    </note>::line_number::2
<title>  Model Decomposition and Simulation   </title>::line_number::3
<author>  Daniel J. Clancy and Benjamin Kuipers   </author>::line_number::4
<affiliation>  Department of Computer Sciences  </affiliation>::line_number::5
<affiliation> University of Texas at Austin   </affiliation>::line_number::6
<address>  Austin, Texas 78712   </address>::line_number::7
<email>  clancy@cs.utexas.edu and kuipers@cs.utexas.edu   </email>::line_number::8
<abstract>  Abstract  </abstract>::line_number::9
<abstract> Qualitative reasoning uses incomplete knowledge to compute a description of the possible behaviors for dynamic  </abstract>::line_number::10
<abstract> systems. For complex systems containing a large number  </abstract>::line_number::11
<abstract> of variables and constraints, the simulation frequently is  </abstract>::line_number::12
<abstract> intractable or results in a large, incomprehensible behavioral description. Abstraction and aggregation techniques are required during the simulation to eliminate  </abstract>::line_number::13
<abstract> irrelevant details and highlight the important characteristics of the behavior. The total temporal ordering of  </abstract>::line_number::14
<abstract> unrelated events provided by a traditional state-based  </abstract>::line_number::15
<abstract> qualitative representation is one such irrelevant distinction. Model decomposition and simulation addresses this  </abstract>::line_number::16
<abstract> problem.  </abstract>::line_number::17
<abstract> Model decomposition uses a causal analysis of the model  </abstract>::line_number::18
<abstract> to partition the variables into tightly connected components. The components are simulated separately in  </abstract>::line_number::19
<abstract> the order dictated by the causal analysis beginning with  </abstract>::line_number::20
<abstract> causally upstream components. Information from the  </abstract>::line_number::21
<abstract> simulation of causally upstream components is used to  </abstract>::line_number::22
<abstract> constrain the behavior of downstream components. If a  </abstract>::line_number::23
<abstract> feedback loop exists between components or a set of components are acausally related, then a concurrent simulation is performed for these components. A truth maintenance system is used to record and retract assumptions  </abstract>::line_number::24
<abstract> made during this concurrent simulation.  </abstract>::line_number::25
<abstract> Model decomposition provides a general architecture  </abstract>::line_number::26
<abstract> which separates the method of simulation from the model  </abstract>::line_number::27
<abstract> decomposition algorithm. This architecture can be used  </abstract>::line_number::28
<abstract> to introduce alternative abstraction techniques to eliminate other irrelevant distinctions.   </abstract>::line_number::29
<intro>  1 Introduction  </intro>::line_number::30

<title>  Programming the Web:  </title>::line_number::0
<title> An Application-oriented Language for Hypermedia Services   </title>::line_number::1
<author>  David A. Ladd J. Christopher Ramming   </author>::line_number::2
<email>  ladd@research.att.com jcr@research.att.com   </email>::line_number::3
<affiliation>  AT&T Bell Laboratories   </affiliation>::line_number::4
<date>  October 9, 1995   </date>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> MAWL is an application language for programming interactive services in the context of the Worldwide  </abstract>::line_number::7
<abstract> Web. The language is small, because no construct was introduced without compelling justification; as with  </abstract>::line_number::8
<abstract> yacc [8], general-purpose computation is done in a host language. MAWL offers conveniences such as control  </abstract>::line_number::9
<abstract> abstraction, persistent state management, synchronization, and shared memory. In addition, the MAWL  </abstract>::line_number::10
<abstract> compiler performs static checking designed to prevent common Web programming errors. In this paper we  </abstract>::line_number::11
<abstract> discuss the design and engineering of MAWL.  </abstract>::line_number::12
<abstract> We describe the problems MAWL is intended to solve, and then discuss our design choices in the context  </abstract>::line_number::13
<abstract> of our general language design philosophy, We also include an appendix of commentary on several short  </abstract>::line_number::14
<abstract> MAWL programs.   </abstract>::line_number::15
<intro>  1 Introduction  </intro>::line_number::16

<title>  Stability and Chaos in an Inertial Two  </title>::line_number::0
<title> Neuron System   </title>::line_number::1
<author>  Diek W. Wheeler 1 and W. C. Schieve   </author>::line_number::2
<affiliation>  Ilya Prigogine Center for Studies in Statistical Mechanics and  </affiliation>::line_number::3
<affiliation> Complex Systems  </affiliation>::line_number::4
<affiliation> and  </affiliation>::line_number::5
<affiliation> Physics Department, The University of Texas,   </affiliation>::line_number::6
<address>  Austin, TX 78712   </address>::line_number::7
<abstract>  Abstract.  </abstract>::line_number::8
<abstract> Inertia is added to a continuous-time, Hopfield [1] effective-neuron system.  </abstract>::line_number::9
<abstract> We explore the effects on the stability of the fixed points of the system. A two  </abstract>::line_number::10
<abstract> neuron system with one or two inertial terms added is shown to exhibit chaos.  </abstract>::line_number::11
<abstract> The chaos is confirmed by Lyapunov exponents, power spectra, and phase space  </abstract>::line_number::12
<abstract> plots.   </abstract>::line_number::13
<intro>  INTRODUCTION  </intro>::line_number::14

<title>  ON UNAPPROXIMABLE VERSIONS OF NP-COMPLETE  </title>::line_number::0
<title> PROBLEMS    </title>::line_number::1
<author>  DAVID ZUCKERMAN    </author>::line_number::2
<abstract>  Abstract.  </abstract>::line_number::3
<abstract> We prove that all of Karp's 21 original NP -complete problems have a version that's hard to  </abstract>::line_number::4
<abstract> approximate. These versions are obtained from the original problems by adding essentially the same,  </abstract>::line_number::5
<abstract> simple constraint. We further show that these problems are absurdly hard to approximate. In fact, no  </abstract>::line_number::6
<abstract> polynomial-time algorithm can even approximate log (k) of the magnitude of these problems to within  </abstract>::line_number::7
<abstract> any constant factor, where log (k) denotes the logarithm iterated k times, unless N P is recognized by  </abstract>::line_number::8
<abstract> slightly superpolynomial randomized machines. We use the same technique to improve the constant  </abstract>::line_number::9
<abstract> * such that MAX CLIQUE is hard to approximate to within a factor of n * . Finally, we show that it  </abstract>::line_number::10
<abstract> is even harder to approximate two counting problems: counting the number of satisfying assignments  </abstract>::line_number::11
<abstract> to a monotone 2-SAT formula and computing the permanent of -1,0,1 matrices.   </abstract>::line_number::12
<keyword>  Key words. NP-complete, unapproximable, randomized reduction, clique, counting problems,  </keyword>::line_number::13
<keyword> permanent, 2SAT   </keyword>::line_number::14
<note>  AMS subject classifications. 68Q15, 68Q25, 68Q99   </note>::line_number::15
<intro>  1. Introduction.  </intro>::line_number::16

<title>  Recursive Functions of Symbolic  </title>::line_number::0
<title> Expressions and Their Computation by  </title>::line_number::1
<title> Machine, Part I   </title>::line_number::2
<author>  John McCarthy,   Massachusetts Institute of Technology,   Cambridge, Mass.    </author>::line_number::3
<date>  April 1960   </date>::line_number::4
<intro>  1 Introduction  </intro>::line_number::5

<title>  Frangipani: A Scalable Distributed File System   </title>::line_number::0
<author>  Chandramohan A. Thekkath  </author>::line_number::1
<author> Timothy Mann  </author>::line_number::2
<author> Edward K. Lee   </author>::line_number::3
<affiliation>  Systems Research Center  </affiliation>::line_number::4
<affiliation> Digital Equipment Corporation   </affiliation>::line_number::5
<address>  130 Lytton Ave, Palo Alto, CA 94301   </address>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> The ideal distributed file system would provide all its users with coherent, shared access to the same set of files,yet would be arbitrarily  </abstract>::line_number::8
<abstract> scalable to provide more storage space and higher performance to  </abstract>::line_number::9
<abstract> a growing user community. It would be highly available in spite of  </abstract>::line_number::10
<abstract> component failures. It would require minimal human administration, and administration would not become more complex as more  </abstract>::line_number::11
<abstract> components were added.  </abstract>::line_number::12
<abstract> Frangipani is a new file system that approximates this ideal, yet  </abstract>::line_number::13
<abstract> was relatively easy to build because of its two-layer structure. The  </abstract>::line_number::14
<abstract> lower layer is Petal (described in an earlier paper), a distributed  </abstract>::line_number::15
<abstract> storage service that provides incrementally scalable, highly available, automatically managed virtual disks. In the upper layer,  </abstract>::line_number::16
<abstract> multiple machines run the same Frangipani file system code on top  </abstract>::line_number::17
<abstract> of a shared Petal virtual disk, using a distributed lock service to  </abstract>::line_number::18
<abstract> ensure coherence.  </abstract>::line_number::19
<abstract> Frangipani is meant to run in a cluster of machines that are under  </abstract>::line_number::20
<abstract> a common administration and can communicate securely. Thus the  </abstract>::line_number::21
<abstract> machines trust one another and the shared virtual disk approach is  </abstract>::line_number::22
<abstract> practical. Of course, a Frangipani file system can be exported to  </abstract>::line_number::23
<abstract> untrusted machines using ordinary network file access protocols.  </abstract>::line_number::24
<abstract> We have implemented Frangipani on a collection of Alphas  </abstract>::line_number::25
<abstract> running DIGITAL Unix 4.0. Initial measurements indicate that  </abstract>::line_number::26
<abstract> Frangipani has excellent single-server performance and scales well  </abstract>::line_number::27
<abstract> as servers are added.   </abstract>::line_number::28
<intro>  1 Introduction  </intro>::line_number::29

<title>  The Cost of Recovery in Message Logging Protocols   </title>::line_number::0
<author>  Sriram Rao, Lorenzo Alvisi, and Harrick M. Vin   </author>::line_number::1
<affiliation>  Department of Computer Sciences  </affiliation>::line_number::2
<affiliation> The University of Texas at Austin   </affiliation>::line_number::3
<address>  Taylor Hall 2.124, Austin, Texas 78712-1188, USA   </address>::line_number::4
<email>  E-mail: fsriram,lorenzo,ving@cs.utexas.edu,   Telephone: (512) 471-9792, Fax: (512) 471-8885   </email>::line_number::5
<web>  URL: http://www.cs.utexas.edu/users/fsriram,lorenzo,ving   </web>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> Message logging is a popular technique for building low-overhead protocols that tolerate  </abstract>::line_number::8
<abstract> process crash failures. Past research in message logging has focused on studying the relative  </abstract>::line_number::9
<abstract> overhead imposed by pessimistic, optimistic, and causal protocols during failure-free executions. In this paper, we give the first experimental evaluation of the performance of these  </abstract>::line_number::10
<abstract> protocols during recovery. We discover that, if a single failure is to be tolerated, pessimistic  </abstract>::line_number::11
<abstract> and causal protocols perform best, because they avoid rollbacks of correct processes. For  </abstract>::line_number::12
<abstract> multiple failures, however, the dominant factor in determining performance becomes where  </abstract>::line_number::13
<abstract> the recovery information is logged (i.e. at the sender, at the receiver, or replicated at a  </abstract>::line_number::14
<abstract> subset of the processes in the system) rather than when this information is logged (i.e. if  </abstract>::line_number::15
<abstract> logging is synchronous or asynchronous). From our results, we distil a few lessons that can  </abstract>::line_number::16
<abstract> guide the design of message-logging protocols that combine low-overhead during failure-free  </abstract>::line_number::17
<abstract> executions with fast recovery.   </abstract>::line_number::18
<intro>  1 Introduction  </intro>::line_number::19

<title>  Constructing Scripts from Components:  </title>::line_number::0
<title> Working Note 6   </title>::line_number::1
<author>  Peter Clark and Bruce Porter   </author>::line_number::2
<affiliation>  Dept. CS, UT Austin   </affiliation>::line_number::3
<email>  fpclark,porterg@cs.utexas.edu   </email>::line_number::4
<intro>  1 Introduction  </intro>::line_number::5

<title>  Design Goals for ACL2   </title>::line_number::0
<author>  Matt Kaufmann and J Strother Moore   </author>::line_number::1
<pubnum>  Technical Report 101   August, 1994   </pubnum>::line_number::2
<affiliation>  Computational Logic, Inc.   </affiliation>::line_number::3
<address>  1717 West Sixth Street, Suite 290  </address>::line_number::4
<address> Austin, Texas 78703-4776   </address>::line_number::5
<phone>  TEL: +1 512 322 9951   </phone>::line_number::6
<email>  EMAIL: kaufmann@cli.com and moore@cli.com   </email>::line_number::7
<note>  This work was supported in part at Computational Logic, Inc., by the Defense  </note>::line_number::8
<note> Advanced Research Projects Agency, ARPA Order 7406. The views and conclusions contained in this document are those of the author(s) and should not  </note>::line_number::9
<note> be interpreted as representing the official policies, either expressed or implied,  </note>::line_number::10
<note> of Computational Logic, Inc., the Defense Advanced Research Projects Agency  </note>::line_number::11
<note> or the U.S. Government.   </note>::line_number::12
<page>  +PAGE+  </page>::line_number::13

<title>  Broadcasting on Meshes with Worm-Hole Routing   </title>::line_number::0
<author>  Michael Barnett   </author>::line_number::1
<affiliation>  Department of Computer Science  </affiliation>::line_number::2
<affiliation> University of Idaho   </affiliation>::line_number::3
<address>  Moscow, Idaho 83844-1010   </address>::line_number::4
<email>  mbarnett@cs.uidaho.edu   </email>::line_number::5
<author>  David G. Payne   </author>::line_number::6
<affiliation>  Supercomputer Systems Division  </affiliation>::line_number::7
<affiliation> Intel Corporation   </affiliation>::line_number::8
<address>  15201 N.W. Greenbrier Pkwy  </address>::line_number::9
<address> Beaverton, Oregon 97006   </address>::line_number::10
<email>  payne@ssd.intel.com   </email>::line_number::11
<author>  Robert A. van de Geijn   </author>::line_number::12
<affiliation>  Department of Computer Sciences  </affiliation>::line_number::13
<affiliation> The University of Texas at Austin   </affiliation>::line_number::14
<address>  Austin, Texas 78712-1188   </address>::line_number::15
<email>  rvdg@cs.utexas.edu   </email>::line_number::16
<author>  Jerrell Watts   </author>::line_number::17
<affiliation>  Scalable Concurrent Programming Laboratory  </affiliation>::line_number::18
<affiliation> California Institute of Technology   </affiliation>::line_number::19
<address>  Pasadena, California 91125   </address>::line_number::20
<email>  jwatts@scp.caltech.edu   </email>::line_number::21
<note>  Original Version: November 2, 1993  </note>::line_number::22
<note> Revised Version: September 21, 1994   </note>::line_number::23
<abstract>  Abstract  </abstract>::line_number::24
<abstract> We address the problem of broadcasting on mesh architectures with arbitrary (non-power-two) dimensions. It is assumed that such mesh architectures employ cut-through or worm-hole routing. The  </abstract>::line_number::25
<abstract> primary focus is on avoiding network conflicts in the various proposed algorithms. We give algorithms  </abstract>::line_number::26
<abstract> for performing a conflict-free minimum-spanning tree broadcast, a pipelined algorithm that is similar to  </abstract>::line_number::27
<abstract> Ho and Johnsson's EDST algorithm for hypercubes, and a novel scatter-collect approach that is a natural  </abstract>::line_number::28
<abstract> choice for communication libraries due to its simplicity. Results obtained on the Intel Paragon system  </abstract>::line_number::29
<abstract> are included.   </abstract>::line_number::30
<intro>  1 Introduction  </intro>::line_number::31

<title>  Towards Usable and Lean  </title>::line_number::0
<title> Parallel Linear Algebra Libraries    </title>::line_number::1
<author>  Almadena Chtchelkanova Carter Edwards  </author>::line_number::2
<author> John Gunnels Greg Morrow  </author>::line_number::3
<author> James Overfelt Robert van de Geijn    </author>::line_number::4
<affiliation>  Department of Computer Sciences  </affiliation>::line_number::5
<affiliation> and  </affiliation>::line_number::6
<affiliation> Texas Institute for Computational and Applied Mathematics  </affiliation>::line_number::7
<affiliation> The University of Texas at Austin   </affiliation>::line_number::8
<address>  Austin, Texas 78712   </address>::line_number::9
<date>  May 1, 1996   </date>::line_number::10
<abstract>  Abstract  </abstract>::line_number::11
<abstract> In this paper, we introduce a new parallel library effort, as part of the PLAPACK  </abstract>::line_number::12
<abstract> project, that attempts to address discrepencies between the needs of applications and  </abstract>::line_number::13
<abstract> parallel libraries. A number of contributions are made, including a new approach  </abstract>::line_number::14
<abstract> to matrix distribution, new insights into layering parallel linear algebra libraries, and  </abstract>::line_number::15
<abstract> the application of "object based" programming techniques which have recently become  </abstract>::line_number::16
<abstract> popular for (parallel) scientific libraries. We present an overview of a prototype library,  </abstract>::line_number::17
<abstract> the SL Library, which incorporates these ideas. Preliminary performance data shows  </abstract>::line_number::18
<abstract> this more application-centric approach to libraries does not necessarily adversely impact  </abstract>::line_number::19
<abstract> performance, compared to more traditional approaches.   </abstract>::line_number::20
<note>  This project is sponsored in part by the Office of Naval Research under Contract N00014-95-1-0401,  </note>::line_number::21
<note> the NASA High Performance Computing and Communications Program's Earth and Space Sciences Project  </note>::line_number::22
<note> under NRA Grant NAG5-2497, the PRISM project under ARPA grant P-95006.  </note>::line_number::23
<affiliation> Corresponding and presenting author.   Dept. of Computer Sciences, The University of Texas at Austin,   </affiliation>::line_number::24
<address>  Austin, TX 78712,  ( 512) 471-9720 (Office), (512) 471-8885 (Fax),   rvdg@cs.utexas.edu.   </address>::line_number::25
<page>  +PAGE+  </page>::line_number::26

<title>  Anatomy of a Parallel Out-of-Core Dense Linear Solver   </title>::line_number::0
<author>  Kenneth Klimkowski   </author>::line_number::1
<affiliation>  Texas Institute for Computational  </affiliation>::line_number::2
<affiliation> and Applied Mathematics  </affiliation>::line_number::3
<affiliation> The University of Texas at Austin   </affiliation>::line_number::4
<address>  Austin, Texas 78712   </address>::line_number::5
<email>  ken@ticam.utexas.edu   </email>::line_number::6
<author>  Robert A. van de Geijn   </author>::line_number::7
<affiliation>  Department of Computer Sciences  </affiliation>::line_number::8
<affiliation> The University of Texas at Austin   </affiliation>::line_number::9
<address>  Austin, Texas 78712   </address>::line_number::10
<email>  rvdg@cs.utexas.edu   </email>::line_number::11
<abstract>  Abstract In this paper, we describe the design  </abstract>::line_number::12
<abstract> and implementation of the Platform Independent  </abstract>::line_number::13
<abstract> Parallel Solver (PIPSolver) package for the out-of-core (OOC) solution of complex dense linear systems. Our approach is unique in that it allows essentially all of RAM to be filled with the current  </abstract>::line_number::14
<abstract> portion of the matrix (slab) to be updated and factored, thereby greatly improving the computation to  </abstract>::line_number::15
<abstract> I/O ratio over previous approaches. Experiences  </abstract>::line_number::16
<abstract> and performance are reported for the Cray T3D  </abstract>::line_number::17
<abstract> system.   </abstract>::line_number::18
<intro>  INTRODUCTION  </intro>::line_number::19

<title>  Automated Proof Support for  </title>::line_number::0
<title> Reasoning about Distributed Mobile  </title>::line_number::1
<title> Programs   </title>::line_number::2
<degree>  A thesis  </degree>::line_number::3
<degree> submitted in partial fulfilment  </degree>::line_number::4
<degree> of the requirements for  </degree>::line_number::5
<degree> the degree  </degree>::line_number::6
<degree> of  </degree>::line_number::7
<degree> Bachelor of Technology  </degree>::line_number::8
<degree> in  </degree>::line_number::9
<degree> Computer Science and Engineering   </degree>::line_number::10
<author>  by  </author>::line_number::11
<author> B Karthikeyan  </author>::line_number::12
<author> T R Vishwanath   </author>::line_number::13
<degree>  under the guidance of  </degree>::line_number::14
<degree> Dr Sanjiva Prasad   </degree>::line_number::15
<affiliation>  Department of Computer Science & Engineering  </affiliation>::line_number::16
<affiliation> Indian Institute of Technology, Delhi   </affiliation>::line_number::17
<date>  May 1997   </date>::line_number::18
<page>  +PAGE+  </page>::line_number::19

<title>  NetSolve: A Network Server  </title>::line_number::0
<title> for Solving Computational Science Problems   </title>::line_number::1
<author>  Henri Casanova   </author>::line_number::2
<affiliation>  University of Tennessee  </affiliation>::line_number::3
<address> UTK, Dept. of Computer Science   104, Ayres Hall. KNOXVILLE, TN 37996-1301.   </address>::line_number::4
<email>  casanova@cs.utk.edu   </email>::line_number::5
<web>  http://www.cs.utk.edu/~casanova   </web>::line_number::6
<author>  Jack Dongarra   </author>::line_number::7
<affiliation>  University of Tennessee,  Oak Ridge National Laboratory  </affiliation>::line_number::8
<address> UTK, Dept. of Computer Science   104, Ayres Hall. KNOXVILLE, TN 37996-1301.   </address>::line_number::9
<email>  dongarra@cs.utk.edu   </email>::line_number::10
<web>  http://www.netlib.org/utk/people/JackDongarra.html   </web>::line_number::11
<date>  November 12, 1996   </date>::line_number::12
<abstract>  Abstract  </abstract>::line_number::13
<abstract> This paper presents a new system, called NetSolve, that allows users to access computational resources, such as hardware and software, distributed across the network. The development of NetSolve  </abstract>::line_number::14
<abstract> was motivated by the need for an easy-to-use, efficient mechanism for using computational resources remotely. Ease of use is obtained as a result of different interfaces, some of which require no programming  </abstract>::line_number::15
<abstract> effort from the user. Good performance is ensured by a load-balancing policy that enables NetSolve to  </abstract>::line_number::16
<abstract> use the computational resources available as efficiently as possible. NetSolve offers the ability to look  </abstract>::line_number::17
<abstract> for computational resources on a network, choose the best one available, solve a problem (with retry for  </abstract>::line_number::18
<abstract> fault-tolerance), and return the answer to the user.   </abstract>::line_number::19
<keyword>  Keywords  </keyword>::line_number::20
<keyword> Networking, Heterogeneity, Load Balancing,  </keyword>::line_number::21
<keyword> Client-Server, Fault Tolerance, Numerical Computing, Virtual Library.   </keyword>::line_number::22
<page>  +PAGE+  </page>::line_number::23

<title>  What robots can do:  </title>::line_number::0
<title> Robot programs and effective achievability   </title>::line_number::1
<author>  Fangzhen Lin   </author>::line_number::2
<affiliation>  Department of Computer Science  </affiliation>::line_number::3
<affiliation> The Hong Kong University of Science and Technology   </affiliation>::line_number::4
<address>  Clear Water Bay, Hong Kong   </address>::line_number::5
<email>  flin@cs.ust.hk   </email>::line_number::6
<author>  Hector Levesque   </author>::line_number::7
<affiliation>  Department of Computer Science  </affiliation>::line_number::8
<affiliation> University of Toronto   </affiliation>::line_number::9
<address>  Toronto, Canada M5S 3H5   </address>::line_number::10
<email>  hector@ai.toronto.edu  </email>::line_number::11
<email>  </email>::line_number::12
<date>  May 15, 1997   </date>::line_number::13
<abstract>  Abstract  </abstract>::line_number::14
<abstract> In this paper, we propose a definition of goal achievability: given a basic action theory describing an initial state of the world and some primitive actions available to a  </abstract>::line_number::15
<abstract> robot, including some actions which return binary sensing information, what goals can  </abstract>::line_number::16
<abstract> be achieved by the robot? The main technical result of the paper is a proof that a simple  </abstract>::line_number::17
<abstract> robot programming language is universal, in that any effectively achievable goal can be  </abstract>::line_number::18
<abstract> achieved by getting the robot to execute one of the robot programs. The significance of  </abstract>::line_number::19
<abstract> this result is at least two fold. First, it is in many ways similar to the equivalence theorem between Turing machines and recursive functions, but applied to robots whose  </abstract>::line_number::20
<abstract> actions are specified by an action theory. Secondly, it provides formal justifications for  </abstract>::line_number::21
<abstract> using the simple robot programming language as a foundation for our work on robotics.   </abstract>::line_number::22
<page>  +PAGE+  </page>::line_number::23

<title>  An Ordering on Subgoals for Planning   </title>::line_number::0
<author>  Fangzhen Lin   </author>::line_number::1
<affiliation> D epartment of Computer Science  </affiliation>::line_number::2
<affiliation> The Hong Kong University of Science and Technology   </affiliation>::line_number::3
<address>  Clear Water Bay, Kowloon, Hong Kong   </address>::line_number::4
<email>  @cs.ust.hk   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Subgoal ordering is a type of control information that has received much attention  </abstract>::line_number::7
<abstract> in AI planning community. In this paper we formulate precisely a subgoal ordering  </abstract>::line_number::8
<abstract> in the situation calculus. We show how information about this subgoal ordering can  </abstract>::line_number::9
<abstract> be deduced from the background action theory. We also show for both linear and  </abstract>::line_number::10
<abstract> nonlinear planners how knowledge about this ordering can be used in a provably  </abstract>::line_number::11
<abstract> correct way to avoid unnecessary backtracking.   </abstract>::line_number::12
<intro>  1 Introduction </intro>::line_number::13
<intro>  </intro>::line_number::14

<title>  How to Progress a Database (and Why)  </title>::line_number::0
<title> I. Logical Foundations   </title>::line_number::1
<author>  Fangzhen Lin and Ray Reiter    </author>::line_number::2
<affiliation>  Department of Computer Science  </affiliation>::line_number::3
<affiliation> University of Toronto   </affiliation>::line_number::4
<address>  Toronto, Canada M5S 1A4   </address>::line_number::5
<email>  email: @ai.toronto.edu reiter@ai.toronto.edu   </email>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> One way to think about STRIPS is as a mapping from databases to databases, in the following sense: Suppose we want to know what  </abstract>::line_number::8
<abstract> the world would be like if an action, represented by the STRIPS operator ff, were done  </abstract>::line_number::9
<abstract> in some world, represented by the STRIPS  </abstract>::line_number::10
<abstract> database D 0 . To find out, simply perform  </abstract>::line_number::11
<abstract> the operator ff on D 0 (by applying ff's elementary add and delete revision operators to  </abstract>::line_number::12
<abstract> D 0 ). We describe this process as progressing  </abstract>::line_number::13
<abstract> the database D 0 in response to the action ff.  </abstract>::line_number::14
<abstract> In this paper, we consider the general problem of progressing an initial database in response to a given sequence of actions. We  </abstract>::line_number::15
<abstract> appeal to the situation calculus and an axiomatization of actions which addresses the  </abstract>::line_number::16
<abstract> frame problem (Reiter [13], Lin and Reiter  </abstract>::line_number::17
<abstract> [8]). This setting is considerably more general than STRIPS. Our results concerning  </abstract>::line_number::18
<abstract> progression are mixed. The (surprising) bad  </abstract>::line_number::19
<abstract> news is that, in general, to characterize a progressed database we must appeal to second  </abstract>::line_number::20
<abstract> order logic. The good news is that there are  </abstract>::line_number::21
<abstract> many useful special cases for which we can  </abstract>::line_number::22
<abstract> compute the progressed database in first order logic; not only that, we can do so efficiently.   </abstract>::line_number::23
<intro>  1 INTRODUCTION  </intro>::line_number::24

<title>  Specifying Instructions' Semantics Using CSDL  </title>::line_number::0
<title> (Preliminary Report)   </title>::line_number::1
<author>  Norman Ramsey and Jack W. Davidson   </author>::line_number::2
<affiliation>  Department of Computer Science  </affiliation>::line_number::3
<affiliation> University of Virginia   </affiliation>::line_number::4
<address>  Charlottesville, VA 22903   </address>::line_number::5
<date>  June 10, 1998   </date>::line_number::6
<page>  +PAGE+  </page>::line_number::7

<title>  Approaching the 5/4-Approximation  </title>::line_number::0
<title> for Rectilinear Steiner Trees    </title>::line_number::1
<author>  Piotr Berman Ulrich Fomeier Marek Karpinski  </author>::line_number::2
<author> Michael Kaufmann Alexander Zelikovsky   </author>::line_number::3
<date>  September 29, 1995   </date>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> The rectilinear Steiner tree problem requires a shortest tree spanning a given vertex subset  </abstract>::line_number::6
<abstract> in the plane with rectilinear distance. It was proved that the output length of Zelikovsky's [25]  </abstract>::line_number::7
<abstract> and Berman/Ramaiyer [3] heuristics is at most 1.375 and 97  </abstract>::line_number::8
<abstract> 72 1:347 of the optimal length,  </abstract>::line_number::9
<abstract> respectively. It was claimed that these bounds are not tight. Here we improve these bounds to  </abstract>::line_number::10
<abstract> 1.3125 and 61  </abstract>::line_number::11
<abstract> 48 1:271, respectively, and give efficient algorithms to find approximations of such  </abstract>::line_number::12
<abstract> quality. We also prove that for Zelikovsky's heuristic this bound cannot be less than 1.3.   </abstract>::line_number::13
<keyword>  Keywords: Algorithms, approximations, Steiner tree   </keyword>::line_number::14
<intro>  1 Introduction  </intro>::line_number::15

<title>  A Distributed Protocol for Channel-Based  </title>::line_number::0
<title> Communication with Choice   </title>::line_number::1
<author>  Frederick Knabe   </author>::line_number::2
<affiliation>  European Computer-Industry Research Centre GmbH   </affiliation>::line_number::3
<address>  Munich, Germany   </address>::line_number::4
<email>  knabe@ecrc.de   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Recent attempts at incorporating concurrency into functional languages have  </abstract>::line_number::7
<abstract> identified synchronous communication via shared channels as a promising primitive. An additional useful feature found in many proposals is a nondeterministic  </abstract>::line_number::8
<abstract> choice operator. Similar in nature to the CSP alternative command, this operator  </abstract>::line_number::9
<abstract> allows different possible actions to be guarded by sends or receives. Choice is  </abstract>::line_number::10
<abstract> difficult to implement in a distributed environment because it requires offering  </abstract>::line_number::11
<abstract> many potential communications but closing only one. In this paper we present  </abstract>::line_number::12
<abstract> the first distributed, deadlock-free algorithm for choice.   </abstract>::line_number::13
<keyword>  Keywords: Distributed protocols, channels, synchronous communication,  </keyword>::line_number::14
<keyword> choice operator, CSP alternative command.   </keyword>::line_number::15
<intro>  1. Introduction  </intro>::line_number::16

<note>  Reprinted from 1995 Usenix Technical Conference * January 16-20, 1995 * New Orleans, LA   </note>::line_number::0
<title>  The New Jersey Machine-Code Toolkit   </title>::line_number::1
<author>  Norman Ramsey   </author>::line_number::2
<affiliation>  Bell Communications Research   </affiliation>::line_number::3
<author>  Mary F. Fernandez   </author>::line_number::4
<affiliation>  Department of Computer Science, Princeton University   </affiliation>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> The New Jersey Machine-Code Toolkit helps programmers write applications that process machine code.  </abstract>::line_number::7
<abstract> Applications that use the toolkit are written at an  </abstract>::line_number::8
<abstract> assembly-language level of abstraction, but they recognize and emit binary. Guided by a short instruction-set specification, the toolkit generates all the bit-manipulating code.  </abstract>::line_number::9
<abstract> The toolkit's specification language uses four concepts: fields and tokens describe parts of instructions,  </abstract>::line_number::10
<abstract> patterns describe binary encodings of instructions or  </abstract>::line_number::11
<abstract> groups of instructions, and constructors map between  </abstract>::line_number::12
<abstract> the assembly-language and binary levels. These concepts are suitable for describing both CISC and RISC  </abstract>::line_number::13
<abstract> machines; we have written specifications for the MIPS  </abstract>::line_number::14
<abstract> R3000, SPARC, and Intel 486 instruction sets.  </abstract>::line_number::15
<abstract> We have used the toolkit to help write two applications: a debugger and a linker. The toolkit generates  </abstract>::line_number::16
<abstract> efficient code; for example, the linker emits binary up  </abstract>::line_number::17
<abstract> to 15% faster than it emits assembly language, making  </abstract>::line_number::18
<abstract> it 1.7-2 times faster to produce an a.out directly than  </abstract>::line_number::19
<abstract> by using the assembler.   </abstract>::line_number::20
<intro>  1 Introduction  </intro>::line_number::21

