<title>  Non-Tree Routing   </title>::line_number::0
<author>  Bernard A. McCoy and Gabriel Robins   </author>::line_number::1
<affiliation>  Department of Computer Science, University of Virginia,   Charlottesville, VA 22903-2442   </affiliation>::line_number::2
<note>  Appeared in: IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems,  </note>::line_number::3
<note> Vol. 14, No. 6, June 1995, pp. 780-784.   </note>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> An implicit premise of existing routing methods is that the routing topology must correspond to a  </abstract>::line_number::6
<abstract> tree (i.e., it does not contain cycles). In this paper we investigate the consequences of abandoning this  </abstract>::line_number::7
<abstract> basic axiom, and instead we allow routing topologies that correspond to arbitrary graphs (i.e., where  </abstract>::line_number::8
<abstract> cycles are allowed). We show that non-tree routing can significantly improve signal propagation delay,  </abstract>::line_number::9
<abstract> reduce signal skew, and afford increased reliability with respect to open faults that may be caused by  </abstract>::line_number::10
<abstract> manufacturing defects and electro-migration. Simulations on uniformly-distributed nets indicate that  </abstract>::line_number::11
<abstract> depending on net size and technology parameters, our non-tree routing construction reduces maximum  </abstract>::line_number::12
<abstract> sourse-sink SPICE delay by an average of up to 62%, and reduces signal skew by an average of up to  </abstract>::line_number::13
<abstract> 63%, as compared with Steiner routing. Moreover, up to 77% of the total wirelength in non-trees can  </abstract>::line_number::14
<abstract> tolerate an open fault without disconnecting the circuit.   </abstract>::line_number::15
<intro>  1 Introduction  </intro>::line_number::16

<title>  Scheduling and Page Migration for Multiprocessor Compute Servers   </title>::line_number::0
<author>  Rohit Chandra, Scott Devine, Ben Verghese,  </author>::line_number::1
<author> Anoop Gupta, and Mendel Rosenblum   </author>::line_number::2
<affiliation>  Computer Systems Laboratory  </affiliation>::line_number::3
<address> Stanford University,   Stanford CA 94305   </address>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> Several cache-coherent shared-memory multiprocessors have been  </abstract>::line_number::6
<abstract> developed that are scalable and offer a very tight coupling between  </abstract>::line_number::7
<abstract> the processing resources. They are therefore quite attractive for  </abstract>::line_number::8
<abstract> use as compute servers for multiprogramming and parallel application workloads. Process scheduling and memory management,  </abstract>::line_number::9
<abstract> however, remain challenging due to the distributed main memory found on such machines. This paper examines the effects of  </abstract>::line_number::10
<abstract> OS scheduling and page migration policies on the performance  </abstract>::line_number::11
<abstract> of such compute servers. Our experiments are done on the Stan-ford DASH, a distributed-memory cache-coherent multiprocessor.  </abstract>::line_number::12
<abstract> We show that for our multiprogramming workloads consisting of  </abstract>::line_number::13
<abstract> sequential jobs, the traditional Unix scheduling policy does very  </abstract>::line_number::14
<abstract> poorly. In contrast, a policy incorporating cluster and cache affinity along with a simple page-migration algorithm offers up to twofold performance improvement. For our workloads consisting of  </abstract>::line_number::15
<abstract> multiple parallel applications, we compare space-sharing policies  </abstract>::line_number::16
<abstract> that divide the processors among the applications to time-slicing  </abstract>::line_number::17
<abstract> policies such as standard Unix or gang scheduling. We show  </abstract>::line_number::18
<abstract> that space-sharing policies can achieve better processor utilization  </abstract>::line_number::19
<abstract> due to the operating point effect, but time-slicing policies benefit  </abstract>::line_number::20
<abstract> strongly from user-level data distribution. Our initial experience  </abstract>::line_number::21
<abstract> with automatic page migration suggests that policies based only  </abstract>::line_number::22
<abstract> on TLB miss information can be quite effective, and useful for  </abstract>::line_number::23
<abstract> addressing the data distribution problems of space-sharing sched-ulers.   </abstract>::line_number::24
<intro>  1 Introduction  </intro>::line_number::25

<title>  Using Runtime Measured Workload Characteristics in  </title>::line_number::0
<title> Parallel Processor Scheduling   </title>::line_number::1
<author>  Thu D. Nguyen, Raj Vaswani, and John Zahorjan   </author>::line_number::2
<affiliation>  Department of Computer Science and Engineering,   Box 352350   </affiliation>::line_number::3
<affiliation>  University of Washington   </affiliation>::line_number::4
<address>  Seattle, WA 98195-2350 USA   </address>::line_number::5
<pubnum>  Technical Report UW-CSE-95-10-01   </pubnum>::line_number::6
<date>  October 15, 1995   </date>::line_number::7
<page>  +PAGE+  </page>::line_number::8

<title>  Semantic Query Optimization in Datalog Programs   </title>::line_number::0
<note>  (Extended Abstract)   </note>::line_number::1
<author>  Alon Y. Levy   </author>::line_number::2
<affiliation>  AT&T Bell Laboratories   </affiliation>::line_number::3
<email>  levy@research.att.com   </email>::line_number::4
<author>  Yehoshua Sagiv    </author>::line_number::5
<affiliation>  Hebrew University, Jerusalem   </affiliation>::line_number::6
<email>  sagiv@cs.huji.ac.il   </email>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> Semantic query optimization refers to the process of using  </abstract>::line_number::9
<abstract> integrity constraints (ic's) in order to optimize the evaluation  </abstract>::line_number::10
<abstract> of queries. The process is well understood in the case  </abstract>::line_number::11
<abstract> of unions of select-project-join queries (i.e., nonrecursive  </abstract>::line_number::12
<abstract> datalog). For arbitrary datalog programs, however, the  </abstract>::line_number::13
<abstract> issue has largely remained an unsolved problem. This  </abstract>::line_number::14
<abstract> paper studies this problem and shows when semantic query  </abstract>::line_number::15
<abstract> optimization can be completely done in recursive rules  </abstract>::line_number::16
<abstract> provided that order constraints and negated EDB subgoals  </abstract>::line_number::17
<abstract> appear only in the recursive rules, but not in the ic's.  </abstract>::line_number::18
<abstract> If either order constraints or negated EDB subgoals are  </abstract>::line_number::19
<abstract> introduced in ic's, then the problem of semantic query  </abstract>::line_number::20
<abstract> optimization becomes undecidable. Since semantic query  </abstract>::line_number::21
<abstract> optimization is closely related to the containment problem  </abstract>::line_number::22
<abstract> of a datalog program in a union of conjunctive queries, our  </abstract>::line_number::23
<abstract> results also imply new decidability and undecidability results  </abstract>::line_number::24
<abstract> for that problem when order constraints and negated EDB  </abstract>::line_number::25
<abstract> subgoals are used.   </abstract>::line_number::26
<intro>  1 Introduction  </intro>::line_number::27

<title>  PCp  </title>::line_number::0
<title> 3 : A C Front End for  </title>::line_number::1
<title> Preprocessor Analysis and Transformation   </title>::line_number::2
<author>  Greg J. Badros    </author>::line_number::3
<email>  gjb@cs.washington.edu   </email>::line_number::4
<date>  16 October 1997   </date>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Though the C preprocessor provides necessary language features, it does so in an unstructured way. The lexical nature of cpp creates numerous problems for software engineers  </abstract>::line_number::7
<abstract> and their tools, all stemming from the chasm between the engineer's view of the source code  </abstract>::line_number::8
<abstract> and the compiler's view. The simplest way to reduce this problem is to minimize use of the  </abstract>::line_number::9
<abstract> preprocessor. In light of the data collected in a prior empirical analysis, this paper describes  </abstract>::line_number::10
<abstract> a tool to aid the software engineer in analyses targeted at replacing preprocessor constructs  </abstract>::line_number::11
<abstract> with language features. Existing tools for analyzing C source in the context of the preprocessor are unsuitable for such transformations. This work introduces a new approach: tightly  </abstract>::line_number::12
<abstract> integrating the preprocessor with a C language parser, permitting the code to be analyzed at  </abstract>::line_number::13
<abstract> both the preprocessor and syntactic levels simultaneously. The front-end framework, called  </abstract>::line_number::14
<abstract> PCp 3 , combines a preprocessor, a parser, and arbitrary Perl subroutine "hooks" invoked upon  </abstract>::line_number::15
<abstract> various preprocessor and parser events. PCp 3 's strengths and weaknesses are discussed in the  </abstract>::line_number::16
<abstract> context of several program understanding and transformation tools, including a conservative  </abstract>::line_number::17
<abstract> analysis to support replacing cpp's #define directives with C++ language features.   </abstract>::line_number::18
<intro>  1 Introduction  </intro>::line_number::19

<title>  Automatic Dynamic Compilation Support for  </title>::line_number::0
<title> Event Dispatching in Extensible Systems   </title>::line_number::1
<author>  Craig Chambers, Susan J. Eggers,  </author>::line_number::2
<author> Joel Auslander, Matthai Philipose, Markus Mock, Przemyslaw Pardyak   </author>::line_number::3
<affiliation>  Department of Computer Science and Engineering  </affiliation>::line_number::4
<affiliation> University of Washington   </affiliation>::line_number::5
<address>  Box 352350, Seattle, WA 98195-2350   </address>::line_number::6
<phone>  (206) 685-2094; fax: (206) 543-2969   </phone>::line_number::7
<email>  -chambers, eggers,ausland,matthai,mock,pardy-@cs.washington.edu   </email>::line_number::8
<abstract>  Abstract  </abstract>::line_number::9
<abstract> This paper describes extensions to an automatic dynamic compilation framework to support  </abstract>::line_number::10
<abstract> optimized event dispatching in the SPIN extensible operating system.   </abstract>::line_number::11
<intro>  1 Introduction  </intro>::line_number::12

<title>  Effective Cache Prefetching on Bus-Based Multiprocessors   </title>::line_number::0
<author>  Dean M. Tullsen and Susan J. Eggers   </author>::line_number::1
<affiliation>  University of Washington   </affiliation>::line_number::2
<abstract>  Abstract  </abstract>::line_number::3
<abstract> Compiler-directed cache prefetching has the potential to hide much of the high memory latency seen by  </abstract>::line_number::4
<abstract> current and future high-performance processors. However, prefetching is not without costs, particularly on a  </abstract>::line_number::5
<abstract> multiprocessor. Prefetching can negatively affect bus utilization, overall cache miss rates, memory latencies and  </abstract>::line_number::6
<abstract> data sharing.  </abstract>::line_number::7
<abstract> We simulate the effects of a compiler-directed prefetching algorithm, running on a range of bus-based multiprocessors. We show that, despite a high memory latency, this architecture does not necessarily support prefetching  </abstract>::line_number::8
<abstract> well, in some cases actually causing performance degradations. We pinpoint several problems with prefetching on  </abstract>::line_number::9
<abstract> a shared memory architecture (additional conflict misses, no reduction in the data sharing traffic and associated  </abstract>::line_number::10
<abstract> latencies, a multiprocessor's greater sensitivity to memory utilization and the sensitivity of the cache hit rate to  </abstract>::line_number::11
<abstract> prefetch distance) and measure their effect on performance. We then solve those problems through architectural  </abstract>::line_number::12
<abstract> techniques and heuristics for prefetching that could be easily incorporated into a compiler: 1) victim caching,  </abstract>::line_number::13
<abstract> which eliminates most of the cache conflict misses caused by prefetching in a direct-mapped cache, 2) special  </abstract>::line_number::14
<abstract> prefetch algorithms for shared data, which significantly improve the ability of our basic prefetching algorithm  </abstract>::line_number::15
<abstract> to prefetch invalidation misses, and 3) compiler-based shared data restructuring, which eliminates many of the  </abstract>::line_number::16
<abstract> invalidation misses the basic prefetching algorithm doesn't predict. The combined effect of these improvements  </abstract>::line_number::17
<abstract> is to make prefetching effective over a much wider range of memory architectures.   </abstract>::line_number::18
<keyword>  keywords: cache prefetching, bus-based multiprocessor, cache misses, prefetching strategies, parallel programs, false sharing, memory latency   </keyword>::line_number::19
<intro>  1 Introduction  </intro>::line_number::20

<note>  Journal of Artificial Intelligence Research 6 (1997) 35-85 Submitted 7/96; published 1/97   </note>::line_number::0
<title>  SCREEN: Learning a Flat Syntactic and Semantic Spoken  </title>::line_number::1
<title> Language Analysis Using Artificial Neural Networks   </title>::line_number::2
<author>  Stefan Wermter   wermter@informatik.uni-hamburg.de   </author>::line_number::3
<author>  Volker Weber   weber@informatik.uni-hamburg.de   </author>::line_number::4
<affiliation>  Department of Computer Science  </affiliation>::line_number::5
<affiliation> University of Hamburg   </affiliation>::line_number::6
<address>  22527 Hamburg, Germany   </address>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> Previous approaches of analyzing spontaneously spoken language often have been based  </abstract>::line_number::9
<abstract> on encoding syntactic and semantic knowledge manually and symbolically. While there  </abstract>::line_number::10
<abstract> has been some progress using statistical or connectionist language models, many current  </abstract>::line_number::11
<abstract> spoken-language systems still use a relatively brittle, hand-coded symbolic grammar or  </abstract>::line_number::12
<abstract> symbolic semantic component.  </abstract>::line_number::13
<abstract> In contrast, we describe a so-called screening approach for learning robust processing  </abstract>::line_number::14
<abstract> of spontaneously spoken language. A screening approach is a flat analysis which uses shallow sequences of category representations for analyzing an utterance at various syntactic,  </abstract>::line_number::15
<abstract> semantic and dialog levels. Rather than using a deeply structured symbolic analysis, we  </abstract>::line_number::16
<abstract> use a flat connectionist analysis. This screening approach aims at supporting speech and  </abstract>::line_number::17
<abstract> language processing by using (1) data-driven learning and (2) robustness of connectionist  </abstract>::line_number::18
<abstract> networks. In order to test this approach, we have developed the screen system which is  </abstract>::line_number::19
<abstract> based on this new robust, learned and flat analysis.  </abstract>::line_number::20
<abstract> In this paper, we focus on a detailed description of screen's architecture, the flat  </abstract>::line_number::21
<abstract> syntactic and semantic analysis, the interaction with a speech recognizer, and a detailed  </abstract>::line_number::22
<abstract> evaluation analysis of the robustness under the influence of noisy or incomplete input.  </abstract>::line_number::23
<abstract> The main result of this paper is that flat representations allow more robust processing of  </abstract>::line_number::24
<abstract> spontaneous spoken language than deeply structured representations. In particular, we  </abstract>::line_number::25
<abstract> show how the fault-tolerance and learning capability of connectionist networks can support  </abstract>::line_number::26
<abstract> a flat analysis for providing more robust spoken-language processing within an overall  </abstract>::line_number::27
<abstract> hybrid symbolic/connectionist framework.   </abstract>::line_number::28
<intro>  1. Introduction  </intro>::line_number::29

<note>  Journal of Artificial Intelligence Research 8 (1998) 165-222 Submitted 8/97; published 6/98   </note>::line_number::0
<title>  Model-Based Diagnosis using Structured System  </title>::line_number::1
<title> Descriptions   </title>::line_number::2
<author>  Adnan Darwiche   darwiche@aub.edu.lb   </author>::line_number::3
<affiliation>  Department of Mathematics  </affiliation>::line_number::4
<affiliation> American University of Beirut   </affiliation>::line_number::5
<address>  PO Box 11-236  </address>::line_number::6
<address> Beirut, Lebanon   </address>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> This paper presents a comprehensive approach for model-based diagnosis which includes proposals for characterizing and computing preferred diagnoses, assuming that the  </abstract>::line_number::9
<abstract> system description is augmented with a system structure (a directed graph explicating the  </abstract>::line_number::10
<abstract> interconnections between system components). Specifically, we first introduce the notion of  </abstract>::line_number::11
<abstract> a consequence, which is a syntactically unconstrained propositional sentence that characterizes all consistency-based diagnoses and show that standard characterizations of diagnoses,  </abstract>::line_number::12
<abstract> such as minimal conflicts, correspond to syntactic variations on a consequence. Second,  </abstract>::line_number::13
<abstract> we propose a new syntactic variation on the consequence known as negation normal form  </abstract>::line_number::14
<abstract> (NNF) and discuss its merits compared to standard variations. Third, we introduce a basic  </abstract>::line_number::15
<abstract> algorithm for computing consequences in NNF given a structured system description. We  </abstract>::line_number::16
<abstract> show that if the system structure does not contain cycles, then there is always a linear-size  </abstract>::line_number::17
<abstract> consequence in NNF which can be computed in linear time. For arbitrary system structures, we show a precise connection between the complexity of computing consequences  </abstract>::line_number::18
<abstract> and the topology of the underlying system structure. Finally, we present an algorithm  </abstract>::line_number::19
<abstract> that enumerates the preferred diagnoses characterized by a consequence. The algorithm is  </abstract>::line_number::20
<abstract> shown to take linear time in the size of the consequence if the preference criterion satisfies  </abstract>::line_number::21
<abstract> some general conditions.   </abstract>::line_number::22
<intro>  1. Introduction  </intro>::line_number::23

<title>  Software Deviation Analysis: A "Safeware" Technique   </title>::line_number::0
<author>  Jon Damon Reese and Nancy G. Leveson   </author>::line_number::1
<affiliation>  Dept. of C.S.E. Safeware Engineering Corp.  </affiliation>::line_number::2
<address> University of Washington   7200 Lower Ridge, Unit B  </address>::line_number::3
<address> Box 352350 Everett, WA 98203, U.S.A.  </address>::line_number::4
<address> Seattle, WA 98195, U.S.A.   </address>::line_number::5
<email>  fjdreese,levesong@cs.washington.edu  </email>::line_number::6
<email> fjdreese,levesong@safeware-eng.com   </email>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> Standard safety analysis techniques are often ineffective when computers and digital devices are integrated into plant control. The Safeware methodology and its  </abstract>::line_number::9
<abstract> set of supporting safety analysis techniques (and prototype tools) includes modeling  </abstract>::line_number::10
<abstract> and hazard analysis of complex systems where the components may be a mixture of  </abstract>::line_number::11
<abstract> humans, hardware, and software. This paper describes one of the Safeware hazard  </abstract>::line_number::12
<abstract> analysis techniques, Software Deviation Analysis, that incorporates the beneficial features of HAZOP (such as guidewords, deviations, exploratory analysis, and a systems  </abstract>::line_number::13
<abstract> engineering approach) into an automated procedure that is capable of handling the  </abstract>::line_number::14
<abstract> complexity and logical nature of computer software.   </abstract>::line_number::15
<note>  This work was partly funded by NASA/Langley Grant NAG-1-1495, NSF Grant CCR-9396181, and the  </note>::line_number::16
<note> California PATH Program of the University of California, in cooperation with the California Department  </note>::line_number::17
<note> of Transportation and the U.S. Department of Transportation.   </note>::line_number::18
<page>  +PAGE+  </page>::line_number::19

<title>  Partition Based Spatial-Merge Join   </title>::line_number::0
<author>  Jignesh M. Patel David J. DeWitt   </author>::line_number::1
<affiliation>  Computer Sciences Department,  </affiliation>::line_number::2
<affiliation> University of Wisconsin, Madison   </affiliation>::line_number::3
<email>  fjignesh, dewittg@cs.wisc.edu   </email>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> This paper describes PBSM (Partition Based Spatial-Merge), a new algorithm for performing spatial join operation. This algorithm is especially effective when neither of the inputs to the join have an index on the joining  </abstract>::line_number::6
<abstract> attribute. Such a situation could arise if both inputs to the join are intermediate results in a complex query, or in  </abstract>::line_number::7
<abstract> a parallel environment where the inputs must be dynamically redistributed. The PBSM algorithm partitions the  </abstract>::line_number::8
<abstract> inputs into manageable chunks, and joins them using a computational geometry based plane-sweeping technique. This paper also presents a performance study comparing the the traditional indexed nested loops join  </abstract>::line_number::9
<abstract> algorithm, a spatial join algorithm based on joining spatial indices, and the PBSM algorithm. These comparisons  </abstract>::line_number::10
<abstract> are based on complete implementations of these algorithms in Paradise, a database system for handling GIS applications. Using real data sets, the performance study examines the behavior of these spatial join algorithms in a  </abstract>::line_number::11
<abstract> variety of situations, including the cases when both, one, or none of the inputs to the join have an suitable index.  </abstract>::line_number::12
<abstract> The study also examines the effect of clustering the join inputs on the performance of these join algorithms. The  </abstract>::line_number::13
<abstract> performance comparisons demonstrates the feasibility, and applicability of the PBSM join algorithm.   </abstract>::line_number::14
<intro>  1 Introduction  </intro>::line_number::15

<title>  Demand Interprocedural Dataflow Analysis   </title>::line_number::0
<author>  Susan Horwitz, Thomas Reps, and Mooly Sagiv    </author>::line_number::1
<affiliation>  University of Wisconsin   </affiliation>::line_number::2
<abstract>  Abstract  </abstract>::line_number::3
<abstract> An exhaustive dataflow-analysis algorithm associates with each point in a program a set of dataflow facts  </abstract>::line_number::4
<abstract> that are guaranteed to hold whenever that point is reached during program execution. By contrast, a  </abstract>::line_number::5
<abstract> demand dataflow-analysis algorithm determines whether a single given dataflow fact holds at a single given  </abstract>::line_number::6
<abstract> point.  </abstract>::line_number::7
<abstract> This paper presents a new demand algorithm for interprocedural dataflow analysis. The algorithm has  </abstract>::line_number::8
<abstract> four important properties:  </abstract>::line_number::9
<abstract> g It provides precise (meet-over-all-interprocedurally-valid-paths) solutions to a large class of problems.  </abstract>::line_number::10
<abstract> g It has a polynomial worst-case cost for both a single demand and a sequence of all possible demands.  </abstract>::line_number::11
<abstract> g The worst-case total cost of the sequence of all possible demands is no worse than the worst-case cost  </abstract>::line_number::12
<abstract> of a single run of the current best exhaustive algorithm.  </abstract>::line_number::13
<abstract> g Experimental results show that in many situations (e.g., when only a small number of demands are  </abstract>::line_number::14
<abstract> made, or when most demands are answered yes) the demand algorithm is superior to the current best  </abstract>::line_number::15
<abstract> exhaustive algorithm.   </abstract>::line_number::16
<keyword>  CR Categories and Subject Descriptors: D.2.2 [Software Engineering]: Tools and Techniques; D.3.4  </keyword>::line_number::17
<keyword> [Programming Languages]: Processors compilers, optimization; E.1 [Data Structures] graphs; F.2.2  </keyword>::line_number::18
<keyword> [Analysis of Algorithms and Problem Complexity]: Nonnumerical Algorithms and Problems computations on discrete structures; G.2.2 [Discrete Mathematics]: Graph Theory graph algorithms  </keyword>::line_number::19
<keyword> General Terms: Algorithms, Experimentation, Theory  </keyword>::line_number::20
<keyword> Additional Key Words and Phrases: demand dataflow analysis, distributive dataflow framework, graph  </keyword>::line_number::21
<keyword> reachability, interprocedural dataflow analysis, interprocedurally realizable path, interprocedurally valid  </keyword>::line_number::22
<keyword> path, meet-over-all-valid-paths solution   </keyword>::line_number::23
<note>  On leave from IBM Scientific Center, Haifa, Israel.  </note>::line_number::24
<note> This work was supported in part by a David and Lucile Packard Fellowship for Science and Engineering, by the National Science  </note>::line_number::25
<note> Foundation under grants CCR-8958530 and CCR-9100424, by the Defense Advanced Research Projects Agency under ARPA Order  </note>::line_number::26
<note> No. 8856 (monitored by the Office of Naval Research under contract N00014-92-J-1937), by the Air Force Office of Scientific  </note>::line_number::27
<note> Research under grant AFOSR-91-0308, and by a grant from Xerox Corporate Research.  </note>::line_number::28
<note> Part of this work was done while the authors were visiting the University of Copenhagen.  </note>::line_number::29
<note> A preliminary version of this paper appeared in SIGSOFT 95: Proceedings of the Third ACM SIGSOFT Symposium on Foundations  </note>::line_number::30
<note> of Software Engineering (Washington DC, October 10-13, 1995) [15]  </note>::line_number::31
<affiliation> Authors' address:   Computer Sciences Department; Univ. of Wisconsin;   1210 West Dayton Street; Madison, WI 53706; USA.   </affiliation>::line_number::32
<email>  Electronic mail: -horwitz, reps, sagiv-@cs.wisc.edu.   </email>::line_number::33
<page>  +PAGE+  </page>::line_number::34

<title>  Maximal-Munch Tokenization in Linear Time   </title>::line_number::0
<author>  THOMAS REPS   </author>::line_number::1
<affiliation>  University of Wisconsin   </affiliation>::line_number::2
<abstract>  The lexical-analysis (or scanning) phase of a compiler attempts to partition the input stream into a sequence of tokens.  </abstract>::line_number::3
<abstract> The convention in most languages is that the input is scanned left to right, and each token identified is a maximal  </abstract>::line_number::4
<abstract> munch of the remaining inputthe longest prefix of the remaining input that is a token of the language. Most textbooks on compiling have extensive discussions of lexical analysis in terms of finite-state automata and regular expressions: Token classes are defined by a set of regular expressions R i , 1 i k, and the lexical analyzer is based on some  </abstract>::line_number::5
<abstract> form of finite-state automaton for recognizing the language L (R 1 + R 2 + . . . + R k ). However, the treatment is unsatisfactory in one respect: The theory of finite-state automata assumes that the end of the input stringi.e., the right-hand-side boundary of the candidate for recognitionis known a priori, whereas a scanner must identify the next token  </abstract>::line_number::6
<abstract> without knowing a definite bound on the extent of the token.  </abstract>::line_number::7
<abstract> Although most of the standard compiler textbooks discuss this issue, the solution they sketch out is one thatfor  </abstract>::line_number::8
<abstract> certain sets of token definitionscan cause the scanner to exhibit quadratic behavior in the worst case. This property is  </abstract>::line_number::9
<abstract> not only dissatisfying, it blemishes an otherwise elegant treatment of lexical analysis.  </abstract>::line_number::10
<abstract> In this paper, we rectify this defect: We show that, given a deterministic finite-state automaton that recognizes the  </abstract>::line_number::11
<abstract> tokens of a language, maximal-munch tokenization can always be performed in time linear in the size of the input.   </abstract>::line_number::12
<keyword>  CR Categories and Subject Descriptors: D.3.1 [Programming Languages]: Formal Definitions and Theory syntax;  </keyword>::line_number::13
<keyword> D.3.4 [Programming Languages]: Processors compilers; F.1.1 [Computation by Abstract Devices]: Models of  </keyword>::line_number::14
<keyword> Computation automata; F.2.2 [Analysis of Algorithms and Problem Complexity]: Nonnumerical Algorithms and  </keyword>::line_number::15
<keyword> Problems pattern matching; I.2.8 [Artificial Intelligence]: Problem Solving, Control Methods, and Search backtracking, dynamic programming; I.5.4 [Pattern Recognition]: Applications text processing  </keyword>::line_number::16
<keyword> General Terms: Algorithms, Theory  </keyword>::line_number::17
<keyword> Additional Key Words and Phrases: memoization, tabulation, tokenization   </keyword>::line_number::18
<intro>  1. INTRODUCTION  </intro>::line_number::19

<title>  DEVise: Integrated Querying and  </title>::line_number::0
<title> Visual Exploration of Large Datasets   </title>::line_number::1
<author>  M. Livny, R. Ramakrishnan, K. Beyer, G. Chen, D. Donjerkovic,  </author>::line_number::2
<author> S. Lawande, J. Myllymaki and K. Wenger   </author>::line_number::3
<affiliation>  Department of Computer Sciences, University of Wisconsin-Madison   </affiliation>::line_number::4
<email>  fmiron,raghu,beyer,guangshu,donjerko,ssl,jussi,wengerg@cs.wisc.edu   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> DEVise is a data exploration system that allows users to easily develop, browse, and share visual presentations of large  </abstract>::line_number::7
<abstract> tabular datasets (possibly containing or referencing multimedia objects) from several sources. The DEVise framework  </abstract>::line_number::8
<abstract> is being implemented in a tool that has been already successfully applied to a variety of real applications by a number  </abstract>::line_number::9
<abstract> of user groups.  </abstract>::line_number::10
<abstract> Our emphasis is on developing an intuitive yet powerful set of querying and visualization primitives that can be  </abstract>::line_number::11
<abstract> easily combined to develop a rich set of visual presentations  </abstract>::line_number::12
<abstract> that integrate data from a wide range of application domains. While DEVise is a powerful visualization tool, its  </abstract>::line_number::13
<abstract> greatest strengths are the ability to interactively explore a  </abstract>::line_number::14
<abstract> visual presentation of the data at any level of detail (including retrieving individual data records), and the ability to  </abstract>::line_number::15
<abstract> seamlessly query and combine data from a variety of local  </abstract>::line_number::16
<abstract> and remote sources. In this paper, we present the DEVise  </abstract>::line_number::17
<abstract> framework, describe the current tool, and report on our experience in applying it to several real applications.   </abstract>::line_number::18
<intro>  1 Introduction  </intro>::line_number::19

<title>  Cost-Aware WWW Proxy Caching Algorithms   </title>::line_number::0
<author>  Pei Cao Sandy Irani   </author>::line_number::1
<affiliation>  Department of Computer Science, Information and Computer Science Department,  </affiliation>::line_number::2
<affiliation> University of Wisconsin-Madison. University of California-Irvine.   </affiliation>::line_number::3
<email>  cao@cs.wisc.edu irani@ics.uci.edu   </email>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> Web caches can not only reduce network traffic and  </abstract>::line_number::6
<abstract> downloading latency, but can also affect the distribution of web traffic over the network through cost-aware caching. This paper introduces GreedyDual-Size, which incorporates locality with cost and size  </abstract>::line_number::7
<abstract> concerns in a simple and non-parameterized fashion  </abstract>::line_number::8
<abstract> for high performance. Trace-driven simulations show  </abstract>::line_number::9
<abstract> that with the appropriate cost definition, GreedyDual-Size outperforms existing web cache replacement algorithms in many aspects, including hit ratios, latency reduction and network cost reduction. In addition, GreedyDual-Size can potentially improve the  </abstract>::line_number::10
<abstract> performance of main-memory caching of Web documents.   </abstract>::line_number::11
<intro>  1 Introduction  </intro>::line_number::12

<title>  LATENT VARIABLES, MEASUREMENT ERROR AND  </title>::line_number::0
<title> METHODS FOR ANALYZING LONGITUDINAL  </title>::line_number::1
<title> ORDINAL DATA   </title>::line_number::2
<author>  Mari Palta, Chin-Yu Lin,   University of Wisconsin-Madison   </author>::line_number::3
<author>  Mari Palta,   504 N Walnut Street, Madison, WI 53705   </author>::line_number::4
<keyword>  Key Words: Latent variable, Longitudinal ordinal data, Structural equation model   </keyword>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> We examine the effects of latent variables, between  </abstract>::line_number::7
<abstract> individual variability and measurement error in the  </abstract>::line_number::8
<abstract> outcome on commonly used methods for the analysis of longitudinal ordinal data, such as marginal  </abstract>::line_number::9
<abstract> and cluster-specific models. The impact of such variability becomes very clear when viewed in the context of structural equation modeling (e.g. Muthen  </abstract>::line_number::10
<abstract> 1979, 1983, 1984, 1988). The structural equation  </abstract>::line_number::11
<abstract> formulation also provides insight into the assumptions and differences in interpretation of regression  </abstract>::line_number::12
<abstract> coefficients of these various methods of analysis. We  </abstract>::line_number::13
<abstract> explore the potential for using structural equations  </abstract>::line_number::14
<abstract> to model random effects and to adjust for measurement error, and in the process compare results  </abstract>::line_number::15
<abstract> from marginal modeling using a SAS GEE routine  </abstract>::line_number::16
<abstract> (Karim and Zeger, 1988), Qu's GAUSS program  </abstract>::line_number::17
<abstract> (Qu, 1992) for generalized mixed models using GEE,  </abstract>::line_number::18
<abstract> the MIXOR package for cluster-specific mixed effects models (Hedeker and Gibbons, 1994), and LIS-COMP (Muthen, 1988) for structural equation models. These approaches are illustrated in a longitudinal data set of sleep disorders.   </abstract>::line_number::19
<intro>  Introduction  </intro>::line_number::20

<author>  Aart J.C. Bik   </author>::line_number::0
<title>  High Performance Computing Division   </title>::line_number::1
<affiliation>  Department of Computer Science  </affiliation>::line_number::2
<affiliation> Leiden University   </affiliation>::line_number::3
<address>  P.O. Box 9512, 2300 RA Leiden  </address>::line_number::4
<address> The Netherlands   </address>::line_number::5
<email>  ajcbik@cs.leidenuniv.nl   </email>::line_number::6
<phone>  Tel. +31 71 5277037   </phone>::line_number::7
<note>  Submission to PLDI'96   </note>::line_number::8
<page>  +PAGE+  </page>::line_number::9

<title>  Practical Comparison of call string and functional Approach in  </title>::line_number::0
<title> Data Flow Analysis    </title>::line_number::1
<author>  Martin Alt Florian Martin   </author>::line_number::2
<affiliation>  Universitat des Saarlandes,   P.O. Box 151150, 66041 Saarbrucken,   </affiliation>::line_number::3
<email>  faltjfloriang@cs.uni-sb.de   </email>::line_number::4
<date>  October 20, 1995   </date>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> The techniques which are used to implement interprocedural data flow analyzers can be generally  </abstract>::line_number::7
<abstract> divided into two parts: the call string and the functional approach [18]. Both differ in their time and space  </abstract>::line_number::8
<abstract> complexity as well as in the preciseness due to properties of the abstract domains and transfer functions.  </abstract>::line_number::9
<abstract> We have developed a data flow analyzer generator PAG [2] which is able to produce interprocedural  </abstract>::line_number::10
<abstract> analyzers for both techniques. We specified two variants of constant propagation working in an ANSI-C  </abstract>::line_number::11
<abstract> compiler; a copy constant propagation that uses distributive transfer function and can be solved precisely,  </abstract>::line_number::12
<abstract> even interprocedurally [13], and a full constant propagator which includes an interpreter for expressions  </abstract>::line_number::13
<abstract> of the language. We present the practical relevant results applying both analyzers to a rather fair set of  </abstract>::line_number::14
<abstract> real-world programs and compare the space/time consumption of the analyzers versus their preciseness.   </abstract>::line_number::15
<intro>  1 Introduction  </intro>::line_number::16

<title>  Kerberos: An Authentication Service for Open Network Systems   </title>::line_number::0
<author>  Jennifer G. Steiner   </author>::line_number::1
<affiliation>  Project Athena  </affiliation>::line_number::2
<affiliation> Massachusetts Institute of Technology   </affiliation>::line_number::3
<address>  Cambridge, MA 02139   </address>::line_number::4
<email>  steiner@ATHENA.MIT.EDU   </email>::line_number::5
<author>  Clifford Neuman   </author>::line_number::6
<affiliation>  Department of Computer Science,   FR-35   </affiliation>::line_number::7
<affiliation>  University of Washington   </affiliation>::line_number::8
<address>  Seattle, WA 98195   </address>::line_number::9
<email>  bcn@CS.WASHINGTON.EDU   </email>::line_number::10
<author>  Jeffrey I. Schiller   </author>::line_number::11
<affiliation>  Project Athena  </affiliation>::line_number::12
<affiliation> Massachusetts Institute of Technology   </affiliation>::line_number::13
<address>  Cambridge, MA 02139   </address>::line_number::14
<email>  jis@ATHENA.MIT.EDU   </email>::line_number::15
<abstract>  ABSTRACT  </abstract>::line_number::16
<abstract> In an open network computing environment, a workstation cannot be trusted to  </abstract>::line_number::17
<abstract> identify its users correctly to network services. Kerberos provides an alternative  </abstract>::line_number::18
<abstract> approach whereby a trusted third-party authentication service is used to verify users'  </abstract>::line_number::19
<abstract> identities. This paper gives an overview of the Kerberos authentication model as implemented for MIT's Project Athena. It describes the protocols used by clients, servers, and  </abstract>::line_number::20
<abstract> Kerberos to achieve authentication. It also describes the management and replication of  </abstract>::line_number::21
<abstract> the database required. The views of Kerberos as seen by the user, programmer, and  </abstract>::line_number::22
<abstract> administrator are described. Finally, the role of Kerberos in the larger Athena picture is  </abstract>::line_number::23
<abstract> given, along with a list of applications that presently use Kerberos for user authentication. We describe the addition of Kerberos authentication to the Sun Network File System as a case study for integrating Kerberos with an existing application.   </abstract>::line_number::24
<intro>  Introduction  </intro>::line_number::25

<title>  DEVise: Integrated Querying and  </title>::line_number::0
<title> Visual Exploration of Large Datasets   </title>::line_number::1
<author>  M. Livny, R. Ramakrishnan, K. Beyer, G. Chen, D. Donjerkovic,  </author>::line_number::2
<author> S. Lawande, J. Myllymaki and K. Wenger   </author>::line_number::3
<affiliation>  Department of Computer Sciences, University of Wisconsin-Madison   </affiliation>::line_number::4
<email>  fmiron,raghu,beyer,guangshu,donjerko,ssl,jussi,wengerg@cs.wisc.edu   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> DEVise is a data exploration system that allows users to easily develop, browse, and share visual presentations of large  </abstract>::line_number::7
<abstract> tabular datasets (possibly containing or referencing multimedia objects) from several sources. The DEVise framework  </abstract>::line_number::8
<abstract> is being implemented in a tool that has been already successfully applied to a variety of real applications by a number  </abstract>::line_number::9
<abstract> of user groups.  </abstract>::line_number::10
<abstract> Our emphasis is on developing an intuitive yet powerful set of querying and visualization primitives that can be  </abstract>::line_number::11
<abstract> easily combined to develop a rich set of visual presentations  </abstract>::line_number::12
<abstract> that integrate data from a wide range of application domains. While DEVise is a powerful visualization tool, its  </abstract>::line_number::13
<abstract> greatest strengths are the ability to interactively explore a  </abstract>::line_number::14
<abstract> visual presentation of the data at any level of detail (includ-ing retrieving individual data records), and the ability to  </abstract>::line_number::15
<abstract> seamlessly query and combine data from a variety of local  </abstract>::line_number::16
<abstract> and remote sources. In this paper, we present the DEVise  </abstract>::line_number::17
<abstract> framework, describe the current tool, and report on our experience in applying it to several real applications.   </abstract>::line_number::18
<intro>  1 Introduction  </intro>::line_number::19

<title>  Approximate Analysis of Parallel Processor Allocation Policies   </title>::line_number::0
<author>  Rajesh K. Mansharamani and Mary K. Vernon   </author>::line_number::1
<email>  (mansha@cs.wisc.edu) (vernon@cs.wisc.edu)   </email>::line_number::2
<affiliation>  Computer Sciences Department  </affiliation>::line_number::3
<affiliation> University of Wisconsin   </affiliation>::line_number::4
<address>  1210 West Dayton Street  </address>::line_number::5
<address> Madison, WI 53706.   </address>::line_number::6
<date>  November 29, 1993   </date>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> The complexity of parallel applications and parallel processor scheduling policies makes both exact analysis and simulation difficult, if not intractable, for large systems. In this paper we propose a new approach  </abstract>::line_number::9
<abstract> to performance modeling of multiprogrammed processor scheduling policies, that of interpolation approximations. We first define a workload model that contains parameters for the essential properties of parallel  </abstract>::line_number::10
<abstract> applications with respect to scheduling discipline performance, yet lends itself to mathematical analysis. Key  </abstract>::line_number::11
<abstract> features of the workload model include general distribution of total job processing time, general distribution  </abstract>::line_number::12
<abstract> of available job parallelism, and a simple characterization of parallelism overheads. We then show that one  </abstract>::line_number::13
<abstract> can find specific values of the system parameters for which the parallel system under a given scheduling  </abstract>::line_number::14
<abstract> policy reduces to a queueing system with a known (closed-form) solution. Finally, interpolation between  </abstract>::line_number::15
<abstract> the points with known solutions is used to arrive at mean response time estimates that hold over the entire  </abstract>::line_number::16
<abstract> system parameter space. The interpolation approximations readily yield insight into policy behavior and are  </abstract>::line_number::17
<abstract> easy to evaluate for systems with hundreds of processors.  </abstract>::line_number::18
<abstract> We illustrate the approach by developing and validating models of three scheduling policies, under the  </abstract>::line_number::19
<abstract> assumptions of linear job execution rates and independence between job parallelism and processing time.  </abstract>::line_number::20
<abstract> We discuss several insights and results obtained from the analysis of the three policies under the assumed  </abstract>::line_number::21
<abstract> workloads. One result clarifies and generalizes observations in two previous simulation studies of how policy  </abstract>::line_number::22
<abstract> performance varies with the coefficient of variation in job processing requirement. Another result of the  </abstract>::line_number::23
<abstract> interpolation models yields new insight into how policy performance varies with job parallelism. We also  </abstract>::line_number::24
<abstract> comment on the generalizations of these insights for workloads with less restrictive assumptions.   </abstract>::line_number::25
<note>  This research was partially supported by the National Science Foundation under grants CCR-9024144 and CDA-9024618.   </note>::line_number::26
<page>  +PAGE+  </page>::line_number::27

<title>  High-Order Accurate Schemes for Incompressible Viscous Flow   </title>::line_number::0
<author>  John C. Strikwerday   </author>::line_number::1
<affiliation>  Computer Sciences Department  </affiliation>::line_number::2
<affiliation> University of Wisconsin-Madison   </affiliation>::line_number::3
<abstract>  Abstract  </abstract>::line_number::4
<abstract> We present new finite difference schemes for the incompressible Navier-Stokes equations. The schemes are based on two spatial differencing methods, one is fourth-order  </abstract>::line_number::5
<abstract> accurate and the other is sixth-order accurate. The temporal differencing is based on  </abstract>::line_number::6
<abstract> backward differencing formulas. The schemes use non-staggered grids and satisfy regularity estimates, guaranteeing smoothness of the solutions. The schemes are computationally  </abstract>::line_number::7
<abstract> efficient. Computational results demonstrating the accuracy are presented.   </abstract>::line_number::8
<keyword>  Keywords: incompressible Navier-Stokes, finite difference schemes, GMRES.   </keyword>::line_number::9
<note>  AMS(MOS) classifications: 65M05, 65N05, 76D05   </note>::line_number::10
<intro>  1. Introduction.  </intro>::line_number::11

<title>  Use of Application Characteristics and Limited Preemption for  </title>::line_number::0
<title> Run-To-Completion Parallel Processor Scheduling Policies *   </title>::line_number::1
<author>  Su-Hui Chiang , Rajesh K. Mansharamani , and Mary K. Vernon    </author>::line_number::2
<affiliation>  Computer Sciences Department  </affiliation>::line_number::3
<affiliation> University of Wisconsin-Madison   </affiliation>::line_number::4
<address>  Madison, WI 53706.   </address>::line_number::5
<email>  email: -suhui, vernon-@cs.wisc.edu   </email>::line_number::6
<affiliation>  TRDDC   </affiliation>::line_number::7
<address>  1 Mangaldas Road  </address>::line_number::8
<address> Pune 411 050, India.   </address>::line_number::9
<email>  email: mansha@research.trddc.ernet.in   </email>::line_number::10
<abstract>  Abstract  </abstract>::line_number::11
<abstract> The performance potential of run-to-completion (RTC) parallel  </abstract>::line_number::12
<abstract> processor scheduling policies is investigated by examining  </abstract>::line_number::13
<abstract> whether (1) application execution rate characteristics such as average parallelism (avg) and processor working set (pws) and/or (2)  </abstract>::line_number::14
<abstract> limited preemption can be used to improve the performance of  </abstract>::line_number::15
<abstract> these policies. We address the first question by comparing policies  </abstract>::line_number::16
<abstract> (previous as well as new) that differ only in whether or not they  </abstract>::line_number::17
<abstract> use execution rate characteristics and by examining a wider range  </abstract>::line_number::18
<abstract> of the workload parameter space than previous studies. We address  </abstract>::line_number::19
<abstract> the second question by comparing a simple two-level queueing  </abstract>::line_number::20
<abstract> policy with RTC scheduling in the second level queue against  </abstract>::line_number::21
<abstract> RTC policies that don't allow any preemption and against dynamic  </abstract>::line_number::22
<abstract> equiallocation (EQ).  </abstract>::line_number::23
<abstract> Using simulation to estimate mean response times we find that for  </abstract>::line_number::24
<abstract> promising RTC policies such as adaptive static partitioning (ASP)  </abstract>::line_number::25
<abstract> and shortest demand first (SDF), a maximum allocation constraint  </abstract>::line_number::26
<abstract> that is for all practical purposes independent of avg and pws provides greater and more consistent improvement in policy performance than using avg or pws. Also, under the assumption that job  </abstract>::line_number::27
<abstract> demand information is unavailable to the scheduler we show that  </abstract>::line_number::28
<abstract> the ASP-max policy outperforms all previous high performance  </abstract>::line_number::29
<abstract> RTC policies for workloads with coefficient of variation in processing requirement greater than one. Furthermore, a two-level  </abstract>::line_number::30
<abstract> queue that allows at most one preemption per job outperforms  </abstract>::line_number::31
<abstract> ASP-max but is not competitive with EQ.   </abstract>::line_number::32
<intro>  1. Introduction  </intro>::line_number::33

<title>  RD-OPT: An Efficient Algorithm For Optimizing DCT  </title>::line_number::0
<title> Quantization Tables    </title>::line_number::1
<author>  Viresh Ratnakar   </author>::line_number::2
<affiliation>  University of Wisconsin-Madison  </affiliation>::line_number::3
<affiliation> Computer Sciences Department   </affiliation>::line_number::4
<address>  Madison, WI 53706   </address>::line_number::5
<phone>  Phone: (608) 262-6627   </phone>::line_number::6
<email>  Email: ratnakar@cs.wisc.edu   </email>::line_number::7
<author>  Miron Livny   </author>::line_number::8
<affiliation>  University of Wisconsin-Madison  </affiliation>::line_number::9
<affiliation> Computer Sciences Department   </affiliation>::line_number::10
<address>  Madison, WI 53706   </address>::line_number::11
<phone>  Phone: (608) 262-0856   </phone>::line_number::12
<email>  Email: miron@cs.wisc.edu   </email>::line_number::13
<abstract>  Abstract  </abstract>::line_number::14
<abstract> The Discrete Cosine Transform (DCT) is widely used in lossy image and video compression schemes  </abstract>::line_number::15
<abstract> such as JPEG and MPEG. In this paper we describe RD-OPT, an efficient algorithm for constructing  </abstract>::line_number::16
<abstract> DCT quantization tables with optimal rate-distortion tradeoffs for a given image. The algorithm uses  </abstract>::line_number::17
<abstract> DCT coefficient distribution statistics in a novel way and uses a dynamic programming strategy to  </abstract>::line_number::18
<abstract> produce optimal quantization tables over a wide range of rates and distortions. It can be used to  </abstract>::line_number::19
<abstract> compress images at any desired signal-to-noise ratio or compressed size.   </abstract>::line_number::20
<intro>  1 Introduction  </intro>::line_number::21

<title>  Program Generalization for Software Reuse:  </title>::line_number::0
<title> From C to C++    </title>::line_number::1
<author>  Michael Siff   </author>::line_number::2
<email>  siff@cs.wisc.edu   </email>::line_number::3
<author>  Thomas Reps   </author>::line_number::4
<email>  reps@cs.wisc.edu   </email>::line_number::5
<affiliation>  University of Wisconsin-Madison   </affiliation>::line_number::6
<address>  1210 West Dayton Street  </address>::line_number::7
<address> Madison, WI 53706   </address>::line_number::8
<abstract>  Abstract  </abstract>::line_number::9
<abstract> We consider the problem of software generalization: Given a program component C, create  </abstract>::line_number::10
<abstract> a parameterized program component C 0 such that C 0 is usable in a wider variety of syntactic  </abstract>::line_number::11
<abstract> contexts than C. Furthermore, C 0 should be a semantically meaningful generalization of C;  </abstract>::line_number::12
<abstract> namely, there must exist an instantiation of C 0 that is equivalent in functionality to C.  </abstract>::line_number::13
<abstract> In this paper, we present an algorithm that generalizes C functions via type inference. The  </abstract>::line_number::14
<abstract> original functions operate on specific data types; the result of generalization is a collection of  </abstract>::line_number::15
<abstract> C++ function templates that operate on parameterized types. This version of the generalization  </abstract>::line_number::16
<abstract> problem is useful in the context of converting existing C programs to C++.   </abstract>::line_number::17
<intro>  1 Introduction  </intro>::line_number::18

<title>  Interconvertibility of Set Constraints and  </title>::line_number::0
<title> Context-Free Language Reachability   </title>::line_number::1
<author>  David Melski Thomas Reps   </author>::line_number::2
<date>  November 18, 1996   </date>::line_number::3
<abstract>  Abstract  </abstract>::line_number::4
<abstract> We show the interconvertibility of context-free-language reachability problems and a class  </abstract>::line_number::5
<abstract> of set-constraint problems: given a context-free-language reachability problem, we show how to  </abstract>::line_number::6
<abstract> construct a set-constraint problem whose answer gives a solution to the reachability problem;  </abstract>::line_number::7
<abstract> given a set-constraint problem, we show how to construct a context-free-language reachability  </abstract>::line_number::8
<abstract> problem whose answer gives a solution to the set-constraint problem. The interconvertibility  </abstract>::line_number::9
<abstract> of these two formalisms offers an conceptual advantage akin to the advantage gained from the  </abstract>::line_number::10
<abstract> interconvertibility of finite-state automata and regular expressions in language theory, namely,  </abstract>::line_number::11
<abstract> a problem can be formulated in whichever formalism is most natural. It also offers some insight into the "O(n 3 ) bottleneck" for different types of program-analysis problems, and allows  </abstract>::line_number::12
<abstract> results previously obtained for context-free-language reachability problems to be applied to set  </abstract>::line_number::13
<abstract> constraint problems.   </abstract>::line_number::14
<author>  David Melski Thomas Reps   </author>::line_number::15
<affiliation>  Computer Sciences Department Computer Sciences Department  </affiliation>::line_number::16
<affiliation> University of Wisconsin University of Wisconsin   </affiliation>::line_number::17
<address>  1210 W. Dayton St. 1210 W. Dayton St.  </address>::line_number::18
<address> Madison, WI 53706 Madison, WI 53706   </address>::line_number::19
<phone>  608/262-0016 608/262-2091   </phone>::line_number::20
<email>  melski@cs.wisc.edu   608/262-9777 (fax)   </email>::line_number::21
<email>  reps@cs.wisc.edu   </email>::line_number::22
<page>  +PAGE+  </page>::line_number::23

<title>  MULTI-COORDINATION METHODS FOR  </title>::line_number::0
<title> PARALLEL SOLUTION OF  </title>::line_number::1
<title> BLOCK-ANGULAR PROGRAMS   </title>::line_number::2
<author>  By  </author>::line_number::3
<author> Golbon Zakeri   </author>::line_number::4
<degree>  A thesis submitted in partial fulfillment of the  </degree>::line_number::5
<degree> requirements for the degree of  </degree>::line_number::6
<degree> Doctor of Philosophy  </degree>::line_number::7
<degree> (Computer Sciences and Mathematics)  </degree>::line_number::8
<degree> at the   </degree>::line_number::9
<affiliation>  UNIVERSITY OF WISCONSIN - MADISON   </affiliation>::line_number::10
<date>  1995   </date>::line_number::11
<page>  +PAGE+  </page>::line_number::12

<note>  , , 1-19 ()  </note>::line_number::0
<note> c Kluwer Academic Publishers, Boston. Manufactured in The Netherlands.   </note>::line_number::1
<title>  A Comparison of Large Scale Mixed  </title>::line_number::2
<title> Complementarity Problem Solvers *   </title>::line_number::3
<author>  STEPHEN C. BILLUPS   sbillups@carbon.cudenver.edu   </author>::line_number::4
<affiliation>  Mathematics Department, University of Colorado,   Denver, Colorado 80217   </affiliation>::line_number::5
<author>  STEVEN P. DIRKSE   steve@gams.com   </author>::line_number::6
<affiliation>  GAMS Development Corporation,   Washington, DC 20007   </affiliation>::line_number::7
<author>  MICHAEL C. FERRIS   ferris@cs.wisc.edu   </author>::line_number::8
<affiliation>  Computer Sciences Department, University of Wisconsin,   Madison, Wisconsin 53706   </affiliation>::line_number::9
<date>  Received Oct 1, 1995; Revised March 22, 1996   </date>::line_number::10
<note>  Editor:   </note>::line_number::11
<abstract>  Abstract. This paper provides a means for comparing various computer codes for solving large  </abstract>::line_number::12
<abstract> scale mixed complementarity problems. We discuss inadequacies in how solvers are currently  </abstract>::line_number::13
<abstract> compared, and present a testing environment that addresses these inadequacies. This testing  </abstract>::line_number::14
<abstract> environment consists of a library of test problems, along with GAMS and MATLAB interfaces that  </abstract>::line_number::15
<abstract> allow these problems to be easily accessed. The environment is intended for use as a tool by other  </abstract>::line_number::16
<abstract> researchers to better understand both their algorithms and their implementations, and to direct  </abstract>::line_number::17
<abstract> research toward problem classes that are currently the most challenging. As an initial benchmark,  </abstract>::line_number::18
<abstract> eight different algorithm implementations for large scale mixed complementarity problems are  </abstract>::line_number::19
<abstract> briefly described and tested with default parameter settings using the new testing environment.   </abstract>::line_number::20
<keyword>  Keywords: complementarity problems, variational inequalities, computation, algorithms   </keyword>::line_number::21
<intro>  1. Introduction  </intro>::line_number::22

<title>  SYNCHRONOUS AND ASYNCHRONOUS MULTI-COORDINATION  </title>::line_number::0
<title> METHODS FOR THE SOLUTION OF BLOCK-ANGULAR  </title>::line_number::1
<title> PROGRAMS   </title>::line_number::2
<author>  R.R. MEYER AND G. ZAKERI    </author>::line_number::3
<abstract>  Abstract. Several types of multi-coordination methods for block-angular programs are considered. We present a computational comparison of synchronous multi-coordination methods. The most  </abstract>::line_number::4
<abstract> efficient of these approaches is shown to involve an intermediate number of blocks in the coordination  </abstract>::line_number::5
<abstract> phase. We also develop a new stabilization algorithm and present asynchronous multi-coordination  </abstract>::line_number::6
<abstract> schemes, which are particularly useful when the number of blocks exceeds the number of available  </abstract>::line_number::7
<abstract> processors or when the block sizes vary significantly.   </abstract>::line_number::8
<intro>  1. Introduction. In this paper we present multi-coordinator synchronous and  </intro>::line_number::9

<title>  PRECONDITIONING FOR REGULAR ELLIPTIC SYSTEMS   </title>::line_number::0
<author>  Hsing-Hsia Chen   </author>::line_number::1
<affiliation>  Department of Mathematics  </affiliation>::line_number::2
<affiliation> Chung-Yuan Christian University   </affiliation>::line_number::3
<address>  Chung-Li, 320, Taiwan   </address>::line_number::4
<author>  and  </author>::line_number::5
<author> John C. Strikwerday   </author>::line_number::6
<affiliation>  Department of Computer Sciences  </affiliation>::line_number::7
<affiliation> University of Wisconsin - Madison   </affiliation>::line_number::8
<address>  Madison, WI   </address>::line_number::9
<abstract>  Abstract. In this paper we examine preconditioning operators for regular elliptic  </abstract>::line_number::10
<abstract> systems of partial differential operators. We obtain general conditions under which the  </abstract>::line_number::11
<abstract> preconditioned systems are bounded. We also provide some useful guidelines for choosing  </abstract>::line_number::12
<abstract> left and right preconditioning operators for regular elliptic systems. The condition numbers  </abstract>::line_number::13
<abstract> of the discrete operators arising from these preconditioned operators are shown to be  </abstract>::line_number::14
<abstract> bounded independent of grid spacing. Several examples of the two-dimensional regular  </abstract>::line_number::15
<abstract> elliptic systems are discussed, including scalar elliptic operators and the Stokes operator  </abstract>::line_number::16
<abstract> with several different boundary conditions. Several preconditioners for these regular elliptic  </abstract>::line_number::17
<abstract> systems are presented and used in numerical experiments illustrating the theoretical results.   </abstract>::line_number::18
<keyword>  Key word. preconditioning, elliptic systems, numerical methods   </keyword>::line_number::19
<note>  AMS subject classifications. 65N06, 65N22   </note>::line_number::20
<intro>  1. Introduction.  </intro>::line_number::21

<title>  An Evaluation of Object Management System  </title>::line_number::0
<title> Architectures for Software Engineering Applications   </title>::line_number::1
<author>  Jayavel Shanmugasundaram, Barbara Staudt Lerner, Lori Clarke   </author>::line_number::2
<affiliation>  Department of Computer Science  </affiliation>::line_number::3
<affiliation> University of Massachusetts   </affiliation>::line_number::4
<address>  Amherst, MA 01003 USA   </address>::line_number::5
<phone>  +1 413 545 3787   </phone>::line_number::6
<email>  fshan, lerner, clarkeg@cs.umass.edu   </email>::line_number::7
<abstract>  ABSTRACT  </abstract>::line_number::8
<abstract> Software engineering applications require sophisticated  </abstract>::line_number::9
<abstract> object management system support for creating and  </abstract>::line_number::10
<abstract> manipulating software objects. One of the key issues for  </abstract>::line_number::11
<abstract> object management systems is distribution. Addressing this issue in the context of software engineering applications is particularly challenging because they have  </abstract>::line_number::12
<abstract> widely varying object access profiles. Two fundamental  </abstract>::line_number::13
<abstract> approaches to dealing with distribution are the object  </abstract>::line_number::14
<abstract> server architecture, where objects are shipped to the  </abstract>::line_number::15
<abstract> application program, and the operation server architecture, where operation requests are shipped to where the  </abstract>::line_number::16
<abstract> objects reside. We compare these architectures experimentally to determine the conditions under which each  </abstract>::line_number::17
<abstract> performs better.   </abstract>::line_number::18
<keyword>  KEYWORDS  </keyword>::line_number::19
<keyword> Distributed object management, experimental evaluation   </keyword>::line_number::20
<intro>  1 INTRODUCTION  </intro>::line_number::21

<title>  Moufang Quasigroups   </title>::line_number::0
<author>  Kenneth Kunen 1   </author>::line_number::1
<affiliation>  University of Wisconsin,   Madison, WI 53706, U.S.A.   </affiliation>::line_number::2
<email>  kunen@cs.wisc.edu   </email>::line_number::3
<date>  September 5, 1995   </date>::line_number::4
<abstract>  ABSTRACT  </abstract>::line_number::5
<abstract> Each of the Moufang identities in a quasigroup implies that the  </abstract>::line_number::6
<abstract> quasigroup is a loop.   </abstract>::line_number::7
<intro>  x1. Introduction.  </intro>::line_number::8

<title>  Fast and Accurate Flow-Insensitive Points-To Analysis   </title>::line_number::0
<author>  Marc Shapiro and Susan Horwitz   </author>::line_number::1
<affiliation>  Computer Sciences Department, University of Wisconsin-Madison   </affiliation>::line_number::2
<address>  1210 West Dayton Street, Madison, WI 53706 USA   </address>::line_number::3
<email>  Electronic mail: fmds, horwitzg@cs.wisc.edu   </email>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> In order to analyze a program that involves pointers, it  </abstract>::line_number::6
<abstract> is necessary to have (safe) information about what each  </abstract>::line_number::7
<abstract> pointer points to. There are many different approaches  </abstract>::line_number::8
<abstract> to computing points-to information. This paper addresses techniques for flow- and context-insensitive in-terprocedural analysis of stack-based storage.  </abstract>::line_number::9
<abstract> The paper makes two contributions to work in this  </abstract>::line_number::10
<abstract> area:  </abstract>::line_number::11
<abstract> * The first contribution is a set of experiments that  </abstract>::line_number::12
<abstract> explore the trade-offs between techniques previously defined by Lars Andersen and Bjarne Steens-gaard. The former has a cubic worst-case running  </abstract>::line_number::13
<abstract> time, while the latter is essentially linear. However, the former may be much more precise than  </abstract>::line_number::14
<abstract> the latter. We have found that in practice, Ander-sen's algorithm is consistently more precise than  </abstract>::line_number::15
<abstract> Steensgaard's. For small programs, there is very  </abstract>::line_number::16
<abstract> little difference in the times required by the two  </abstract>::line_number::17
<abstract> approaches; however, for larger programs, Ander-sen's algorithm can be much slower than Steens  </abstract>::line_number::18
<abstract> gaard's.  </abstract>::line_number::19
<abstract> * The second contribution is the definition of two  </abstract>::line_number::20
<abstract> new algorithms. The first algorithm can be "tuned"  </abstract>::line_number::21
<abstract> so that its worst-case time and space requirements,  </abstract>::line_number::22
<abstract> as well as its accuracy range from those of Steens-gaard to those of Andersen. We have experimented  </abstract>::line_number::23
<abstract> with several versions of this algorithm; one version  </abstract>::line_number::24
<abstract> provided a significant increase in accuracy over  </abstract>::line_number::25
<abstract> Steensgaard's algorithm, while keeping the running time within a factor of two.  </abstract>::line_number::26
<abstract> The second algorithm uses the first as a subroutine. Its worst-case time and space requirements  </abstract>::line_number::27
<abstract> are a factor of log N (where N is the number of  </abstract>::line_number::28
<abstract> variables in the program) worse than those of  </abstract>::line_number::29
<abstract> Steensgaard's algorithm. In practice, it appears to   </abstract>::line_number::30
<note>  This work was supported in part by the National Science Foundation under grant CCR-8958530, and by the Defense Advanced Research Projects Agency under ARPA Order No. 8856 (monitored by  </note>::line_number::31
<note> the Office of Naval Research under contract N00014-92-J-1937).   </note>::line_number::32
<abstract>  run about ten times slower than Steensgaard's algorithm; however it is significantly more accurate  </abstract>::line_number::33
<abstract> than Steensgaard's algorithm, and significantly  </abstract>::line_number::34
<abstract> faster than Andersen's algorithm on large  </abstract>::line_number::35
<abstract> programs.   </abstract>::line_number::36
<intro>  1 Introduction  </intro>::line_number::37

<title>  C**:  </title>::line_number::0
<title> A Large-Grain, Object-Oriented, Data-Parallel  </title>::line_number::1
<title> Programming Language   </title>::line_number::2
<author>  James R. Larus, Brad Richards, and Guhan Viswanathan 1   </author>::line_number::3
<affiliation>  Computer Sciences Department  </affiliation>::line_number::4
<affiliation> University of Wisconsin-Madison   </affiliation>::line_number::5
<address>  1210 West Dayton Street  </address>::line_number::6
<address> Madison, WI 53706 USA   </address>::line_number::7
<pubnum>  UW Technical Report #1126   </pubnum>::line_number::8
<date>  November 24, 1992   </date>::line_number::9
<note>  1 This work was supported by the National Science Foundation under grants CCR-9101035 and CDA  </note>::line_number::10
<note> 9024618.   </note>::line_number::11
<page>  +PAGE+  </page>::line_number::12

<title>  Storage Estimation for Multidimensional Aggregates in  </title>::line_number::0
<title> the Presence of Hierarchies    </title>::line_number::1
<author>  Amit Shukla Prasad M. Deshpande  </author>::line_number::2
<author> Jeffrey F. Naughton Karthikeyan Ramasamy   </author>::line_number::3
<email>  famit,pmd,naughton,karthikg@cs.wisc.edu   </email>::line_number::4
<affiliation>  Computer Sciences Department  </affiliation>::line_number::5
<affiliation> University of Wisconsin - Madison   </affiliation>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> To speed up multidimensional data analysis,  </abstract>::line_number::8
<abstract> database systems frequently precompute aggregates on some subsets of dimensions and  </abstract>::line_number::9
<abstract> their corresponding hierarchies. This improves  </abstract>::line_number::10
<abstract> query response time. However, the decision of  </abstract>::line_number::11
<abstract> what and how much to precompute is a difficult one. It is further complicated by the fact  </abstract>::line_number::12
<abstract> that precomputation in the presence of hierarchies can result in an unintuitively large increase in the amount of storage required by the  </abstract>::line_number::13
<abstract> database. Hence, it is interesting and useful  </abstract>::line_number::14
<abstract> to estimate the storage blowup that will result from a proposed set of precomputations  </abstract>::line_number::15
<abstract> without actually computing them. We propose  </abstract>::line_number::16
<abstract> three strategies for this problem: one based on  </abstract>::line_number::17
<abstract> sampling, one based on mathematical approximation, and one based on probabilistic counting. We investigate the accuracy of these algorithms in estimating the blowup for different  </abstract>::line_number::18
<abstract> data distributions and database schemas. The  </abstract>::line_number::19
<abstract> algorithm based upon probabilistic counting is  </abstract>::line_number::20
<abstract> particularly attractive, since it estimates the  </abstract>::line_number::21
<abstract> storage blowup to within provable error bounds  </abstract>::line_number::22
<abstract> while performing only a single scan of the data.   </abstract>::line_number::23
<note>  Work supported by an IBM CAS Fellowship, NSF grant IRI-9157357, and a grant from IBM under the University Partnership  </note>::line_number::24
<note> Program.  </note>::line_number::25
<note> Permission to copy without fee all or part of this material is  </note>::line_number::26
<note> granted provided that the copies are not made or distributed for  </note>::line_number::27
<note> direct commercial advantage, the VLDB copyright notice and  </note>::line_number::28
<note> the title of the publication and its date appear, and notice is  </note>::line_number::29
<note> given that copying is by permission of the Very Large Data Base  </note>::line_number::30
<note> Endowment. To copy otherwise, or to republish, requires a fee  </note>::line_number::31
<note> and/or special permission from the Endowment.  </note>::line_number::32
<note> Proceedings of the 22nd VLDB Conference  </note>::line_number::33
<note> Mumbai (Bombay), India, 1996   </note>::line_number::34
<intro>  1 Introduction  </intro>::line_number::35

<title>  Towards Effective and Efficient Free Space Management   </title>::line_number::0
<author>  Mark L. McAuliffe   </author>::line_number::1
<affiliation>  University of Wisconsin|Madison   </affiliation>::line_number::2
<email>  mcauliff@cs.wisc.edu   </email>::line_number::3
<author>  Michael J. Carey   </author>::line_number::4
<affiliation>  IBM Almaden Research Center   </affiliation>::line_number::5
<email>  carey@almaden.ibm.com   </email>::line_number::6
<author>  Marvin H. Solomon   </author>::line_number::7
<affiliation>  University of Wisconsin|Madison   </affiliation>::line_number::8
<email>  solomon@cs.wisc.edu   </email>::line_number::9
<abstract>  Abstract  </abstract>::line_number::10
<abstract> An important problem faced by many database management  </abstract>::line_number::11
<abstract> systems is the "online object placement problem"|the  </abstract>::line_number::12
<abstract> problem of choosing a disk page to hold a newly allocated  </abstract>::line_number::13
<abstract> object. In the absence of clustering criteria, the goal is  </abstract>::line_number::14
<abstract> to maximize storage utilization. For main-memory based  </abstract>::line_number::15
<abstract> systems, simple heuristics exist that provide reasonable  </abstract>::line_number::16
<abstract> space utilization in the worst case and excellent utilization  </abstract>::line_number::17
<abstract> in typical cases. However, the storage management problem  </abstract>::line_number::18
<abstract> for databases includes significant additional challenges, such  </abstract>::line_number::19
<abstract> as minimizing I/O traffic, coping with crash recovery, and  </abstract>::line_number::20
<abstract> gracefully integrating space management with locking and  </abstract>::line_number::21
<abstract> logging.  </abstract>::line_number::22
<abstract> We survey several object placement algorithms, including  </abstract>::line_number::23
<abstract> techniques that can be found in commercial and research  </abstract>::line_number::24
<abstract> database systems. We then present a new object placement  </abstract>::line_number::25
<abstract> algorithm that we have designed for use in Shore, an  </abstract>::line_number::26
<abstract> object-oriented database system under development at the  </abstract>::line_number::27
<abstract> University of Wisconsin|Madison. Finally, we present  </abstract>::line_number::28
<abstract> results from a series of experiments involving actual Shore  </abstract>::line_number::29
<abstract> implementations of some of these algorithms. Our results  </abstract>::line_number::30
<abstract> show that while current object placement algorithms have  </abstract>::line_number::31
<abstract> serious performance deficiencies, including excessive CPU  </abstract>::line_number::32
<abstract> or main memory overhead, I/O traffic, or poor disk  </abstract>::line_number::33
<abstract> utilization, our new algorithm consistently demonstrates  </abstract>::line_number::34
<abstract> excellent performance in all of these areas.   </abstract>::line_number::35
<intro>  1 Introduction  </intro>::line_number::36

<title>  Asking Questions to Minimize Errors   </title>::line_number::0
<author>  Nader H. Bshouty   </author>::line_number::1
<affiliation>  Department of Computer Science  </affiliation>::line_number::2
<affiliation> The University of Calgary   </affiliation>::line_number::3
<address>  2500 University Drive N.W.  </address>::line_number::4
<address> Calgary, Alberta, Canada T2N 1N4   </address>::line_number::5
<email>  bshouty@cpsc.ucalgary.ca   </email>::line_number::6
<author>  Sally A. Goldman   </author>::line_number::7
<affiliation>  Department of Computer Science  </affiliation>::line_number::8
<affiliation> Washington University   </affiliation>::line_number::9
<address>  St. Louis, MO 63130   </address>::line_number::10
<email>  sg@cs.wustl.edu   </email>::line_number::11
<author>  Thomas R. Hancock   </author>::line_number::12
<affiliation>  Siemens Corporate Research, Inc.   </affiliation>::line_number::13
<address>  755 College Road East  </address>::line_number::14
<address> Princeton, NJ 08540   </address>::line_number::15
<email>  hancock@learning.siemens.com   </email>::line_number::16
<author>  Sleiman Matar   </author>::line_number::17
<affiliation>  Department of Computer Science  </affiliation>::line_number::18
<affiliation> The University of Calgary   </affiliation>::line_number::19
<address>  2500 University Drive N.W.  </address>::line_number::20
<address> Calgary, Alberta, Canada T2N 1N4   </address>::line_number::21
<email>  sleiman@cpsc.ucalgary.ca   </email>::line_number::22
<date>  September 1993   </date>::line_number::23
<pubnum>  WUCS-93-23   </pubnum>::line_number::24
<abstract>  Abstract  </abstract>::line_number::25
<abstract> A number of efficient learning algorithms achieve exact identification of an unknown function  </abstract>::line_number::26
<abstract> from some class using membership and equivalence queries. Using a standard transformation  </abstract>::line_number::27
<abstract> such algorithms can easily be converted to on-line learning algorithms that use membership  </abstract>::line_number::28
<abstract> queries. Under such a transformation the number of equivalence queries made by the query  </abstract>::line_number::29
<abstract> algorithm directly corresponds to the number of mistakes made by the on-line algorithm. In  </abstract>::line_number::30
<abstract> this paper we consider several of the natural classes known to be learnable in this setting, and  </abstract>::line_number::31
<abstract> investigate the minimum number of equivalence queries with accompanying counterexamples  </abstract>::line_number::32
<abstract> (or equivalently the minimum number of mistakes in the on-line model) that can be made by a  </abstract>::line_number::33
<abstract> learning algorithm that makes a polynomial number of membership queries and uses polynomial  </abstract>::line_number::34
<abstract> computation time. We are able both to reduce the number of equivalence queries used by the  </abstract>::line_number::35
<abstract> previous algorithms and often to prove matching lower bounds. As an example, consider the  </abstract>::line_number::36
<abstract> class of DNF formulas over n variables with at most k = O(log n) terms. Previously, the  </abstract>::line_number::37
<abstract> algorithm of Blum and Rudich [BR92] provided the best known upper bound of 2 O(k) log n for  </abstract>::line_number::38
<abstract> the minimum number of equivalence queries needed for exact identification. We greatly improve  </abstract>::line_number::39
<abstract> on this upper bound showing that exactly k counterexamples are needed if the learner knows k a  </abstract>::line_number::40
<abstract> priori and exactly k +1 counterexamples are needed if the learner does not know k a priori. This  </abstract>::line_number::41
<abstract> exactly matches known lower bounds [BC92]. For many of our results we obtain a complete  </abstract>::line_number::42
<abstract> characterization of the tradeoff between the number of membership and equivalence queries  </abstract>::line_number::43
<abstract> needed for exact identification. The classes we consider here are monotone DNF formulas, Horn  </abstract>::line_number::44
<abstract> sentences, O(log n)-term DNF formulas, read-k sat-j DNF formulas, read-once formulas over  </abstract>::line_number::45
<abstract> various bases, and deterministic finite automata.   </abstract>::line_number::46
<page>  +PAGE+  </page>::line_number::47

<title>  Learning One-Dimensional Geometric Patterns  </title>::line_number::0
<title> Under One-Sided Random Misclassification  </title>::line_number::1
<title> Noise   </title>::line_number::2
<author>  Paul W. Goldberg    </author>::line_number::3
<address>  Department 1423   </address>::line_number::4
<affiliation>  Sandia National Laboratories,   MS 1110  </affiliation>::line_number::5
<affiliation> P.O. Box 5800  </affiliation>::line_number::6
<affiliation> Albuquerque, NM 87185-1110   </affiliation>::line_number::7
<email>  pwgoldb@cs.sandia.gov   </email>::line_number::8
<author>  Sally A. Goldman    </author>::line_number::9
<affiliation>  Dept. of Computer Science  </affiliation>::line_number::10
<affiliation> Washington University   </affiliation>::line_number::11
<address>  St. Louis, MO 63130   </address>::line_number::12
<email>  sg@cs.wustl.edu   </email>::line_number::13
<pubnum>  WUCS-94-01   </pubnum>::line_number::14
<date>  May 12, 1994   </date>::line_number::15
<note>  This research was performed while visiting Washington University. Currently supported by the  </note>::line_number::16
<note> U.S. Department of Energy under contract DE-AC04-76AL85000.  </note>::line_number::17
<note> Supported in part by NSF Grant CCR-9110108 and an NSF NYI Grant CCR-9357707.   </note>::line_number::18
<page>  +PAGE+  </page>::line_number::19

<title>  Optimal Solution of Off-line and On-line Generalized Caching   </title>::line_number::0
<author>  Saied Hosseini-Khayat and Jerome R. Cox, Jr.   </author>::line_number::1
<affiliation>  Washington University in St. Louis   </affiliation>::line_number::2
<abstract>  Abstract. Network traffic can be reduced significantly if caching is utilized effectively. As an effort  </abstract>::line_number::3
<abstract> in this direction we study the replacement problem  </abstract>::line_number::4
<abstract> that arises in caching of multimedia objects. The size  </abstract>::line_number::5
<abstract> of objects and the cost of cache misses are assumed  </abstract>::line_number::6
<abstract> non-uniform. The non-uniformity of size is inherent in multimedia objects, and the non-uniformity of  </abstract>::line_number::7
<abstract> cost is due to the non-uniformity of size and the fact  </abstract>::line_number::8
<abstract> that the objects are scattered throughout the network.  </abstract>::line_number::9
<abstract> Although a special case of this problem, i.e. the case  </abstract>::line_number::10
<abstract> of uniform size and cost, has been extensively studied, the general case needs a great deal of study. We  </abstract>::line_number::11
<abstract> present a dynamic programming method of optimally  </abstract>::line_number::12
<abstract> solving the off-line and on-line versions of this problem, and discuss the complexity of this method.   </abstract>::line_number::13
<keyword>  Key words: Generalized caching, network traffic,  </keyword>::line_number::14
<keyword> network caching, file caching, optimal replacement,  </keyword>::line_number::15
<keyword> replacement algorithm.   </keyword>::line_number::16
<intro>  I. Introduction  </intro>::line_number::17

<title>  Advantages of a Leveled Commitment  </title>::line_number::0
<title> Contracting Protocol   </title>::line_number::1
<author>  Tuomas W. Sandholm and Victor R. Lesser   </author>::line_number::2
<affiliation>  Computer Science Department  </affiliation>::line_number::3
<affiliation> University of Massachusetts at Amherst   </affiliation>::line_number::4
<pubnum>  CMPSCI Technical Report 95-72   </pubnum>::line_number::5
<date>  September 7, 1995   </date>::line_number::6
<page>  +PAGE+  </page>::line_number::7

<title>  Techniques for Developing and Measuring  </title>::line_number::0
<title> High-Performance Web Servers over ATM Networks   </title>::line_number::1
<author>  James C. Hu , Sumedh Mungee, Douglas C. Schmidt   </author>::line_number::2
<email>  fjxh,sumedh,schmidtg@cs.wustl.edu   </email>::line_number::3
<phone>  TEL: (314) 935-4215 FAX: (314) 935-7302   </phone>::line_number::4
<address>  Campus Box 1045/Bryan 509   </address>::line_number::5
<affiliation>  Washington University   </affiliation>::line_number::6
<address>  One Brookings Drive  </address>::line_number::7
<address> St. Louis, MO 63130, USA    </address>::line_number::8
<note>  This paper has been submitted to the INFOCOM '98 conference.   </note>::line_number::9
<abstract>  Abstract  </abstract>::line_number::10
<abstract> High-performance Web servers are essential to meet the growing demands of the Internet and large-scale intranets. Satisfying these demands requires a thorough understanding of key  </abstract>::line_number::11
<abstract> factors affecting Web server performance. This paper presents  </abstract>::line_number::12
<abstract> empirical analysis illustrating how dynamic and static adaptivity can enhance Web server performance. Two research  </abstract>::line_number::13
<abstract> contributions support this conclusion.  </abstract>::line_number::14
<abstract> First, the paper presents results from a comprehensive empirical study of Web servers (such as Apache, Netscape Enterprise, PHTTPD, Zeus, and JAWS) over high-speed ATM networks. This study illustrates their relative performance and  </abstract>::line_number::15
<abstract> precisely pinpoints the server design choices that cause performance bottlenecks. We found that once network and disk  </abstract>::line_number::16
<abstract> I/O overheads are reduced to negligible constant factors, the  </abstract>::line_number::17
<abstract> main determinants of Web server performance are its protocol processing path and concurrency strategy. Moreover, no  </abstract>::line_number::18
<abstract> single strategy performs optimally for all load conditions and  </abstract>::line_number::19
<abstract> traffic types.  </abstract>::line_number::20
<abstract> Second, we describe the design techniques and optimizations used to develop JAWS, our high-performance, adaptive  </abstract>::line_number::21
<abstract> Web server. JAWS is an object-oriented Web server that was  </abstract>::line_number::22
<abstract> explicitly designed to alleviate the performance bottlenecks  </abstract>::line_number::23
<abstract> we identified in existing Web servers. It consistently outperforms all other Web servers over ATM networks. The performance optimizations used in JAWS include adaptive pre-spawned threading, fixed headers, cached date processing,  </abstract>::line_number::24
<abstract> and file caching. In addition, JAWS uses a novel software architecture that substantially improves its portability and flex  </abstract>::line_number::25
<abstract> This work was funded in part by NSF grant NCR-9628218, Object Technologies International, Eastman Kodak, and Siemens MED.  </abstract>::line_number::26
<abstract> ibility, relative to other Web servers. Our empirical results  </abstract>::line_number::27
<abstract> illustrate that highly efficient communication software is not  </abstract>::line_number::28
<abstract> antithetical to highly flexible software.   </abstract>::line_number::29
<intro>  1 Introduction  </intro>::line_number::30

<title>  Measuring the Performance of Communication  </title>::line_number::0
<title> Middleware on High-Speed Networks   </title>::line_number::1
<author>  Aniruddha Gokhale and Douglas C. Schmidt   </author>::line_number::2
<email>  gokhale@cs.wustl.edu and schmidt@cs.wustl.edu   </email>::line_number::3
<affiliation>  Department of Computer Science, Washington University   </affiliation>::line_number::4
<address>  St. Louis, MO 63130, USA   </address>::line_number::5
<note>  An earlier version of this paper appeared in the Proceedings  </note>::line_number::6
<note> of the SIGCOMM Conference, 1996, Stanford University,  </note>::line_number::7
<note> August, 1996.   </note>::line_number::8
<abstract>  Abstract  </abstract>::line_number::9
<abstract> Conventional implementations of communication middle-ware (such as CORBA and traditional RPC toolkits) incur  </abstract>::line_number::10
<abstract> considerable overhead when used for performance-sensitive  </abstract>::line_number::11
<abstract> applications over high-speed networks. As gigabit networks  </abstract>::line_number::12
<abstract> become pervasive, inefficient middleware will force programmers to use lower-level mechanisms to achieve the necessary  </abstract>::line_number::13
<abstract> transfer rates. This is a serious problem for mission/life-critical applications (such as satellite surveillance and medical imaging).  </abstract>::line_number::14
<abstract> This paper compares the performance of several widely  </abstract>::line_number::15
<abstract> used communication middleware mechanisms on a high-speed ATM network. The middleware ranged from lower-level mechanisms (such as socket-based C interfaces and  </abstract>::line_number::16
<abstract> C++ wrappers for sockets) to higher-level mechanisms (such  </abstract>::line_number::17
<abstract> as RPC, hand-optimized RPC and two implementations of  </abstract>::line_number::18
<abstract> CORBA - Orbix 2.0.1 and ORBeline 2.0). These measurements reveal that the lower-level C and C++ implementations outperform the CORBA implementations significantly  </abstract>::line_number::19
<abstract> (the best CORBA throughput for remote transfer was roughly  </abstract>::line_number::20
<abstract> 75 to 80 percent of the best C/C++ throughput for sending scalar data types and only around 33 percent for sending structs containing binary fields), and the hand-optimized  </abstract>::line_number::21
<abstract> RPC code performs slightly better than the CORBA implementations. Our goal in precisely pinpointing the sources of  </abstract>::line_number::22
<abstract> overhead for communication middleware is to develop scalable and flexible CORBA implementations that can deliver  </abstract>::line_number::23
<abstract> gigabit data rates to applications.   </abstract>::line_number::24
<keyword>  Keywords: Communication middleware, distributed object computing, CORBA, high-speed networks.   </keyword>::line_number::25
<intro>  1 Introduction and Motivation  </intro>::line_number::26

<title>  MINIMIZING MEMORY CACHE USAGE FOR MULTIGRID  </title>::line_number::0
<title> ALGORITHMS IN TWO DIMENSIONS    </title>::line_number::1
<author>  CRAIG C. DOUGLAS    </author>::line_number::2
<abstract>  Abstract. Computers today rely heavily on good utilization of their cache memory subsystems.  </abstract>::line_number::3
<abstract> Compilers are optimized for business applications, not scientific computing ones, however. Automatic  </abstract>::line_number::4
<abstract> tiling of basic numerical algorithms is simply not provided by any compiler. Thus, absolutely terrible  </abstract>::line_number::5
<abstract> cache performance is normal for scientific computing applications.  </abstract>::line_number::6
<abstract> Multigrid algorithms combine several numerical algorithms into a more complicated algorithm.  </abstract>::line_number::7
<abstract> In this paper, an algorithm is derived that allows for data to pass through cache exactly once per  </abstract>::line_number::8
<abstract> multigrid level during a V cycle before the level changes. This is optimal cache usage for large  </abstract>::line_number::9
<abstract> problems that do not fit entirely in cache.  </abstract>::line_number::10
<abstract> The new algorithm would appear to be quite complicated to implement, leading to spaghetti  </abstract>::line_number::11
<abstract> coding. Actually, an efficient implementation of the algorithm requires a rigid, highly structured  </abstract>::line_number::12
<abstract> coding style. A coding example is given that is suitable for almost all common discretization methods.  </abstract>::line_number::13
<abstract> Numerical experiments are provided that show that the new algorithm is up to an integer factor  </abstract>::line_number::14
<abstract> faster than the traditional implementation method for common multigrid parameter choices.   </abstract>::line_number::15
<keyword>  Key words. multigrid, cache, threads, sparse matrix, iterative methods, domain decomposition,  </keyword>::line_number::16
<keyword> compiler optimization.   </keyword>::line_number::17
<note>  AMS subject classifications. 65N15, 65N10   </note>::line_number::18
<intro>  1. Introduction. Multigrid methods are widely known as the fastest methods  </intro>::line_number::19

<title>  THE DOMAIN REDUCTION METHOD: HIGH WAY REDUCTION  </title>::line_number::0
<title> IN THREE DIMENSIONS AND CONVERGENCE WITH INEXACT  </title>::line_number::1
<title> SOLVERS    </title>::line_number::2
<author>  CRAIG C. DOUGLAS AND JAN MANDEL    </author>::line_number::3
<abstract>  Abstract. We study a method for parallel solution of elliptic partial differential equations which  </abstract>::line_number::4
<abstract> decomposes the problem into a number of independent subproblems on subspaces of the underlying  </abstract>::line_number::5
<abstract> solution space. Using symmetries of the domain, we obtain up to 64 such subproblems for a 3  </abstract>::line_number::6
<abstract> dimensional cube and the method reduces to a direct solver. In the general case, or when the  </abstract>::line_number::7
<abstract> subproblems are solved only approximately, the method becomes an iterative method or can be used  </abstract>::line_number::8
<abstract> as a preconditioner. Bounds on the resulting convergence factors and condition numbers are given.   </abstract>::line_number::9
<intro>  1. Introduction. In this paper, we approximate the solution to the elliptic  </intro>::line_number::10

<title>  GEMMW: A PORTABLE LEVEL 3 BLAS WINOGRAD VARIANT OF  </title>::line_number::0
<title> STRASSEN'S MATRIX-MATRIX MULTIPLY ALGORITHM    </title>::line_number::1
<author>  CRAIG C. DOUGLAS , MICHAEL HEROUX , GORDON SLISHMAN x AND ROGER M.  </author>::line_number::2
<author> SMITH -   </author>::line_number::3
<abstract>  Abstract. Matrix-matrix multiplication is normally computed using one of the BLAS or a  </abstract>::line_number::4
<abstract> reinvention of part of the BLAS. Unfortunately, the BLAS were designed with small matrices in  </abstract>::line_number::5
<abstract> mind. When huge, well conditioned matrices are multiplied together, the BLAS perform like the  </abstract>::line_number::6
<abstract> blahs, even on vector machines. For matrices where the coefficients are well conditioned, Winograd's  </abstract>::line_number::7
<abstract> variant of Strassen's algorithm offers some relief, but is rarely available in a quality form on most  </abstract>::line_number::8
<abstract> computers. We reconsider this method and offer a highly portable solution based on the Level 3  </abstract>::line_number::9
<abstract> BLAS interface.   </abstract>::line_number::10
<keyword>  Key Words. Level 3 BLAS, matrix multiplication, Winograd's variant of Strassen's algorithm,  </keyword>::line_number::11
<keyword> multilevel algorithms  </keyword>::line_number::12
<keyword> AMS(MOS) subject classification. Numerical Analysis: Numerical Linear Algebra   </keyword>::line_number::13
<intro>  1. Preliminaries. Matrix-matrix multiplication is a very basic computer oper  </intro>::line_number::14

<affiliation>  Yale University  </affiliation>::line_number::0
<affiliation> Department of Computer Science   </affiliation>::line_number::1
<title>  Dynamic Fault Diagnosis   </title>::line_number::2
<author>  William Hurwood   </author>::line_number::3
<pubnum>  YALEU/DCS/TR-1056   </pubnum>::line_number::4
<date>  December 1994   </date>::line_number::5
<page>  +PAGE+  </page>::line_number::6

<title>  Constructing Logic Programs with  </title>::line_number::0
<title> Higher-Order Predicates 1   </title>::line_number::1
<author>  Jtrgen Fischer Nilsson   </author>::line_number::2
<affiliation>  Department of Computer Science  </affiliation>::line_number::3
<affiliation> Technical University of Denmark   </affiliation>::line_number::4
<author>  Andreas Hamfelt   </author>::line_number::5
<affiliation>  Computing Science Department  </affiliation>::line_number::6
<affiliation> Uppsala University   </affiliation>::line_number::7
<abstract>  Abstract: This paper proposes a logic programming approach based on the  </abstract>::line_number::8
<abstract> application of a system of higher-order predicates put at disposal within ordinary logic programming languages such as prolog. These higher-order  </abstract>::line_number::9
<abstract> predicates parallel the higher-order functionals or combinators which form an  </abstract>::line_number::10
<abstract> established part of contemporary functional programming methodology.  </abstract>::line_number::11
<abstract> The suggested toolbox of higher-order predicates for composing logic programs  </abstract>::line_number::12
<abstract> is derived from one universal higher-order predicate. They take the form of  </abstract>::line_number::13
<abstract> recursion operators (in particular for expressing recursion along lists) intended  </abstract>::line_number::14
<abstract> to cover all commonly occurring recursion schemes in logic programming practice. Their theoretical sufficiency is proved and their practical adequacy is  </abstract>::line_number::15
<abstract> argued through examples.  </abstract>::line_number::16
<abstract> The recursion operators, denoting higher-order relations rather than functions, are brought about straightforwardly through a well-known metalogic  </abstract>::line_number::17
<abstract> programming technique, rendering superfluous the need for special higher-order unification mechanisms.   </abstract>::line_number::18
<keyword>  Keywords: Relational higher-order and metalogic programming. Logic program recursion schemes. Declarative logic programming methodology.   </keyword>::line_number::19
<note>  Perche nessuna cosa si puo amare ne odiare,  </note>::line_number::20
<note> se prima no si a cognitio di quella.  </note>::line_number::21
<note> - Leonardo da Vinci, Notebooks   </note>::line_number::22
<intro>  1 Introduction: Background and Ob jectives  </intro>::line_number::23

<title>  Facilitating Worst-Case Execution Times Analysis for Optimized Code   </title>::line_number::0
<author>  Jakob Engblom 1 Andreas Ermedahl 1 Peter Altenbernd 2   </author>::line_number::1
<email>  1 fjakob,ebbeg@docs.uu.se,   Department of Computer Systems (DoCS),  </email>::line_number::2
<address> Uppsala University,   P.O. Box 325, S-751 05 Uppsala, Sweden,   Fax: +46-(0)18-550225   </address>::line_number::3
<email>  2 peter@c-lab.de,   C-LAB,   D-33094 Paderborn, Germany    </email>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> In this paper we present co-transformation, a novel approach to the mapping of execution information from the  </abstract>::line_number::6
<abstract> source code of a program to the object code for the purpose of worst-case execution time (WCET) analysis. Our  </abstract>::line_number::7
<abstract> approach is designed to handle the problems introduced by  </abstract>::line_number::8
<abstract> optimizing compilers, i.e. that the structure of the object  </abstract>::line_number::9
<abstract> code is very different from the structure of the source code.  </abstract>::line_number::10
<abstract> The co-transformer allows us to keep track of how different compiler transformations, including optimizations, influence the execution time of a program. This allows us to  </abstract>::line_number::11
<abstract> statically calculate the execution time of a program at the  </abstract>::line_number::12
<abstract> object code level, using information about the program execution obtained at the source code level.   </abstract>::line_number::13
<intro>  1. Introduction  </intro>::line_number::14

<title>  Experience with MPI: 'Converting  </title>::line_number::0
<title> pvmmake to mpimake under LAM'  </title>::line_number::1
<title> and 'MPI and Parallel Genetic  </title>::line_number::2
<title> Programming'   </title>::line_number::3
<author>  Judith Ellen Devaney   </author>::line_number::4
<affiliation>  NIST   </affiliation>::line_number::5
<email>  jdevaney@nist.gov   </email>::line_number::6
<date>  June 1995   </date>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> This looks at the issues which arose in porting the pvmmake utility  </abstract>::line_number::9
<abstract> from PVM to MPI. Pvmmake is a PVM application which allows  </abstract>::line_number::10
<abstract> a user to send files, execute commands, and receive results from a  </abstract>::line_number::11
<abstract> single machine on any machine in the virtual machine. Its actions are  </abstract>::line_number::12
<abstract> controlled by the contents of a configuration file. Its most common  </abstract>::line_number::13
<abstract> use is to enable management of the development of a parallel program  </abstract>::line_number::14
<abstract> in a heterogeneous environment. A utility with the same features,  </abstract>::line_number::15
<abstract> mpimake, was coded up to run under LAM.  </abstract>::line_number::16
<abstract> Genetic programming is an algorithm which evolves an algorithm  </abstract>::line_number::17
<abstract> in the form of a program to solve your input problem. The implementation under MPI requires the transfer of dynamic data structures  </abstract>::line_number::18
<abstract> such as lists and trees. This paper discusses the match between the  </abstract>::line_number::19
<abstract> requirements of this algorithm and the datatype feature in MPI. A  </abstract>::line_number::20
<abstract> new library, MPI DataStruct is being developed which can transfer  </abstract>::line_number::21
<abstract> dynamic data structures, created with pointers, without intervention  </abstract>::line_number::22
<abstract> by the user.   </abstract>::line_number::23
<page>  +PAGE+  </page>::line_number::24

<title>  An Object-Oriented Approach to Interoperation of  </title>::line_number::0
<title> Heterogeneous Information Sources   </title>::line_number::1
<author>  Ling Liu 1 and Calton Pu 2   </author>::line_number::2
<affiliation>  1 University of Alberta,   Edmonton, Alberta T6G 2H1 Canada   </affiliation>::line_number::3
<email>  email: lingliu@cs.ualberta.ca   </email>::line_number::4
<affiliation>  2 Oregon Graduate Institute,   Portland, Oregon 97291-1000 USA   </affiliation>::line_number::5
<email>  email: calton@cse.ogi.edu   </email>::line_number::6
<abstract>  Abstract. In the modern Internet environment, various types of  </abstract>::line_number::7
<abstract> data sources have become accessible, including multimedia data and web  </abstract>::line_number::8
<abstract> pages. Some of the fundamental assumptions in traditional databases,  </abstract>::line_number::9
<abstract> such as the existence of a global schema and data consistency maintained  </abstract>::line_number::10
<abstract> by a Data Base Administrator, are no longer true in many of the new  </abstract>::line_number::11
<abstract> data sources. We outline the DIOM [LP95b] object-oriented approach  </abstract>::line_number::12
<abstract> to build interoperable heterogeneous information systems despite the  </abstract>::line_number::13
<abstract> absence of global schema and the presence of data inconsistency. We describe the metadata catalog management component of DIOM, a key service in the support for interoperation among heterogeneous information  </abstract>::line_number::14
<abstract> sources. To support a flexible and customizable conection between information consumers and information producers, DIOM metadata catalog  </abstract>::line_number::15
<abstract> development utilizes the adaptive specification mechanisms, provided in  </abstract>::line_number::16
<abstract> DIOM interface description language, for explicit description of information consumers' domain query requirements and for object-oriented  </abstract>::line_number::17
<abstract> abstractions of information producers' information sources.   </abstract>::line_number::18
<intro>  1 Introduction  </intro>::line_number::19

<title>  Microkernel Operating System Architecture and Mach   </title>::line_number::0
<author>  David L. Black David B. Golub Daniel P. Julin Richard F. Rashid  </author>::line_number::1
<author> Richard P. Draves Randall W. Dean Alessandro Forin Joseph Barrera  </author>::line_number::2
<author> Hideyuki Tokuda Gerald Malan David Bohman    </author>::line_number::3
<note>  DRAFT of   June 16, 1991   </note>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> Modular architectures based on a microkernel are suitable bases for the design and implementation  </abstract>::line_number::6
<abstract> of operating systems. Prototype systems employing microkernel architectures are achieving the levels of  </abstract>::line_number::7
<abstract> functionality and performance expected and required of commercial products. Researchers at Carnegie  </abstract>::line_number::8
<abstract> Mellon University, the Open Software Foundation, and other sites are investigating implementations of a  </abstract>::line_number::9
<abstract> number of operating systems (e.g., Unix 1 , MS-DOS 2 ) that use the Mach microkernel. This paper describes  </abstract>::line_number::10
<abstract> the Mach microkernel, its use to support implementations of other operating systems, and the status of these  </abstract>::line_number::11
<abstract> efforts.   </abstract>::line_number::12
<intro>  1 Introduction  </intro>::line_number::13

<title>  Defining and Measuring Conflicts  </title>::line_number::0
<title> in Optimistic Replication    </title>::line_number::1
<author>  John Heidemann Ashvin Goel Gerald Popek   </author>::line_number::2
<affiliation>  University of California, Los Angeles   </affiliation>::line_number::3
<pubnum>  Technical report UCLA-CSD-950033   </pubnum>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> Optimistic replication is often viewed as essential for  </abstract>::line_number::6
<abstract> large scale systems and for supporting mobile computing. In optimistic replication, updates can be made concurrently to different file replicas, resulting in multiple  </abstract>::line_number::7
<abstract> versions of the file. To recover from these conflicting  </abstract>::line_number::8
<abstract> updates, after-the fact conflict resolution actions are  </abstract>::line_number::9
<abstract> required to recombine multiple versions into one. This  </abstract>::line_number::10
<abstract> paper defines these concepts and discusses approaches  </abstract>::line_number::11
<abstract> to measure them in optimistically replicated systems.  </abstract>::line_number::12
<abstract> Measurement of the number of conflicting updates  </abstract>::line_number::13
<abstract> and conflict resolution is important to judge the practicality of optimistic replication. An environment  </abstract>::line_number::14
<abstract> where conflicting updates are frequent will not be attractive since users cannot assume they have up-to-date  </abstract>::line_number::15
<abstract> data. Although many conflicts can be automatically  </abstract>::line_number::16
<abstract> resolved, some conflicts require user intervention; such  </abstract>::line_number::17
<abstract> conflicts cannot be too common. This paper shows an  </abstract>::line_number::18
<abstract> approach to measure the number of conflicting updates.  </abstract>::line_number::19
<abstract> From this measurement we derive the actual amount of  </abstract>::line_number::20
<abstract> work done by the user or system to resolve conflicts  </abstract>::line_number::21
<abstract> and the minimum amount of work required to resolve  </abstract>::line_number::22
<abstract> conflicts.   </abstract>::line_number::23
<intro>  1 Introduction  </intro>::line_number::24

<title>  Weak and Strong Beta Normalisations  </title>::line_number::0
<title> in Typed -Calculi   </title>::line_number::1
<author>  Hongwei Xi   </author>::line_number::2
<affiliation>  Department of Mathematical Sciences  </affiliation>::line_number::3
<affiliation> Carnegie Mellon University   </affiliation>::line_number::4
<address>  Pittsburgh, PA 15213, USA   </address>::line_number::5
<abstract>  Abstract. We present a technique to study relations between weak and  </abstract>::line_number::6
<abstract> strong fi-normalisations in various typed -calculi. We first introduce a  </abstract>::line_number::7
<abstract> translation which translates a -term into a I-term, and show that a  </abstract>::line_number::8
<abstract> -term is strongly fi-normalisable if and only if its translation is weakly  </abstract>::line_number::9
<abstract> fi-normalisable. We then prove that the translation preserves typability  </abstract>::line_number::10
<abstract> of -terms in various typed -calculi. This enables us to establish the  </abstract>::line_number::11
<abstract> equivalence between weak and strong fi-normalisations in these typed  </abstract>::line_number::12
<abstract> -calculi. This translation can deal with Curry typing as well as Church  </abstract>::line_number::13
<abstract> typing, strengthening some recent closely related results. This may bring  </abstract>::line_number::14
<abstract> some insights into answering whether weak and strong fi-normalisations  </abstract>::line_number::15
<abstract> in all pure type systems are equivalent.   </abstract>::line_number::16
<intro>  1 Introduction  </intro>::line_number::17

<note>  This research is partially supported by DARPA grant N00014-94-1-0845, DARPA contract F19628--95-C-0193, NSF grant CCR-9224375, and grants from Hewlett-Packard, Intel and Tektronix.   </note>::line_number::0
<title>  Predictable File Access Latency for   </title>::line_number::1
<title> Multimedia   </title>::line_number::2
<author>  D. Revel, C. Cowan, D. McNamee, C. Pu, and J. Walpole   </author>::line_number::3
<affiliation>  Department of Computer Science and Engineering  </affiliation>::line_number::4
<affiliation> Oregon Graduate Institute of Science & Technology   </affiliation>::line_number::5
<address>  20000 N.W. Walker Rd., P.O. Box 91000  </address>::line_number::6
<address> Portland, OR 97291-1000   </address>::line_number::7
<phone>  (503) 690-1121   </phone>::line_number::8
<email>  revel,crispin,dylan,calton,walpole-@cse.ogi.edu   </email>::line_number::9
<abstract>  Abstract  </abstract>::line_number::10
<abstract> Multimedia applications are sensitive to I/O latency and jitter when accessing   </abstract>::line_number::11
<abstract> data in secondary storage. Transparent adaptive prefetching (TAP) uses software   </abstract>::line_number::12
<abstract> feedback to provide multimedia applications with file system quality of service   </abstract>::line_number::13
<abstract> (QoS) guarantees. We are investigating how QoS requirements can be communicated and how they can be met by adaptive resource management. A preliminary test of adaptive prefetching is presented.   </abstract>::line_number::14
<keyword>  Keywords  </keyword>::line_number::15
<keyword> QoS, adaptive, multimedia, prefetching   </keyword>::line_number::16
<intro>  1 INTRODUCTION  </intro>::line_number::17

<title>  Realistic Parsing:  </title>::line_number::0
<title> Practical Solutions of Difficult Problems   </title>::line_number::1
<author>  SYLVAIN DELISLE a & STAN SZPAKOWICZ b   </author>::line_number::2
<affiliation>  a Dpartement de mathmatiques et dinformatique  </affiliation>::line_number::3
<affiliation> Universit du Qubec Trois-Rivires   </affiliation>::line_number::4
<address>  Trois-Rivires, Qubec, Canada G9A 5H7   </address>::line_number::5
<email>  email: Sylvain_Delisle@uqtr.uquebec.ca,   phone +1 819 376 5125; fax +1 819 376 5185   </email>::line_number::6
<affiliation>  b Department of Computer Science  </affiliation>::line_number::7
<affiliation> University of Ottawa   </affiliation>::line_number::8
<address>  Ottawa, Ontario, Canada K1N 6N5   </address>::line_number::9
<email>  email: szpak@csi.uottawa.ca,   phone +1 613 562 5800 ext. 6687; fax +1 613 562 5187   </email>::line_number::10
<abstract>  Abstract  </abstract>::line_number::11
<abstract> This paper describes work on the linguistic  </abstract>::line_number::12
<abstract> analysis of texts within a project devoted to  </abstract>::line_number::13
<abstract> knowledge acquisition from text. We focus  </abstract>::line_number::14
<abstract> on syntactic processing and present some  </abstract>::line_number::15
<abstract> key elements of the projects parser that  </abstract>::line_number::16
<abstract> allow it to deal successfully with technical  </abstract>::line_number::17
<abstract> texts. The parser is fully implemented and  </abstract>::line_number::18
<abstract> tested on a variety of real texts;  </abstract>::line_number::19
<abstract> improvements and enhancements are in  </abstract>::line_number::20
<abstract> progress. Because our knowledge acquisition  </abstract>::line_number::21
<abstract> method assumes no a priori model of the  </abstract>::line_number::22
<abstract> domain of the source text, the parser relies  </abstract>::line_number::23
<abstract> as much as possible on lexical and syntactic  </abstract>::line_number::24
<abstract> clues. That is why it strives for full  </abstract>::line_number::25
<abstract> syntactic analysis rather than some form of  </abstract>::line_number::26
<abstract> text skimming. We present a practical  </abstract>::line_number::27
<abstract> approach to four acknowledged difficult  </abstract>::line_number::28
<abstract> problems which to date have no generally  </abstract>::line_number::29
<abstract> acceptable answers: phrase attachment; time  </abstract>::line_number::30
<abstract> constraints for problematic input (how to  </abstract>::line_number::31
<abstract> avoid long and unproductive computation);  </abstract>::line_number::32
<abstract> parsing conjoined structures (how to  </abstract>::line_number::33
<abstract> preserve broad coverage without losing  </abstract>::line_number::34
<abstract> control of the parsing process); and the  </abstract>::line_number::35
<abstract> treatment of fragmentary input or fragments  </abstract>::line_number::36
<abstract> that are a byproduct of a fallback parsing  </abstract>::line_number::37
<abstract> strategy. We review recent related work and  </abstract>::line_number::38
<abstract> conclude by listing several future work  </abstract>::line_number::39
<abstract> items.   </abstract>::line_number::40
<keyword>  Key Words  </keyword>::line_number::41
<keyword> Text processing, knowledge acquisition from  </keyword>::line_number::42
<keyword> text, broad-coverage parsing, parsing conjoined  </keyword>::line_number::43
<keyword> structures.   </keyword>::line_number::44
<intro>  1. Introduction  </intro>::line_number::45

<title>  Verifying a Self-Stabilizing Mutual Exclusion Algorithm   </title>::line_number::0
<note>  To Appear in the Proceedings of PROCOMET'98   </note>::line_number::1
<author>  Shaz Qadeer   </author>::line_number::2
<affiliation>  Department of EECS  </affiliation>::line_number::3
<affiliation> University of California at Berkeley   </affiliation>::line_number::4
<address>  Berkeley CA 94720   </address>::line_number::5
<phone>  Phone: (510)642-1490   </phone>::line_number::6
<email>  shaz@eecs.berkeley.edu   </email>::line_number::7
<author>  Natarajan Shankar   </author>::line_number::8
<affiliation>  Computer Science Laboratory  </affiliation>::line_number::9
<affiliation> SRI International   </affiliation>::line_number::10
<address>  Menlo Park CA 94025   </address>::line_number::11
<phone>  Phone: (415)859-5272   </phone>::line_number::12
<email>  shankar@csl.sri.com   </email>::line_number::13
<abstract>  Abstract  </abstract>::line_number::14
<abstract> We present a detailed description of a machine-assisted verification of an algorithm  </abstract>::line_number::15
<abstract> for self-stabilizing mutual exclusion that is due to Dijkstra [Dij74]. This verification was  </abstract>::line_number::16
<abstract> constructed using PVS. We compare the mechanical verification to the informal proof  </abstract>::line_number::17
<abstract> sketch on which it is based. This comparison yields several observations regarding the  </abstract>::line_number::18
<abstract> challenges of formalizing and mechanically verifying distributed algorithms in general.   </abstract>::line_number::19
<intro>  1 Introduction  </intro>::line_number::20

<title>  Handling Infeasible Specifications of Cryptographic Protocols   </title>::line_number::0
<author>  Li Gong   </author>::line_number::1
<affiliation>  ORA Corporation Cornell University   </affiliation>::line_number::2
<address>  301A Dates Drive    Dept. of Computer Science   </address>::line_number::3
<address>   Ithaca, NY 14850 Ithaca, NY 14853    </address>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> In the verification of cryptographic protocols along the  </abstract>::line_number::6
<abstract> approach of the logic for authentication by Burrows,  </abstract>::line_number::7
<abstract> Abadi, and Needham, it is possible to write a specification which does not faithfully represent the real world  </abstract>::line_number::8
<abstract> situation. Such a specification, though impossible or  </abstract>::line_number::9
<abstract> unreasonable to implement, can go undetected and be  </abstract>::line_number::10
<abstract> verified to be correct. It can also lead to logical statements that do not preserve causality, which in turn can  </abstract>::line_number::11
<abstract> have undesirable consequences. Such a specification,  </abstract>::line_number::12
<abstract> called an infeasible specification here, can be subtle and  </abstract>::line_number::13
<abstract> hard to locate. This note shows how the logic of cryptographic protocols by Gong, Needham, and Yahalom  </abstract>::line_number::14
<abstract> can be enhanced with a notion of eligibility to preserve  </abstract>::line_number::15
<abstract> causality of beliefs and detect infeasible specifications.  </abstract>::line_number::16
<abstract> It is conceivable that this technique can be adopted in  </abstract>::line_number::17
<abstract> other similar logics.   </abstract>::line_number::18
<intro>  1 Introduction  </intro>::line_number::19

<title>  Integrating Security in a Group Oriented Distributed System   </title>::line_number::0
<author>  Michael Reiter Kenneth Birman Li Gong   </author>::line_number::1
<affiliation>  Dept. of Computer Science Dept. of Computer Science ORA Corporation  </affiliation>::line_number::2
<address> Cornell University Cornell University   675 Massachusetts Ave.  </address>::line_number::3
<address> Ithaca, NY 14853 Ithaca, NY 14853 Cambridge, MA 02139   </address>::line_number::4
<email>  reiter@cs.cornell.edu ken@cs.cornell.edu li@cambridge.oracorp.com   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> A distributed security architecture is proposed for  </abstract>::line_number::7
<abstract> incorporation into group oriented distributed systems,  </abstract>::line_number::8
<abstract> and in particular, into the Isis distributed programming toolkit. The primary goal of the architecture is  </abstract>::line_number::9
<abstract> to make common group oriented abstractions robust  </abstract>::line_number::10
<abstract> in hostile settings, in order to facilitate the construction of high performance distributed applications that  </abstract>::line_number::11
<abstract> can tolerate both component failures and malicious attacks. These abstractions include process groups and  </abstract>::line_number::12
<abstract> causal group multicast. Moreover, a delegation and  </abstract>::line_number::13
<abstract> access control scheme is proposed for use in group  </abstract>::line_number::14
<abstract> oriented systems. The focus of the paper is the security architecture; particular cryptosystems and key  </abstract>::line_number::15
<abstract> exchange protocols are not emphasized.   </abstract>::line_number::16
<intro>  1 Introduction  </intro>::line_number::17

<title>  Abstract Datatypes in PVS   </title>::line_number::0
<author>  S. Owre N. Shankar   </author>::line_number::1
<affiliation>  Computer Science Laboratory  </affiliation>::line_number::2
<affiliation> SRI International   </affiliation>::line_number::3
<address>  Menlo Park CA 94025   </address>::line_number::4
<phone>  Phone: (415)859-5272   </phone>::line_number::5
<email>  fowre, shankarg@csl.sri.com   </email>::line_number::6
<web>  URL: http://www.csl.sri.com/sri-csl-fm.html   </web>::line_number::7
<note>  1 The development of PVS was funded by internal research funding from SRI International. Support for the preparation of this document came from the National Aeronautics and Space Administration Langley Research Center under Contract NAS1-18969. This report is a revised and updated  </note>::line_number::8

<title>  Toward a MAC policy framework   </title>::line_number::0
<author>  Xiaolei Qian Teresa F. Lunt   </author>::line_number::1
<affiliation>  SRI International ARPA/ITO   </affiliation>::line_number::2
<address>  333 Ravenswood Avenue 3701 North Fairfax Drive  </address>::line_number::3
<address> Menlo Park, CA 94025 Arlington, VA 22203   </address>::line_number::4
<email>  qian@csl.sri.com tlunt@arpa.mil   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> We propose a formal policy framework of MAC policies in multilevel relational databases.  </abstract>::line_number::7
<abstract> We identify the important components of such policies and their desirable properties. The  </abstract>::line_number::8
<abstract> framework provides a basis for systematically specifying such policies and characterizing  </abstract>::line_number::9
<abstract> their potential mismatches. Based on the framework, we compare and unify the MAC  </abstract>::line_number::10
<abstract> policies and policy components that are proposed in the literature or imposed in existing  </abstract>::line_number::11
<abstract> systems. Our framework could be used to capture and resolve MAC policy mismatches in  </abstract>::line_number::12
<abstract> the trusted interoperation of heterogeneous multilevel relational databases.   </abstract>::line_number::13
<keyword>  Keywords  </keyword>::line_number::14
<keyword> Heterogeneity, interoperation, mandatory access control, multilevel security, relational  </keyword>::line_number::15
<keyword> database, security policy   </keyword>::line_number::16
<intro>  1 INTRODUCTION  </intro>::line_number::17

<note>  IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING, 7(5), OCTOBER 1995 1   </note>::line_number::0
<title>  Enriching the Expressive Power of Security Labels   </title>::line_number::1
<author>  Li Gong and Xiaolei Qian   </author>::line_number::2
<abstract>  Abstract| Common security models such as Bell-LaPadula  </abstract>::line_number::3
<abstract> focus on the control of access to sensitive data but leave  </abstract>::line_number::4
<abstract> some important systems issues unspecified, such as the implementation of read-only objects, garbage collection, and  </abstract>::line_number::5
<abstract> object upgrade and downgrade paths. Consequently, different implementations of the same security model may have  </abstract>::line_number::6
<abstract> conflicting operational and security semantics. We propose  </abstract>::line_number::7
<abstract> the use of more expressive security labels for specifying these  </abstract>::line_number::8
<abstract> system issues within the security model, so that the semantics of a system design are precisely understood and are  </abstract>::line_number::9
<abstract> independent of implementation details.   </abstract>::line_number::10
<keyword>  Keywords| Data security, garbage collection, multilevel  </keyword>::line_number::11
<keyword> security, object label, read-only object.   </keyword>::line_number::12
<intro>  I. Introduction  </intro>::line_number::13

<title>  Using Linguistic Phenomena to Motivate a Set of Rhetorical  </title>::line_number::0
<title> Relations   </title>::line_number::1
<author>  Alistair Knott   </author>::line_number::2
<affiliation>  Department of Artificial Intelligence, University of Edinburgh   </affiliation>::line_number::3
<address>  80 South Bridge, Edinburgh EH1 1HN, Scotland   </address>::line_number::4
<email>  Email: A.Knott@ed.ac.uk   </email>::line_number::5
<author>  Robert Dale   </author>::line_number::6
<affiliation>  Human Communication Research Centre, University of Edinburgh   </affiliation>::line_number::7
<address>  2 Buccleuch Place, Edinburgh EH8 9LW, Scotland   </address>::line_number::8
<email>  Email: R.Dale@ed.ac.uk   </email>::line_number::9
<date>  May 5, 1993   </date>::line_number::10
<note>  Running head: Motivating Rhetorical Relations   </note>::line_number::11
<page>  +PAGE+  </page>::line_number::12

<title>  Indexing PROLOG Procedures into DAGs  </title>::line_number::0
<title> by Heuristic Classification   </title>::line_number::1
<author>  Michael Sintek   </author>::line_number::2
<affiliation>  DFKI   </affiliation>::line_number::3
<address>  Postfach 2080  </address>::line_number::4
<address> 67608 Kaiserslautern  </address>::line_number::5
<address> Germany   </address>::line_number::6
<date>  May 5, 1994   </date>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> This paper first gives an overview of standard PROLOG indexing and  </abstract>::line_number::9
<abstract> then shows, in a step-by-step manner, how it can be improved by slightly  </abstract>::line_number::10
<abstract> extending the WAM indexing instruction set to allow indexing on multiple  </abstract>::line_number::11
<abstract> arguments. Heuristics are described that overcome the difficulty of computing the indexing WAM code. In order to become independent from a  </abstract>::line_number::12
<abstract> concrete WAM instruction set, an abstract graphical representation based  </abstract>::line_number::13
<abstract> on DAGs (called DAXes) is introduced.  </abstract>::line_number::14
<abstract> The paper includes a COMMON LISP listing of the main heuristics  </abstract>::line_number::15
<abstract> implemented; the algorithms were developed for RELFUN, a relational-plus-functional language, but can easily be used in arbitrary PROLOG  </abstract>::line_number::16
<abstract> implementations.   </abstract>::line_number::17
<note>  The ideas described in this paper were first presented at the Workshop  </note>::line_number::18
<note> "Sprachen fur KI-Anwendungen, Konzepte - Methoden Implementierun-gen" 1992 in Bad Honnef [SS92]. This paper is part of a collaborative work  </note>::line_number::19
<note> together with Werner Stein [Ste92].   </note>::line_number::20
<page>  +PAGE+  </page>::line_number::21

<title>  A Relational-Functional Integration  </title>::line_number::0
<title> for Declarative Programming   </title>::line_number::1
<author>  Harold Boley   </author>::line_number::2
<affiliation>  DFKI   </affiliation>::line_number::3
<address>  Box 2080, 67608 Kaiserslautern, Germany   </address>::line_number::4
<email>  boley@informatik.uni-kl.de   </email>::line_number::5
<abstract>  Abstract. A relational-functional kernel language is introduced that  </abstract>::line_number::6
<abstract> integrates essential declarative constructs: logic variables and non-determinism from the relational paradigm with nested and higher-order operations from the functional paradigm. Operator definitions use  </abstract>::line_number::7
<abstract> `valued clauses', subsuming relational Horn clauses and functional  </abstract>::line_number::8
<abstract> (conditional or unconditional) directed equations. Their semantics complements the atoms in relational Herbrand models by `molecules', which  </abstract>::line_number::9
<abstract> pair functions, applied to argument terms, with returned-value terms.  </abstract>::line_number::10
<abstract> All abstract notions are illustrated by concrete declarative programs.   </abstract>::line_number::11
<intro>  1 Introduction  </intro>::line_number::12

<title>  Layer Reassignment for Antenna Effect  </title>::line_number::0
<title> Minimization in 3-Layer Channel Routing    </title>::line_number::1
<author>  Zhan Chen and Israel Koren   </author>::line_number::2
<affiliation>  Department of Electrical and Computer Engineering  </affiliation>::line_number::3
<address> University of Massachusetts,   Amherst, MA 01003   </address>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> As semiconductor technology enters the deep submicron era, reliability has  </abstract>::line_number::6
<abstract> become a major challenge in the design and manufacturing of next generation  </abstract>::line_number::7
<abstract> VLSI circuits. In this paper we focus on one reliability issue the antenna  </abstract>::line_number::8
<abstract> effect in the context of 3-layer channel routing. We first present an antenna effect model in 3-layer channel routing and, based on this, an antenna effect cost  </abstract>::line_number::9
<abstract> function is proposed. A layer reassignment approach is adopted to minimize this  </abstract>::line_number::10
<abstract> cost function and we show that the layer reassignment problem can be formulated as a network bipartitioning problem. Experimental results show that the  </abstract>::line_number::11
<abstract> antenna effect can be reduced considerably by applying the proposed technique.  </abstract>::line_number::12
<abstract> Compared with previous work, one advantage of our approach is that no extra  </abstract>::line_number::13
<abstract> channel area is required for antenna effect minimization. We show that layer  </abstract>::line_number::14
<abstract> reassignment technique can be used in yield-related critical area minimization  </abstract>::line_number::15
<abstract> in 3-layer channel routing as well. The trade-off between these two objectives is  </abstract>::line_number::16
<abstract> also presented.   </abstract>::line_number::17
<intro>  1: Introduction  </intro>::line_number::18

<title>  Crosstalk Minimization in Three-Layer  </title>::line_number::0
<title> HVH Channel Routing    </title>::line_number::1
<author>  Zhan Chen and Israel Koren   </author>::line_number::2
<affiliation>  Department of Electrical and Computer Engineering  </affiliation>::line_number::3
<address> University of Massachusetts,   Amherst, MA 01003, USA   </address>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> Crosstalk has become a major issue in VLSI design due to the high frequency, long  </abstract>::line_number::6
<abstract> interconnecting lines and small spacing between interconnects in today's integrated circuits.  </abstract>::line_number::7
<abstract> In this paper, we study the problem of crosstalk minimization in 3-layer HVH channel  </abstract>::line_number::8
<abstract> routing. A heuristic algorithm that combines layer reassignment and track reassignment  </abstract>::line_number::9
<abstract> is presented. This algorithm can iteratively modify the layout so that the crosstalk in the  </abstract>::line_number::10
<abstract> channel is minimized. Experimental results show that the proposed approach can reduce the  </abstract>::line_number::11
<abstract> crosstalk by an average of 16.4% on a set of benchmark examples.   </abstract>::line_number::12
<intro>  1: Introduction  </intro>::line_number::13

<title>  Optimal Routing Control: Game Theoretic Approach   </title>::line_number::0
<author>  Richard J. La, and Venkat Anantharam   </author>::line_number::1
<affiliation>  Department of Electrical Engineering and Computer Science  </affiliation>::line_number::2
<affiliation> University of California at Berkeley   </affiliation>::line_number::3
<email>  hyongla@eecs.berkeley.edu, ananth@eecs.berkeley.edu   </email>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> Communication networks shared by selfish users are  </abstract>::line_number::6
<abstract> considered and modeled as noncooperative repeated  </abstract>::line_number::7
<abstract> games. Each user is interested only in optimizing its  </abstract>::line_number::8
<abstract> own performance by controlling the routing of its load.  </abstract>::line_number::9
<abstract> We investigate the existence of a NEP that achieves  </abstract>::line_number::10
<abstract> the system-wide optimal cost. The existence of a NEP  </abstract>::line_number::11
<abstract> that not only achieves the system-wide optimal cost but  </abstract>::line_number::12
<abstract> also yields a cost for each user no greater than its stage  </abstract>::line_number::13
<abstract> game NEP cost is shown for two-node multiple link networks. It is shown that more general networks where  </abstract>::line_number::14
<abstract> all users have the same source-destination pair have  </abstract>::line_number::15
<abstract> a NEP that achieves the minimum total system cost  </abstract>::line_number::16
<abstract> under a mild technical condition. It is shown general  </abstract>::line_number::17
<abstract> networks with users having multiple source-destination  </abstract>::line_number::18
<abstract> pairs don't necessarily have such an NEP.   </abstract>::line_number::19
<intro>  1 Introduction  </intro>::line_number::20

<title>  The Common Randomness Capacity of a  </title>::line_number::0
<title> Pair of Independent Discrete Memoryless  </title>::line_number::1
<title> Channels    </title>::line_number::2
<author>  S. Venkatesan V. Anantharam zx   </author>::line_number::3
<date>  13 August 1995   </date>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> We study the following problem: two agents Alice and Bob are connected to each other by independent discrete memoryless channels. They  </abstract>::line_number::6
<abstract> wish to generate common randomness by communicating interactively over  </abstract>::line_number::7
<abstract> the two channels. Assuming that Alice and Bob are allowed access to  </abstract>::line_number::8
<abstract> independent external random sources at rates (in bits per step of communication) of H A and H B , respectively, we show that they can generate common randomness at a rate of max f min [H A + H(W jQ); I(P ; V )] +  </abstract>::line_number::9
<abstract> min [H B + H(V jP ); I(Q; W )] g bits per step. Here, V is the channel from  </abstract>::line_number::10
<abstract> Alice to Bob, and W is the channel from Bob to Alice. The maximum  </abstract>::line_number::11
<abstract> is over all probability distributions P and Q on the input alphabets of V  </abstract>::line_number::12
<abstract> and W respectively. We also prove a strong converse which establishes the  </abstract>::line_number::13
<abstract> above rate as the highest attainable in this situation.   </abstract>::line_number::14
<keyword>  Keywords: Common randomness capacity, generating randomness from  </keyword>::line_number::15
<keyword> noise, interactive communication.   </keyword>::line_number::16
<note>  Research supported by NSF IRI 9005849, IRI 9310670, NCR 9422513, and the AT&T  </note>::line_number::17
<note> Foundation.   </note>::line_number::18
<affiliation>  Cornell University and U.C. Berkeley.  </affiliation>::line_number::19
<affiliation> Univ. of California, Berkeley.   </affiliation>::line_number::20
<note>  x Address all correspondence to the second author:   570 Cory Hall, Dept. of EECS, U.C.  </note>::line_number::21
<note> Berkeley, Berkeley, CA 94720.   </note>::line_number::22
<page>  +PAGE+  </page>::line_number::23

<title>  TIME-FREQUENCY SIGNAL MODELS FOR MUSIC ANALYSIS,  </title>::line_number::0
<title> TRANSFORMATION, AND SYNTHESIS   </title>::line_number::1
<author>  Michael Goodwin Martin Vetterli   </author>::line_number::2
<affiliation>  Department of Electrical Engineering and Computer Science & Center for New Music and Audio Technologies  </affiliation>::line_number::3
<affiliation> University of California at Berkeley   </affiliation>::line_number::4
<abstract>  ABSTRACT  </abstract>::line_number::5
<abstract> In signal analysis-synthesis, the analysis derives a set of parameters that the synthesis uses to reconstruct the original  </abstract>::line_number::6
<abstract> signal. In musical applications, this reconstruction should  </abstract>::line_number::7
<abstract> be perceptually accurate, and the parameterization should  </abstract>::line_number::8
<abstract> allow for such desirable signal modifications as time-scaling,  </abstract>::line_number::9
<abstract> pitch-shifting, and cross-synthesis; the analysis parameters  </abstract>::line_number::10
<abstract> should correspond to a signal model that is flexible enough  </abstract>::line_number::11
<abstract> to allow these transformations. Sinusoidal modeling meets  </abstract>::line_number::12
<abstract> this flexibility requirement, but has difficulty representing  </abstract>::line_number::13
<abstract> some salient features of musical signals such as attack transients and noiselike processes. In this paper, sinusoidal  </abstract>::line_number::14
<abstract> modeling is reviewed and some variations are proposed to  </abstract>::line_number::15
<abstract> account for its shortcomings; also, wavelet-based representations of musical signals are considered.   </abstract>::line_number::16
<intro>  1. SIGNAL MODELING FOR MUSIC  </intro>::line_number::17

<title>  Reactive Modules   </title>::line_number::0
<author>  Rajeev Alur Thomas A. Henzinger    </author>::line_number::1
<abstract>  Abstract. We present a formal model for concurrent systems. The model represents  </abstract>::line_number::2
<abstract> synchronous and asynchronous components in a uniform framework that supports compositional (assume-guarantee) and hierarchical (stepwise-refinement) design and verification. While synchronous models are based on a notion of atomic computation step,  </abstract>::line_number::3
<abstract> and asynchronous models remove that notion by introducing stuttering, our model is  </abstract>::line_number::4
<abstract> based on a flexible notion of what constitutes a computation step: by applying an abstraction operator to a system, arbitrarily many consecutive steps can be collapsed into  </abstract>::line_number::5
<abstract> a single step. The abstraction operator, which may turn an asynchronous system into a  </abstract>::line_number::6
<abstract> synchronous one, allows us to describe systems at various levels of temporal detail. For  </abstract>::line_number::7
<abstract> describing systems at various levels of spatial detail, we use a hiding operator that may  </abstract>::line_number::8
<abstract> turn a synchronous system into an asynchronous one. We illustrate the model with diverse examples from synchronous circuits, asynchronous shared-memory programs, and  </abstract>::line_number::9
<abstract> synchronous message-passing protocols.   </abstract>::line_number::10
<intro>  1 Introduction  </intro>::line_number::11

<title>  Capacity, Mutual Information, and Coding  </title>::line_number::0
<title> for Finite-State Markov Channels   </title>::line_number::1
<author>  Andrea J. Goldsmith, Member, IEEE and Pravin P. Varaiya, Fellow, IEEE    </author>::line_number::2
<abstract>  Abstract  </abstract>::line_number::3
<abstract> The Finite-State Markov Channel (FSMC) is a discrete-time varying channel whose variation is determined by a finite-state Markov process. These channels have memory due to the  </abstract>::line_number::4
<abstract> Markov channel variation. We obtain the FSMC capacity as a function of the conditional channel  </abstract>::line_number::5
<abstract> state probability. We also show that for i.i.d. channel inputs, this conditional probability converges  </abstract>::line_number::6
<abstract> weakly, and the channel's mutual information is then a closed-form continuous function of the input  </abstract>::line_number::7
<abstract> distribution.  </abstract>::line_number::8
<abstract> We next consider coding for FSMCs. In general, the complexity of maximum-likelihood  </abstract>::line_number::9
<abstract> decoding grows exponentially with the channel memory length. Therefore, in practice, interleaving  </abstract>::line_number::10
<abstract> and memoryless channel codes are used. This technique results in some performance loss relative  </abstract>::line_number::11
<abstract> to the inherent capacity of channels with memory. We propose a maximum-likelihood decision-feedback decoder with complexity that is independent of the channel memory. We calculate the  </abstract>::line_number::12
<abstract> capacity and cutoff rate of our technique, and show that it preserves the capacity of certain FSMCs.  </abstract>::line_number::13
<abstract> We also compare the performance of the decision-feedback decoder with that of interleaving and  </abstract>::line_number::14
<abstract> memoryless channel coding on a fading channel with 4PSK modulation.   </abstract>::line_number::15
<keyword>  Index Terms: Finite-State Markov Channels, Capacity, Mutual Information, Decision-Feedback  </keyword>::line_number::16
<keyword> Maximum-Likelihood Decoding.   </keyword>::line_number::17
<note>  Work supported in part by an IBM graduate fellowship, and in part by the PATH program, Institute of Transportation Studies, University of California, Berkeley.  </note>::line_number::18
<note> A. Goldsmith is with the Department of Electrical Engineering, California Institute of Technology, Pasadena, CA  </note>::line_number::19
<note> 91125.  </note>::line_number::20
<note> P. Varaiya is with the Department of Electrical Engineering and Computer Science, University of California,  </note>::line_number::21
<note> Berkeley, CA 94720.   </note>::line_number::22
<page>  +PAGE+  </page>::line_number::23

<title>  What's Decidable about Hybrid Automata?   </title>::line_number::0
<author>  Thomas A. Henzinger 2 Peter W. Kopke 2 Anuj Puri 3 Pravin Varaiya 3   </author>::line_number::1
<abstract>  Abstract. Hybrid automata model systems with both  </abstract>::line_number::2
<abstract> digital and analog components, such as embedded control programs. Many verification tasks for such programs  </abstract>::line_number::3
<abstract> can be expressed as reachability problems for hybrid automata. By improving on previous decidability and undecidability results, we identify the precise boundary between decidability and undecidability of the reachability  </abstract>::line_number::4
<abstract> problem for hybrid automata.  </abstract>::line_number::5
<abstract> On the positive side, we give an (optimal) PSPACE  </abstract>::line_number::6
<abstract> reachability algorithm for the case of initialized rectangular automata, where all analog variables follow trajectories within piecewise-linear envelopes and are reinitialized  </abstract>::line_number::7
<abstract> whenever the envelope changes. Our algorithm is based  </abstract>::line_number::8
<abstract> on a translation of an initialized rectangular automaton  </abstract>::line_number::9
<abstract> into a timed automaton that defines the same timed language. The translation has practical significance for verification, because it guarantees the termination of symbolic  </abstract>::line_number::10
<abstract> procedures for the reachability analysis of initialized rectangular automata.  </abstract>::line_number::11
<abstract> On the negative side, we show that several slight generalizations of initialized rectangular automata lead to an  </abstract>::line_number::12
<abstract> undecidable reachability problem. In particular, we prove  </abstract>::line_number::13
<abstract> that the reachability problem is undecidable for timed automata with a single stopwatch.   </abstract>::line_number::14
<intro>  1 Introduction  </intro>::line_number::15

<title>  An Analysis of Geographical Push-Caching +L + </title>::line_number::0
<author>  James Gwertzman,   Microsoft Corporation   </author>::line_number::1
<author>  Margo Seltzer,   Harvard University   </author>::line_number::2
<abstract>  Abstract  </abstract>::line_number::3
<abstract> Most caching schemes in wide-area, distributed systems are client-initiated. Decisions of when and  </abstract>::line_number::4
<abstract> where to cache information are made without the benefit of the server's global knowledge of the usage  </abstract>::line_number::5
<abstract> patterns. In this paper, we present a new caching strategy: geographical push-caching. Using the server's  </abstract>::line_number::6
<abstract> global knowledge and a derived network topology, we distribute data to cooperating servers. The World  </abstract>::line_number::7
<abstract> Wide Web is an example of a wide-area system that will benefit from distance-sensitive caching, and we  </abstract>::line_number::8
<abstract> present an architecture that allows a Web server to autonomously replicate HTML pages. We use a trace-driven simulation to evaluate several competing caching strategies. Our results show that geographical  </abstract>::line_number::9
<abstract> push-caching reduces bandwidth consumption and sever load by the same amount as web proxy caching,  </abstract>::line_number::10
<abstract> but with a savings in global cache space of almost two orders of magnitude. More importantly, servers  </abstract>::line_number::11
<abstract> that wish to reduce Internet bandwidth consumption and their load can do so without waiting for web  </abstract>::line_number::12
<abstract> proxies to be implemented world-wide. Furthermore, geographical push-caching helps distribute server  </abstract>::line_number::13
<abstract> load for all web servers, not just the most popular as is the case with proxy caching.   </abstract>::line_number::14
<intro>  1 Introduction  </intro>::line_number::15

<note>  To appear in the 10th International Parallel Processing Symposium, April 1996. 1   </note>::line_number::0
<title>  Modeling the Communication Performance of the IBM SP2   </title>::line_number::1
<author>  Gheith A. Abandah Edward S. Davidson   </author>::line_number::2
<affiliation>  Advanced Computer Architecture Laboratory, Department of EECS  </affiliation>::line_number::3
<affiliation> University of Michigan   </affiliation>::line_number::4
<address>  1301 Beal Avenue, Ann Arbor, MI 48109-2122   </address>::line_number::5
<email>  gabandah,davidson@eecs.umich.edu   </email>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> The objective of this paper is to develop models that  </abstract>::line_number::8
<abstract> characterize the communication performance of a message-passing multicomputer by taking the IBM SP2 as a case  </abstract>::line_number::9
<abstract> study. The paper evaluates and models the three aspects  </abstract>::line_number::10
<abstract> of the communication performance: scheduling overhead,  </abstract>::line_number::11
<abstract> message-passing time, and synchronization overhead. Performance models are developed for the basic communication patterns, enabling the estimation of the communication  </abstract>::line_number::12
<abstract> times of a message-passing application. Such estimates facilitate activities such as application tuning, selection of the  </abstract>::line_number::13
<abstract> best available implementation technique, and performance  </abstract>::line_number::14
<abstract> comparisons among different multicomputers.   </abstract>::line_number::15
<intro>  1. Introduction  </intro>::line_number::16

<title>  Efficient Formulation for Optimal Modulo Schedulers   </title>::line_number::0
<author>  Alexandre E. Eichenberger Edward S. Davidson   </author>::line_number::1
<affiliation>  ECE Department EECS Department  </affiliation>::line_number::2
<affiliation> North Carolina State University University of Michigan   </affiliation>::line_number::3
<address>  Raleigh, NC 27695-7911 Ann Arbor, MI 48109-2122   </address>::line_number::4
<email>  alexe@eos.ncsu.edu davidson@eecs.umich.edu   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Modulo scheduling algorithms based on optimal  </abstract>::line_number::7
<abstract> solvers have been proposed to investigate and tune the  </abstract>::line_number::8
<abstract> performance of modulo scheduling heuristics. While  </abstract>::line_number::9
<abstract> recent advances have broadened the scope for which  </abstract>::line_number::10
<abstract> the optimal approach is applicable, this approach  </abstract>::line_number::11
<abstract> increasingly suffers from large execution times. In this  </abstract>::line_number::12
<abstract> paper, we propose a more efficient formulation of the  </abstract>::line_number::13
<abstract> modulo scheduling space that significantly decreases  </abstract>::line_number::14
<abstract> the execution time of solvers based on integer linear  </abstract>::line_number::15
<abstract> programs. For example, the total execution time is  </abstract>::line_number::16
<abstract> reduced by a factor of 8.6 when 782 loops from the  </abstract>::line_number::17
<abstract> Perfect Club, SPEC, and Livermore Fortran Kernels  </abstract>::line_number::18
<abstract> are scheduled for minimum register requirements using  </abstract>::line_number::19
<abstract> the more efficient formulation instead of the traditional  </abstract>::line_number::20
<abstract> formulation. Experimental evidence further indicates  </abstract>::line_number::21
<abstract> that significantly larger loops can be scheduled under  </abstract>::line_number::22
<abstract> realistic machine constraints.   </abstract>::line_number::23
<intro>  1 Introduction  </intro>::line_number::24

<title>  A Chromaticity Space for Specularity, Illumination  </title>::line_number::0
<title> Color- and Illumination Pose-Invariant 3-D Object  </title>::line_number::1
<title> Recognition   </title>::line_number::2
<author>  Daniel Berwick and Sang Wook Lee   </author>::line_number::3
<email>  (dberwick@umich.edu and swlee@umich.edu)   </email>::line_number::4
<affiliation>  Dept. of Electrical Enginnering and Computer Science  </affiliation>::line_number::5
<affiliation> University of Michigan   </affiliation>::line_number::6
<address>  Ann Arbor, MI 48104   </address>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> Most of the recent color recognition/indexing approaches concentrate on establishing invariance to illumination color to improve the utility of color recognition. However, other effects caused by illumination pose and specularity on three-dimensional  </abstract>::line_number::9
<abstract> object surfaces have not received notable attention. We present a chromaticity recognition method that discounts the effects of illumination pose, illumination color and  </abstract>::line_number::10
<abstract> specularity. It utilizes a chromaticity space based on log-ratio of sensor responses for  </abstract>::line_number::11
<abstract> illumination pose and color invariance. A model-based specularity detection/rejection  </abstract>::line_number::12
<abstract> algorithm can be used to improve the chromaticity recognition and illumination estimation for objects including specular reflections.   </abstract>::line_number::13
<page>  +PAGE+  </page>::line_number::14

<title>  A Scalable Key Distribution Hierarchy   </title>::line_number::0
<author>  Patrick McDaniel Sugih Jamin   </author>::line_number::1
<affiliation>  Electrical Engineering and Computer Science Department  </affiliation>::line_number::2
<affiliation> University of Michigan   </affiliation>::line_number::3
<address>  Ann Arbor, MI 48109-2122   </address>::line_number::4
<email>  fpdmcdan,jaming@eecs.umich.edu   </email>::line_number::5
<date>  April 13, 1998   </date>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> As the use of the Internet for electronic commerce, audio  </abstract>::line_number::8
<abstract> and video conferencing, and other applications with sensitive content grows, the need for secure services becomes  </abstract>::line_number::9
<abstract> critical. Central to the success of these services is the support for secure public key distribution. Although there are  </abstract>::line_number::10
<abstract> several existing services available for this purpose, they  </abstract>::line_number::11
<abstract> are not very scalable, either because they depend on a centralized server or rely on ad hoc trust relationships.  </abstract>::line_number::12
<abstract> In this paper, we present and examine a flexible approach to certificate distribution scalable to arbitrarily  </abstract>::line_number::13
<abstract> large networks. We propose a two level hierarchy where  </abstract>::line_number::14
<abstract> certificates can be independently authenticated by one or  </abstract>::line_number::15
<abstract> more peer authorities, called keyservers. Certificates for  </abstract>::line_number::16
<abstract> end-user and host entities are managed within local domains, called enterprises. By administering certificates  </abstract>::line_number::17
<abstract> close to the source, we reduce the load on the key servers  </abstract>::line_number::18
<abstract> and the effects of network topology changes. We describe  </abstract>::line_number::19
<abstract> the design of our system and present a preliminary performance analysis based on traces of present-day DNS requests.   </abstract>::line_number::20
<intro>  1 Introduction  </intro>::line_number::21

<note>  To Appear in AI Magazine,  </note>::line_number::0
<note> Summer/Fall 1994.   </note>::line_number::1
<title>  An Introduction to Least Commitment  </title>::line_number::2
<title> Planning   </title>::line_number::3
<author>  Daniel S. Weld 1   </author>::line_number::4
<affiliation>  Department of Computer Science and Engineering  </affiliation>::line_number::5
<affiliation> University of Washington   </affiliation>::line_number::6
<address>  Seattle, WA 98195   </address>::line_number::7
<email>  weld@cs.washington.edu   </email>::line_number::8
<abstract>  Abstract  </abstract>::line_number::9
<abstract> Recent developments have clarified the process of generating partially ordered, partially specified sequences of actions whose execution  </abstract>::line_number::10
<abstract> will achive an agent's goal. This paper summarizes a progression of  </abstract>::line_number::11
<abstract> least commitment planners, starting with one that handles the sim  </abstract>::line_number::12
<abstract> ple strips representation, and ending with one that manages actions  </abstract>::line_number::13
<abstract> with disjunctive precondition, conditional effects and universal quantification over dynamic universes. Along the way we explain how  </abstract>::line_number::14
<abstract> Chapman's formulation of the Modal Truth Criterion is misleading  </abstract>::line_number::15
<abstract> and why his NP-completeness result for reasoning about plans with  </abstract>::line_number::16
<abstract> conditional effects does not apply to our planner.   </abstract>::line_number::17
<note>  1 I thank Franz Amador, Tony Barrett, Darren Cronquist, Denise Draper, Ernie Davis,  </note>::line_number::18

<title>  A Novel Framework for Decentralized Supervisory Control with Communication   </title>::line_number::0
<author>  George Barrett   </author>::line_number::1
<email>  grbarret@eecs.umich.edu   </email>::line_number::2
<author>  Stephane Lafortune   </author>::line_number::3
<email>  stephane@eecs.umich.edu   </email>::line_number::4
<affiliation>  Department of Electrical Engineering and Computer Science  </affiliation>::line_number::5
<affiliation> The University of Michigan   </affiliation>::line_number::6
<address>  1301 Beal Avenue  </address>::line_number::7
<address> Ann Arbor, MI 48109-2122   </address>::line_number::8
<abstract>  ABSTRACT  </abstract>::line_number::9
<abstract> The decentralized control problem that we address in  </abstract>::line_number::10
<abstract> this paper is that of several communicating supervisory  </abstract>::line_number::11
<abstract> controllers, each with different information, working in  </abstract>::line_number::12
<abstract> concert to exactly achieve a given legal sublanguage of  </abstract>::line_number::13
<abstract> the uncontrolled system's language model. We present  </abstract>::line_number::14
<abstract> a novel information structure formalism for dealing with  </abstract>::line_number::15
<abstract> this class of problems. Preliminary results are presented  </abstract>::line_number::16
<abstract> which elucidate a fundamental concept in decentralized  </abstract>::line_number::17
<abstract> control problems: the importance of controllers anticipating future possible communications.   </abstract>::line_number::18
<intro>  1. INTRODUCTION  </intro>::line_number::19

<title>  MDARTS: A Multiprocessor Database Architecture for Real-Time  </title>::line_number::0
<title> Systems   </title>::line_number::1
<affiliation>  Real-Time Computing Laboratory  </affiliation>::line_number::2
<affiliation> Computer Science and Engineering Division  </affiliation>::line_number::3
<affiliation> Department of Electrical Engineering and Computer Science  </affiliation>::line_number::4
<affiliation> The University of Michigan   </affiliation>::line_number::5
<address>  Ann Arbor, Michigan 48109-2122   </address>::line_number::6
<phone>  (313) 763-0391   </phone>::line_number::7
<abstract>  ABSTRACT  </abstract>::line_number::8
<abstract> Some of the advanced real-time systems being proposed, such as the Next Generation Workstation/Machine  </abstract>::line_number::9
<abstract> Controller (NGC) for automated factories, require a built-in database to support concurrent data access and provide  </abstract>::line_number::10
<abstract> well-defined interfaces between software modules. However, conventional database systems do not provide the performance levels or response time guarantees needed by real-time applications. To address the need for high-performance  </abstract>::line_number::11
<abstract> real-time database systems, we propose to design, implement, and evaluate an object-oriented software system called  </abstract>::line_number::12
<abstract> Multiprocessor Database Architecture for Real-Time Systems (MDARTS). An important feature of MDARTS is that  </abstract>::line_number::13
<abstract> it supports explicit specification of real-time requirements and semantic constraints at an object-granularity level.  </abstract>::line_number::14
<abstract> The database examines these specifications at runtime during application initialization and dynamically adjusts  </abstract>::line_number::15
<abstract> its data management strategy accordingly to provide hard real-time guarantees. For maximum performance on  </abstract>::line_number::16
<abstract> shared-memory multiprocessors, MDARTS supports concurrent, direct, shared-memory data access. Prior real-time  </abstract>::line_number::17
<abstract> database systems do not support per-object dynamic configuration during initialization, and they either work only on  </abstract>::line_number::18
<abstract> uniprocessors or use relatively slow inter-process communication for all transactions. The unique design of MDARTS  </abstract>::line_number::19
<abstract> will support a transaction execution time two to three orders of magnitude faster than current real-time database  </abstract>::line_number::20
<abstract> systems for multiprocessors. For data access with less stringent timing constraints, MDARTS also supports remote  </abstract>::line_number::21
<abstract> transactions across networks and provides interfaces to external database systems. Once we have implemented the  </abstract>::line_number::22
<abstract> basic MDARTS architecture, we will demonstrate its capabilities by using it to develop distributed, open architecture  </abstract>::line_number::23
<abstract> controllers for actual manufacturing machine tools.   </abstract>::line_number::24
<page>  +PAGE+  </page>::line_number::25

<title>  Internet Routing Instability   </title>::line_number::0
<author>  Craig Labovitz, G. Robert Malan, and Farnam Jahanian   </author>::line_number::1
<affiliation>  University of Michigan  </affiliation>::line_number::2
<affiliation> Department of Electrical Engineering and Computer Science   </affiliation>::line_number::3
<address>  1301 Beal Ave.  </address>::line_number::4
<address> Ann Arbor, Michigan 48109-2122   </address>::line_number::5
<email>  flabovit, rmalan, farnamg@eecs.umich.edu   </email>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> This paper examines the network inter-domain routing information exchanged between backbone service providers at  </abstract>::line_number::8
<abstract> the major U.S. public Internet exchange points. Internet  </abstract>::line_number::9
<abstract> routing instability, or the rapid fluctuation of network reach-ability information, is an important problem currently facing the Internet engineering community. High levels of network instability can lead to packet loss, increased network  </abstract>::line_number::10
<abstract> latency and time to convergence. At the extreme, high levels of routing instability have lead to the loss of internal  </abstract>::line_number::11
<abstract> connectivity in wide-area, national networks. In this paper,  </abstract>::line_number::12
<abstract> we describe several unexpected trends in routing instability,  </abstract>::line_number::13
<abstract> and examine a number of anomalies and pathologies observed in the exchange of inter-domain routing information.  </abstract>::line_number::14
<abstract> The analysis in this paper is based on data collected from  </abstract>::line_number::15
<abstract> BGP routing messages generated by border routers at five  </abstract>::line_number::16
<abstract> of the Internet core's public exchange points during a nine  </abstract>::line_number::17
<abstract> month period. We show that the volume of these routing updates is several orders of magnitude more than expected and  </abstract>::line_number::18
<abstract> that the majority of this routing information is redundant,  </abstract>::line_number::19
<abstract> or pathological. Furthermore, our analysis reveals several  </abstract>::line_number::20
<abstract> unexpected trends and ill-behaved systematic properties in  </abstract>::line_number::21
<abstract> Internet routing. We finally posit a number of explanations  </abstract>::line_number::22
<abstract> for these anomalies and evaluate their potential impact on  </abstract>::line_number::23
<abstract> the Internet infrastructure.   </abstract>::line_number::24
<intro>  1 Introduction  </intro>::line_number::25

<title>  Spheres of Control:  </title>::line_number::0
<title> An Approach to Advanced Recovery   </title>::line_number::1
<author>  C. Wallace N. Soparkar   </author>::line_number::2
<affiliation>  Electrical Engineering & Computer Science  </affiliation>::line_number::3
<affiliation> The University of Michigan   </affiliation>::line_number::4
<address>  Ann Arbor, MI 48109-2122  </address>::line_number::5
<address> USA   </address>::line_number::6
<email>  fwallace,soparkarg@eecs.umich.edu   </email>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> Recovery from failures and erroneous executions is a crucial but complicated issue for concurrently accessed data systems. Increasingly sophisticated techniques are being developed to improve performance  </abstract>::line_number::9
<abstract> and functionality of recovery protocols. To better understand and analyze recovery schemes, we reexamine the concept of spheres of control [Dav78], using it as a unifying framework for specifying diverse  </abstract>::line_number::10
<abstract> recovery models simply and precisely. We constrain sphere-of-control formulations appropriately to capture transaction-oriented recovery in both centralized and distributed environments and with different  </abstract>::line_number::11
<abstract> types of schedules, as well as semantics-based recovery and compensation. In addition, we discuss how  </abstract>::line_number::12
<abstract> the operational semantics methodology of evolving algebras [Gur95] can model spheres of control formally  </abstract>::line_number::13
<abstract> and refine them to lower levels of abstraction.   </abstract>::line_number::14
<intro>  1 Introduction  </intro>::line_number::15

<title>  Distributed Pipeline Scheduling: End-to-End Analysis of  </title>::line_number::0
<title> Heterogeneous, Multi-Resource Real-Time Systems   </title>::line_number::1
<author>  Saurav Chatterjee and Jay Strosnider   </author>::line_number::2
<affiliation>  Department of Electrical & Computer Engineering  </affiliation>::line_number::3
<affiliation> Carnegie Mellon University   </affiliation>::line_number::4
<address>  Pittsburgh, PA 15213   </address>::line_number::5
<note>  This research was supported in part by a grant from the Office  </note>::line_number::6
<note> of Naval Research, in part by a grant from the Naval Research  </note>::line_number::7
<note> and Development Laboratory, and in part by a grant from  </note>::line_number::8
<note> Siemens Corporate Research.  </note>::line_number::9
<note> In 15th IEEE International Conference on Distributed Computing Systems, May 1995.   </note>::line_number::10
<abstract>  Abstract  </abstract>::line_number::11
<abstract> This paper presents an hierarchical end-to-end  </abstract>::line_number::12
<abstract> analysis technique that decomposes the very complex  </abstract>::line_number::13
<abstract> heterogeneous multi-resource scheduling problem into  </abstract>::line_number::14
<abstract> a set of single resource scheduling problems with well  </abstract>::line_number::15
<abstract> defined interactions. We define heterogeneity both in  </abstract>::line_number::16
<abstract> resource types, e.g., CPU, and in scheduling policies,  </abstract>::line_number::17
<abstract> e.g., rate-monotonic scheduling. This analysis  </abstract>::line_number::18
<abstract> technique is one phase of our systems integration  </abstract>::line_number::19
<abstract> framework for designing large-scale, heterogeneous,  </abstract>::line_number::20
<abstract> distributed real-time systems whose timing properties  </abstract>::line_number::21
<abstract> can be strictly controlled and analyzed. This approach,  </abstract>::line_number::22
<abstract> denoted the Distributed Pipelining Framework,  </abstract>::line_number::23
<abstract> exploits the natural pipelining execution pattern found  </abstract>::line_number::24
<abstract> in a large number of continuous (periodic) applications  </abstract>::line_number::25
<abstract> executing over heterogenous resources. A teleconference application is used in this paper to show the  </abstract>::line_number::26
<abstract> utility of the approach.   </abstract>::line_number::27
<intro>  1. Introduction  </intro>::line_number::28

<title>  Modelling rational inquiry in non-ideal agents   </title>::line_number::0
<author>  Antonio Moreno   </author>::line_number::1
<affiliation>  Escola Tecnica Superior d'Enginyeria  </affiliation>::line_number::2
<affiliation> Departament d'Enginyeria Informatica  </affiliation>::line_number::3
<affiliation> Universitat Rovira i Virgili (URV)   </affiliation>::line_number::4
<address>  Carretera de Salou, s/n. 43006-Tarragona   </address>::line_number::5
<email>  amoreno@etse.urv.es   </email>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> The construction of rational agents is one of the goals that has been pursued in  </abstract>::line_number::8
<abstract> Artificial Intelligence (AI). In most of the architectures that have been proposed for  </abstract>::line_number::9
<abstract> this kind of agents, its behaviour is guided by its set of beliefs. In our work, rational  </abstract>::line_number::10
<abstract> agents are those systems that are permanently engaged in the process of rational  </abstract>::line_number::11
<abstract> inquiry; thus, their beliefs keep evolving in time, as a consequence of their internal  </abstract>::line_number::12
<abstract> inference procedures and their interaction with the environment. Both AI researchers  </abstract>::line_number::13
<abstract> and philosophers are interested in having a formal model of this process, and this is  </abstract>::line_number::14
<abstract> the main topic in our work.  </abstract>::line_number::15
<abstract> Beliefs have been formally modelled in the last decades using doxastic logics. The  </abstract>::line_number::16
<abstract> possible worlds model and its associated Kripke semantics provide an intuitive semantics for these logics, but they seem to commit us to model agents that are logically  </abstract>::line_number::17
<abstract> omniscient and perfect reasoners. We avoid these problems by replacing possible  </abstract>::line_number::18
<abstract> worlds by conceivable situations, which are all the situations that the modelled agent  </abstract>::line_number::19
<abstract> is capable of considering.  </abstract>::line_number::20
<abstract> In this document we show how this notion of conceivable situations may be used  </abstract>::line_number::21
<abstract> to model the process of rational inquiry in which a non-ideal rational agent is engaged. We define a wide class of agents, called rational inquirers, which are a general  </abstract>::line_number::22
<abstract> abstraction of any kind of non-ideal agent. We show how the beliefs of these kind of  </abstract>::line_number::23
<abstract> agents evolve in time as a consequence of a multi-dimensional belief analysis, and we  </abstract>::line_number::24
<abstract> use the framework of conceivable situations in order to model this evolution.   </abstract>::line_number::25
<keyword>  Keywords: rational inquiry, doxastic logics, logical omniscience, perfect reasoning, possible  </keyword>::line_number::26
<keyword> worlds, Kripke semantics, dynamic multi-dimensional belief analysis   </keyword>::line_number::27
<page>  +PAGE+  </page>::line_number::28

<title>  Some Geographical Applications of  </title>::line_number::0
<title> Genetic Programming on the Cray T3D  </title>::line_number::1
<title> Supercomputer   </title>::line_number::2
<author>  I. Turton, S. Openshaw and G. Diplock   </author>::line_number::3
<affiliation>  School of Geography, University of Leeds,   Leeds, UK   </affiliation>::line_number::4
<email>  email: ian@geog.leeds.ac.uk, stan@geog.leeds.ac.uk, gary@geog.leeds.ac.uk   </email>::line_number::5
<date>  April 15, 1996   </date>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> The paper describes some geographical applications of a parallel GP code  </abstract>::line_number::8
<abstract> which is run on a Cray T3D 512 processor supercomputer to create new  </abstract>::line_number::9
<abstract> types of well performing mathematical models. A series of results are described which allude to the potential power of the method for which there  </abstract>::line_number::10
<abstract> are many practical applications in spatial data rich environments where  </abstract>::line_number::11
<abstract> there are no suitable existing models and no soundly based theoretical  </abstract>::line_number::12
<abstract> framework on which to base them.   </abstract>::line_number::13
<intro>  1 Introduction  </intro>::line_number::14

<title>  Simulation of Simplicity:  </title>::line_number::0
<title> A Technique to Cope with Degenerate Cases  </title>::line_number::1
<title> in Geometric Algorithms 1   </title>::line_number::2
<author>  Herbert Edelsbrunner 2 and Ernst Peter Mucke 2   </author>::line_number::3
<abstract>  Abstract  </abstract>::line_number::4
<abstract> This paper describes a general-purpose programming technique, called the Simulation of  </abstract>::line_number::5
<abstract> Simplicity, which can be used to cope with degenerate input data for geometric algorithms.  </abstract>::line_number::6
<abstract> It relieves the programmer from the task to provide a consistent treatment for every single  </abstract>::line_number::7
<abstract> special case that can occur. The programs that use the technique tend to be considerably  </abstract>::line_number::8
<abstract> smaller and more robust than those that do not use it. We believe that this technique will  </abstract>::line_number::9
<abstract> become a standard tool in writing geometric software.   </abstract>::line_number::10
<keyword>  Keywords: Computational geometry, degenerate data, implementation, programming  </keyword>::line_number::11
<keyword> tool, perturbation, determinants, symbolic computation.   </keyword>::line_number::12
<note>  ACM Transactions on Graphics, 9(1):66-104, 1990.  </note>::line_number::13
<note> 1 Research of both authors was supported by Amoco Foundation Faculty Development Grant CS 1-6-44862. It  </note>::line_number::14

<note>  , , 1-30 ()  </note>::line_number::0
<note> c Kluwer Academic Publishers, Boston. Manufactured in The Netherlands.   </note>::line_number::1
<title>  On the Optimality of the Simple Bayesian  </title>::line_number::2
<title> Classifier under Zero-One Loss   </title>::line_number::3
<author>  PEDRO DOMINGOS   pedrod@ics.uci.edu   </author>::line_number::4
<author>  MICHAEL PAZZANI   pazzani@ics.uci.edu   </author>::line_number::5
<affiliation>  Department of Information and Computer Science, University of California,   Irvine, CA 92697   </affiliation>::line_number::6
<note>  Editor: Gregory Provan   </note>::line_number::7
<abstract>  Abstract. The simple Bayesian classifier is known to be optimal when attributes are independent  </abstract>::line_number::8
<abstract> given the class, but the question of whether other sufficient conditions for its optimality exist has  </abstract>::line_number::9
<abstract> so far not been explored. Empirical results showing that it performs surprisingly well in many  </abstract>::line_number::10
<abstract> domains containing clear attribute dependences suggest that the answer to this question may be  </abstract>::line_number::11
<abstract> positive. This article shows that, although the Bayesian classifier's probability estimates are only  </abstract>::line_number::12
<abstract> optimal under quadratic loss if the independence assumption holds, the classifier itself can be  </abstract>::line_number::13
<abstract> optimal under zero-one loss (misclassification rate) even when this assumption is violated by a  </abstract>::line_number::14
<abstract> wide margin. The region of quadratic-loss optimality of the Bayesian classifier is in fact a second-order infinitesimal fraction of the region of zero-one optimality. This implies that the Bayesian  </abstract>::line_number::15
<abstract> classifier has a much greater range of applicability than previously thought. For example, in this  </abstract>::line_number::16
<abstract> article it is shown to be optimal for learning conjunctions and disjunctions, even though they  </abstract>::line_number::17
<abstract> violate the independence assumption. Further, studies in artificial domains show that it will often  </abstract>::line_number::18
<abstract> outperform more powerful classifiers for common training set sizes and numbers of attributes, even  </abstract>::line_number::19
<abstract> if its bias is a priori much less appropriate to the domain. This article's results also imply that  </abstract>::line_number::20
<abstract> detecting attribute dependence is not necessarily the best way to extend the Bayesian classifier,  </abstract>::line_number::21
<abstract> and this is also verified empirically.   </abstract>::line_number::22
<keyword>  Keywords: Simple Bayesian classifier, naive Bayesian classifier, zero-one loss, optimal classification, induction with attribute dependences   </keyword>::line_number::23
<intro>  1. Introduction  </intro>::line_number::24

<title>  STATISTICAL LANGUAGE MODELING FOR SPEECH DISFLUENCIES   </title>::line_number::0
<author>  Andreas Stolcke Elizabeth Shriberg   </author>::line_number::1
<affiliation>  Speech Technology and Research Laboratory  </affiliation>::line_number::2
<address> SRI International,   Menlo Park, CA 94025   </address>::line_number::3
<email>  stolcke@speech.sri.com  </email>::line_number::4
<email> ees@speech.sri.com   </email>::line_number::5
<abstract>  ABSTRACT  </abstract>::line_number::6
<abstract> Speech disfluencies (such as filled pauses, repetitions, restarts) are  </abstract>::line_number::7
<abstract> among the characteristics distinguishing spontaneous speech from  </abstract>::line_number::8
<abstract> planned or read speech. We introduce a language model that predicts disfluencies probabilistically and uses an edited, fluent context  </abstract>::line_number::9
<abstract> to predict following words. The model is based on a generalization  </abstract>::line_number::10
<abstract> of the standard N-gram language model. It uses dynamic programming to compute the probability of a word sequence, taking into  </abstract>::line_number::11
<abstract> account possible hidden disfluency events. We analyze the model's performance for various disfluency types on the Switchboard  </abstract>::line_number::12
<abstract> corpus. We find that the model reduces word perplexity in the  </abstract>::line_number::13
<abstract> neighborhood of disfluency events; however, overall differences  </abstract>::line_number::14
<abstract> are small and have no significant impact on recognition accuracy.  </abstract>::line_number::15
<abstract> We also note that for modeling of the most frequent type of dis-fluency, filled pauses, a segmentation of utterances into linguistic  </abstract>::line_number::16
<abstract> (rather than acoustic) units is required. Our analysis illustrates a  </abstract>::line_number::17
<abstract> generally useful technique for language model evaluation based on  </abstract>::line_number::18
<abstract> local perplexity comparisons.   </abstract>::line_number::19
<intro>  1. MOTIVATION AND OVERVIEW  </intro>::line_number::20

<affiliation>  INTERNATIONAL COMPUTER SCIENCE INSTITUTE   </affiliation>::line_number::0
<address>  I 1947 Center St. * Suite 600 * Berkeley, California 94704-1198 *   (510) 643-9153 * FAX (510) 643-7684   </address>::line_number::1
<title>  Some MPEG Decoding Functions  </title>::line_number::2
<title> on Spert  </title>::line_number::3
<title> An Example for Assembly  </title>::line_number::4
<title> Programmers   </title>::line_number::5
<author>  Arno Formella   </author>::line_number::6
<pubnum>  TR-94-027   </pubnum>::line_number::7
<date>  October 1994   </date>::line_number::8
<abstract>  Abstract  </abstract>::line_number::9
<abstract> We describe our method how to implement C-program sequences in torrent (T0)  </abstract>::line_number::10
<abstract> assembler code while there is no efficient automatic tool. We use re-structuring of  </abstract>::line_number::11
<abstract> the source code, vectorization, dataflow graphs, a simple scheduling strategy and a  </abstract>::line_number::12
<abstract> straight forward register allocation algorithm. We define some lower and an upper  </abstract>::line_number::13
<abstract> bound for the expected run time. For two functions, namely the color transformation  </abstract>::line_number::14
<abstract> and reverse DCT, we achieve almost 54, respectively 16 times the performance of a  </abstract>::line_number::15
<abstract> Sparc 2 workstation.   </abstract>::line_number::16
<page>  +PAGE+  </page>::line_number::17

<title>  Getting a Grip: A Computational Model of the  </title>::line_number::0
<title> Acquisition of Verb Semantics for Hand Actions   </title>::line_number::1
<author>  David Bailey   </author>::line_number::2
<affiliation>  Computer Science Division, Univ. of California at Berkeley  </affiliation>::line_number::3
<affiliation> and International Computer Science Institute   </affiliation>::line_number::4
<address>  1947 Center St. Suite 600, Berkeley CA 94704   </address>::line_number::5
<email>  dbailey@icsi.berkeley.edu   </email>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> We present a computational model of how verbs might be learned within  </abstract>::line_number::8
<abstract> the limited domain of hand actions. We hypothesize that such verbs refer to  </abstract>::line_number::9
<abstract> the activities of underlying motor schemas, and leverage this constraint to  </abstract>::line_number::10
<abstract> build a system with strong enough biases that it can learn from a reasonably  </abstract>::line_number::11
<abstract> small number of examples, while still having adequate flexibility to learn the  </abstract>::line_number::12
<abstract> hand-action verbs of any language. The completed system should demonstrate its knowledge both by labelling its own behavior and by carrying out  </abstract>::line_number::13
<abstract> verbal commands in a simulated world.   </abstract>::line_number::14
<intro>  1 Overview  </intro>::line_number::15

<title>  Storage of Two and Three Dimensional Raster Type Data for  </title>::line_number::0
<title> Optimized Retrieval of One, Two or Three Dimensional Features   </title>::line_number::1
<author>  Kjell Bratbergsengen   </author>::line_number::2
<affiliation>  Department of Computer Systems and Information Science  </affiliation>::line_number::3
<address> Norwegian University of Science and Technology,   Trondheim, Norway   </address>::line_number::4
<email>  email: kjellb@idi.ntnu.no   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> We are analyzing storage structures for two and three dimensional raster type data which are used  </abstract>::line_number::7
<abstract> for feature retrieval. The features are one, two or three dimensional objects with regular outlines  </abstract>::line_number::8
<abstract> like a rectangle or a prism. The features could be parts of a map or image, an area of special  </abstract>::line_number::9
<abstract> interest for searching after oil, a sequence of ultra sound images, and so on. The storage medium  </abstract>::line_number::10
<abstract> is magnetic disk. The data are stored in chunks or blocks representing a regular part of the source  </abstract>::line_number::11
<abstract> object. We analyze the shape and the size to minimize the cost of retrieval. The optimization is  </abstract>::line_number::12
<abstract> based on minimum time to do retrieval. We have five combinations: Lines and areas from areas and  </abstract>::line_number::13
<abstract> volumes, and volumes from volumes. The optimal block sizes for random retrieval varies, with case,  </abstract>::line_number::14
<abstract> feature size and disk characteristics. One general observation is that longer disk tracks gives larger  </abstract>::line_number::15
<abstract> blocks. For line retrieval the optimal block size is only depending on disk track length. For other  </abstract>::line_number::16
<abstract> cases it is also depending on the feature size. For partly sequential retrieval the block size is not the  </abstract>::line_number::17
<abstract> actual block size used during retrieval, but the smallest addressing unit, and the optimal addressing  </abstract>::line_number::18
<abstract> unit could be rather small.  </abstract>::line_number::19
<abstract> The analysis reveals that using too small blocks could be very costly. The time could easily  </abstract>::line_number::20
<abstract> double or triple if small blocks are used. In many cases the optimal block size is several tracks.   </abstract>::line_number::21
<keyword>  Keywords: storage and retrieval, matrix, optimization   </keyword>::line_number::22
<intro>  1 Problem Introduction  </intro>::line_number::23

<title>  Video Server on an ATM Connected Cluster of Workstations   </title>::line_number::0
<author>  Olav Sandsta, Stein Langrgen, and Roger Midtstraum   </author>::line_number::1
<affiliation>  Department of Computer and Information Science  </affiliation>::line_number::2
<affiliation> Norwegian University of Science and Technology   </affiliation>::line_number::3
<address>  N-7034 Trondheim, Norway   </address>::line_number::4
<email>  folavsa, steinl, rogerg@idi.ntnu.no   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Video servers are important for applications which make  </abstract>::line_number::7
<abstract> use of digital video. The video servers should provide better  </abstract>::line_number::8
<abstract> functionality than most of today's video servers offer, - e.g.,  </abstract>::line_number::9
<abstract> support of flexible and instant user interactions, delivery of  </abstract>::line_number::10
<abstract> multiple video formats and support of virtual video documents. In this paper we discuss the requirements that video  </abstract>::line_number::11
<abstract> servers should fulfill and we describe the design and implementation of the Elvira video server. The Elvira video server  </abstract>::line_number::12
<abstract> is built on a cluster of standard UNIX workstations interconnected by an ATM switch. The capacity of the Elvira server  </abstract>::line_number::13
<abstract> is evaluated and we show the effects of different strategies  </abstract>::line_number::14
<abstract> for allocation of video data across nodes and disks.   </abstract>::line_number::15
<intro>  1. Introduction  </intro>::line_number::16

<title>  Write Optimized Object-Oriented Database Systems   </title>::line_number::0
<author>  Kjetil Nrvag and Kjell Bratbergsengen   </author>::line_number::1
<affiliation>  Department of Computer and Information Science  </affiliation>::line_number::2
<affiliation> Norwegian University of Science and Technology   </affiliation>::line_number::3
<address>  7034 Trondheim, Norway   </address>::line_number::4
<email>  fnoervaag, kjellbg@idi.ntnu.no   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> In a database system, read operations are much more  </abstract>::line_number::7
<abstract> common than write operations, and consequently, database  </abstract>::line_number::8
<abstract> systems have been read optimized. As the size of main memory increases, more of the database read requests will be satisfied from the buffer system, and the amount of disk write  </abstract>::line_number::9
<abstract> operations relative to disk read operations will increase.  </abstract>::line_number::10
<abstract> This calls for a focus on write optimized database systems.  </abstract>::line_number::11
<abstract> In this paper, we present solutions to this problem. We describe in detail the data structures and algorithms needed  </abstract>::line_number::12
<abstract> to realize a write optimized object-oriented database system  </abstract>::line_number::13
<abstract> in the context of Vagabond, an OODB currently being implemented at our department. In Vagabond, focus has been  </abstract>::line_number::14
<abstract> to provide support for applications which have earlier used  </abstract>::line_number::15
<abstract> file systems because of the limited data bandwidth in current  </abstract>::line_number::16
<abstract> database systems, typical examples are super computing applications and geographical information systems   </abstract>::line_number::17
<intro>  1. Introduction  </intro>::line_number::18

<title>  On the Computational Requirements of  </title>::line_number::0
<title> Virtual Reality Systems 1   </title>::line_number::1
<author>  Frank Devai   </author>::line_number::2
<affiliation>  School of Computing & Mathematics, University of Ulster   </affiliation>::line_number::3
<abstract>  Abstract  </abstract>::line_number::4
<abstract> The computational requirements of high-quality, real-time rendering exceeds the limits of  </abstract>::line_number::5
<abstract> generally available computing power. However illumination effects, except shadows, are  </abstract>::line_number::6
<abstract> less noticeable on moving pictures. Shadows can be produced with the same techniques  </abstract>::line_number::7
<abstract> used for visibility computations, therefore the basic requirements of real-time rendering  </abstract>::line_number::8
<abstract> are transformations, pre-selection of the part of the scene to be displayed and visibility  </abstract>::line_number::9
<abstract> computations. Transformations scale well, ie, their time requirement grows linearly with  </abstract>::line_number::10
<abstract> the input size. Pre-selection, if implemented by the traditional way of polygon clipping,  </abstract>::line_number::11
<abstract> has a growing rate of N log N in the worst case, where N is the total number of edges in  </abstract>::line_number::12
<abstract> the scene. Visibility computations, exhibiting a quadratic growing rate, are the bottleneck  </abstract>::line_number::13
<abstract> from a theoretical point of view. Three approaches are discussed to speed up visibility  </abstract>::line_number::14
<abstract> computations: (i) reducing the expected running time to O(N log N ) (ii) using approximation algorithms with O(N K) worst-case time, where K is the linear resolution of the  </abstract>::line_number::15
<abstract> image, and (iii) applying parallel techniques leading to logarithmic time in the worst-case.  </abstract>::line_number::16
<abstract> Though the growing rate of the time requirement of pre-selection is significantly slower  </abstract>::line_number::17
<abstract> than that of visibility, it is demonstrated that pre-selection has to deal with a significantly  </abstract>::line_number::18
<abstract> higher amount of data than visibility computations, as the average clipping volume is 1/27  </abstract>::line_number::19
<abstract> of the volume of the model.   </abstract>::line_number::20
<intro>  1 Introduction  </intro>::line_number::21

<title>  Signal and Image Processing in Java   </title>::line_number::0
<author>  Jonathan Campbell and Fionn Murtagh   </author>::line_number::1
<affiliation>  University of Ulster, Magee College,   Derry, BT48 7JL   </affiliation>::line_number::2
<email>  email: jg.campbell@ulst.ac.uk.   </email>::line_number::3
<note>  Revisions available from   </note>::line_number::4
<web>  http://www.infm.ulst.ac.uk/research/preprints.html   </web>::line_number::5
<note>  Original paper presented at IMVIP '97  </note>::line_number::6
<note> University of Ulster, Magee College, Derry  </note>::line_number::7
<note> 10-13 September 1997.   </note>::line_number::8
<date>  9 September 1997   </date>::line_number::9
<note>  Revised 20 September 1997  </note>::line_number::10
<note> Revised 6 November 1997   </note>::line_number::11
<abstract>  Abstract  </abstract>::line_number::12
<abstract> We describe the implementation of a multi-purpose data analysis laboratory, DataLab-J, in  </abstract>::line_number::13
<abstract> the programming language Java. We briefly trace the stages of the evolution of DataLab from a  </abstract>::line_number::14
<abstract> FORTRAN-IV system in 1973 to the current Java development. Description of this evolution allows  </abstract>::line_number::15
<abstract> us to discuss some key design and functionality decisions and issues that arose throughout the years;  </abstract>::line_number::16
<abstract> many of these issues remain topical, so, in addition to an evaluation of Java, we identify and discuss  </abstract>::line_number::17
<abstract> what are for us the major issues in the design of such software. Moreover, we address questions  </abstract>::line_number::18
<abstract> raised by the need to convert legacy systems, e.g. those programmed in C and various versions of  </abstract>::line_number::19
<abstract> FORTRAN. The experience of redesign and implementation in Java is described, together with a  </abstract>::line_number::20
<abstract> brief evaluation of the suitability of Java for 'number-crunching'. Overall conclusions are drawn,  </abstract>::line_number::21
<abstract> regarding design of such software, lessons learned, traps to avoid, and on Java itself.   </abstract>::line_number::22
<intro>  1 Introduction  </intro>::line_number::23

<title>  A Rule-Based CQL for 2-Dimensional Tables   </title>::line_number::0
<author>  Mohand-Sad Hacid, Patrick Marcel, and Christophe Rigotti   </author>::line_number::1
<affiliation>  Laboratoire d'Ingenierie des Systemes d'Information  </affiliation>::line_number::2
<address> INSA Lyon,   B^atiment 501, F-69621 Villeurbanne Cedex   </address>::line_number::3
<phone>  Tel : 72 43 85 88 Fax: 72 43 87 13   </phone>::line_number::4
<email>  fmohand,patrick,crigg@lisi.insa-lyon.fr   </email>::line_number::5
<abstract>  Abstract. We describe the core of a rule-based CQL, devoted to the  </abstract>::line_number::6
<abstract> manipulation of 2-dimensional tabular databases. The rules provide a  </abstract>::line_number::7
<abstract> simple and declarative way to restructure and query tables, and the constraints allow to define cell contents by formulas over concrete domains.  </abstract>::line_number::8
<abstract> We define a model-theoretic semantics and develop an equivalent fixpoint  </abstract>::line_number::9
<abstract> theory that leads to a naive evaluation procedure.   </abstract>::line_number::10
<intro>  1 Introduction  </intro>::line_number::11

<title>  SEE ME, HEAR ME: INTEGRATING AUTOMATIC SPEECH RECOGNITION AND  </title>::line_number::0
<title> LIP-READING   </title>::line_number::1
<author>  Paul Duchnowski 1 Uwe Meier 1 Alex Waibel 1;2   </author>::line_number::2
<affiliation>  1 University of Karlsruhe,   Karlsruhe, Germany   2 Carnegie Mellon University,   Pittsburgh PA, USA   </affiliation>::line_number::3
<abstract>  ABSTRACT  </abstract>::line_number::4
<abstract> We present recent work on integration of visual information (automatic lip-reading) with acoustic speech for better overall speech recognition. A Multi-State Time Delay  </abstract>::line_number::5
<abstract> Neural Network performs the recognition of spelled letter  </abstract>::line_number::6
<abstract> sequences taking advantage of lip images from a standard  </abstract>::line_number::7
<abstract> camera. The problems addressed include efficient but effective representation of the visual information and optimum  </abstract>::line_number::8
<abstract> manner of combining the two modalities when rendering a  </abstract>::line_number::9
<abstract> decision. We show results for several alternatives to direct  </abstract>::line_number::10
<abstract> gray level image as the visual evidence. These are: Principal  </abstract>::line_number::11
<abstract> Components, Linear Discriminants, and DFT coefficients.  </abstract>::line_number::12
<abstract> Dimensionality of the input is decreased by a factor of 12  </abstract>::line_number::13
<abstract> while maintaining recognition rates. Combination of the  </abstract>::line_number::14
<abstract> visual and acoustic information is performed at three different levels of abstraction. Results suggest that integration  </abstract>::line_number::15
<abstract> of higher order input features works best. On a continuous  </abstract>::line_number::16
<abstract> spelling task, visual-alone recognition of 45-55%, when combined with acoustic data, lowers audio-alone error rates by  </abstract>::line_number::17
<abstract> 30-40%.   </abstract>::line_number::18
<intro>  1. INTRODUCTION  </intro>::line_number::19

<title>  A Stochastic Case Frame Approach for Natural Language Understanding   </title>::line_number::0
<author>  Wolfgang Minker, Samir Bennacef, Jean-Luc Gauvain   </author>::line_number::1
<affiliation>  Spoken Language Processing Group  </affiliation>::line_number::2
<affiliation> LIMSI-CNRS   </affiliation>::line_number::3
<address>  91403 Orsay cedex, FRANCE   </address>::line_number::4
<email>  email: fminker,bennacef,gauvaing@limsi.fr   </email>::line_number::5
<abstract>  ABSTRACT  </abstract>::line_number::6
<abstract> A stochastically based approach for the semantic analysis component of a natural spoken language system for the ATIS task has been  </abstract>::line_number::7
<abstract> developed. The semantic analyzer of the spoken language system  </abstract>::line_number::8
<abstract> already in use at LIMSI makes use of a rule-based case grammar. In  </abstract>::line_number::9
<abstract> this work, the system of rules for the semantic analysis is replaced  </abstract>::line_number::10
<abstract> with a relatively simple, first order Hidden Markov Model. The  </abstract>::line_number::11
<abstract> performance of the two approaches can be compared because they  </abstract>::line_number::12
<abstract> use identical semantic representations despite their rather different  </abstract>::line_number::13
<abstract> methods for meaning extraction. We use an evaluation methodology  </abstract>::line_number::14
<abstract> that assesses performance at different semantic levels, including the  </abstract>::line_number::15
<abstract> database response comparison used in the ARPA ATIS paradigm.   </abstract>::line_number::16
<intro>  1. INTRODUCTION  </intro>::line_number::17

<title>  Tracking Drifting Concepts  </title>::line_number::0
<title> By Minimizing Disagreements   </title>::line_number::1
<author>  David P. Helmbold and Philip M. Long    </author>::line_number::2
<affiliation>  CIS Board  </affiliation>::line_number::3
<affiliation> UC Santa Cruz   </affiliation>::line_number::4
<address>  Santa Cruz, CA 95064   </address>::line_number::5
<date>  March 24, 1994   </date>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> In this paper we consider the problem of tracking a subset of a domain (called the target) which  </abstract>::line_number::8
<abstract> changes gradually over time. A single (unknown) probability distribution over the domain is used  </abstract>::line_number::9
<abstract> to generate random examples for the learning algorithm and measure the speed at which the target  </abstract>::line_number::10
<abstract> changes.  </abstract>::line_number::11
<abstract> Clearly, the more rapidly the target moves, the harder it is for the algorithm to maintain a good  </abstract>::line_number::12
<abstract> approximation of the target. Therefore we evaluate algorithms based on how much movement of  </abstract>::line_number::13
<abstract> the target can be tolerated between examples while predicting with accuracy *. Furthermore, the  </abstract>::line_number::14
<abstract> complexity of the class H of possible targets, as measured by d, its VC-dimension, also effects the  </abstract>::line_number::15
<abstract> difficulty of tracking the target concept.  </abstract>::line_number::16
<abstract> We show that if the problem of minimizing the number of disagreements with a sample from  </abstract>::line_number::17
<abstract> among concepts in a class H can be approximated to within a factor k, then there is a simple tracking  </abstract>::line_number::18
<abstract> algorithm for H which can achieve a probability * of making a mistake if the target movement rate  </abstract>::line_number::19
<abstract> is at most a constant times * 2 =(k(d + k) ln 1  </abstract>::line_number::20
<abstract> * ), where d is the Vapnik-Chervonenkis dimension of  </abstract>::line_number::21
<abstract> H. Also, we show that if H is properly PAC-learnable, then there is an efficient (randomized)  </abstract>::line_number::22
<abstract> algorithm that with high probability approximately minimizes disagreements to within a factor of  </abstract>::line_number::23
<abstract> 7d + 1, yielding an efficient tracking algorithm for H which tolerates drift rates up to a constant  </abstract>::line_number::24
<abstract> times * 2 =(d 2 ln 1  </abstract>::line_number::25
<abstract> In addition, we prove complementary results for the classes of halfspaces and axis-aligned hy  </abstract>::line_number::26
<abstract> perrectangles showing that the maximum rate of drift that any algorithm (even with unlimited  </abstract>::line_number::27
<abstract> computational power) can tolerate is a constant times * 2 =d.   </abstract>::line_number::28
<intro>  1 Introduction  </intro>::line_number::29

<title>  A Monotonic Measure for Optimal  </title>::line_number::0
<title> Feature Selection   </title>::line_number::1
<author>  Huan Liu 1 and Hiroshi Motoda 2 and Manoranjan Dash 3   </author>::line_number::2
<affiliation>  1 Dept of Info Sys & Comp Sci, National University of Singapore,   Singapore 119260.   </affiliation>::line_number::3
<affiliation>  2 Division of Intelligent Sys Sci, Osaka University,   Ibaraki, Osaka 567, Japan.   </affiliation>::line_number::4
<affiliation>  3 BioInformatics Centre, National University of Singapore,   Singapore 119074.   </affiliation>::line_number::5
<email>  fliuh, manoranjg@iscs.nus.edu.sg motoda@sanken.osaka-u.ac.jp   </email>::line_number::6
<abstract>  Abstract. Feature selection is a problem of choosing a subset of relevant  </abstract>::line_number::7
<abstract> features. In general, only exhaustive search can bring about the optimal  </abstract>::line_number::8
<abstract> subset. With a monotonic measure, exhaustive search can be avoided  </abstract>::line_number::9
<abstract> without sacrificing optimality. Unfortunately, most error- or distance-based measures are not monotonic. A new measure is employed in this  </abstract>::line_number::10
<abstract> work that is monotonic and fast to compute. The search for relevant  </abstract>::line_number::11
<abstract> features according to this measure is guaranteed to be complete but not  </abstract>::line_number::12
<abstract> exhaustive. Experiments are conducted for verification.   </abstract>::line_number::13
<intro>  1 Introduction  </intro>::line_number::14

<title>  Understanding Neural Networks via Rule Extraction   </title>::line_number::0
<author>  Rudy Setiono and Huan Liu    </author>::line_number::1
<affiliation>  Department of Information Systems and Computer Science  </affiliation>::line_number::2
<affiliation> National University of Singapore   </affiliation>::line_number::3
<address>  Kent Ridge, Singapore 0511   </address>::line_number::4
<email>  frudys,liuhg@iscs.nus.sg   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Although backpropagation neural networks  </abstract>::line_number::7
<abstract> generally predict better than decision trees do  </abstract>::line_number::8
<abstract> for pattern classification problems, they are often regarded as black boxes, i.e., their predictions are not as interpretable as those of decision trees. This paper argues that this is because there has been no proper technique that  </abstract>::line_number::9
<abstract> enables us to do so. With an algorithm that  </abstract>::line_number::10
<abstract> can extract rules 1 , by drawing parallels with  </abstract>::line_number::11
<abstract> those of decision trees, we show that the predictions of a network can be explained via rules extracted from it, thereby, the network can be understood. Experiments demonstrate that rules  </abstract>::line_number::12
<abstract> extracted from neural networks are comparable with those of decision trees in terms of predictive accuracy, number of rules and average  </abstract>::line_number::13
<abstract> number of conditions for a rule; they preserve  </abstract>::line_number::14
<abstract> high predictive accuracy of original networks.   </abstract>::line_number::15
<intro>  1 Introduction  </intro>::line_number::16

<note>  To appear in Expert Systems with Applications: An International Journal, Vol.10(1996)   </note>::line_number::0
<title>  Efficient Rule Induction from Noise Data   </title>::line_number::1
<author>  Huan Liu   </author>::line_number::2
<affiliation>  Department of Information Systems and Computer Science  </affiliation>::line_number::3
<affiliation> National University of Singapore   </affiliation>::line_number::4
<address>  Kent Ridge, Singapore 0511   </address>::line_number::5
<email>  liuh@iscs.nus.sg   </email>::line_number::6
<phone>  Tel: (+65)-772-6563; Fax: (+65) 779-4580   </phone>::line_number::7
<note>  Acknowledgments  </note>::line_number::8
<note> Many thanks to Rudy Setiono and Tiow Seng Tan for providing valuable com  </note>::line_number::9
<note> ments and help.   </note>::line_number::10
<page>  +PAGE+  </page>::line_number::11

<note>  To appear in the journal Presence   </note>::line_number::0
<date>  06/02/97 4:57 PM 1   </date>::line_number::1
<title>  Integrating Pedagogical Agents into Virtual Environments   </title>::line_number::2
<author>  W. Lewis Johnson  </author>::line_number::3
<author> Jeff Rickel  </author>::line_number::4
<author> Randy Stiles  </author>::line_number::5
<author> Allen Munro 1   </author>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> In order for a virtual environment to be effective as a training tool, it is not enough to  </abstract>::line_number::8
<abstract> concentrate on the fidelity of the renderings and the accuracy of the simulated behaviors.  </abstract>::line_number::9
<abstract> The environment should help trainees develop an understanding of the task being trained,  </abstract>::line_number::10
<abstract> and should provide guidance and assistance as needed. This paper describes a system for  </abstract>::line_number::11
<abstract> developing virtual environments in which pedagogical capabilities are incorporated into  </abstract>::line_number::12
<abstract> autonomous agents that interact with trainees. These pedagogical agents can monitor  </abstract>::line_number::13
<abstract> trainees progress and provide guidance and assistance. The agents interact with  </abstract>::line_number::14
<abstract> simulations of objects in the environment, and with trainees. The paper describes the  </abstract>::line_number::15
<abstract> architectural features of the environment and of the agents that permit the agents to meet  </abstract>::line_number::16
<abstract> instructional objectives within the virtual environment. It also discusses how agent-based  </abstract>::line_number::17
<abstract> instruction is combined with other methods of delivering instruction.   </abstract>::line_number::18
<intro>  1. Introduction  </intro>::line_number::19

<title>  Generating Word Lattices from Abstract Meaning Representation   </title>::line_number::0
<author>  Irene Langkilde and Kevin Knight   </author>::line_number::1
<affiliation>  Information Sciences Institute  </affiliation>::line_number::2
<affiliation> University of Southern California   </affiliation>::line_number::3
<address>  Marina del Rey, CA 90292   </address>::line_number::4
<email>  ilangkil@isi.edu and knight@isi.edu   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Large-scale generation of natural language requires an  </abstract>::line_number::7
<abstract> abstract meaning representation and a mechanism for  </abstract>::line_number::8
<abstract> integrating immense amounts of lexical, morphological, grammatical, and conceptual knowledge. The  </abstract>::line_number::9
<abstract> availability of corpus-based statistical knowledge motivates the invention of a new style of generation in  </abstract>::line_number::10
<abstract> which word lattices compactly encode many possible  </abstract>::line_number::11
<abstract> sentence renderings and a statistical extractor chooses  </abstract>::line_number::12
<abstract> the best ones. The focus of generation thus shifts  </abstract>::line_number::13
<abstract> to how word lattices can be generated from abstract  </abstract>::line_number::14
<abstract> meaning representation. This paper presents a flexible  </abstract>::line_number::15
<abstract> meaning representation scheme and generation mechanism. It includes an efficient generation algorithm and  </abstract>::line_number::16
<abstract> grammar formalism that maps from a meaning representation to a lattice. This mapping is flexible enough  </abstract>::line_number::17
<abstract> to allow meaning representation along a continuum of  </abstract>::line_number::18
<abstract> semantic depth.   </abstract>::line_number::19
<intro>  Introduction  </intro>::line_number::20

<title>  A Multicast Congestion Control Mechanism Using Representatives   </title>::line_number::0
<author>  Dante DeLucia Katia Obraczka   </author>::line_number::1
<affiliation>  Hughes Research Laboratories USC Information Sciences Institute   </affiliation>::line_number::2
<address>  3011 Malibu Canyon Road 4676 Admiralty Way Suite 1001  </address>::line_number::3
<address> Malibu CA 90265 Marina Del Rey, CA 90292   </address>::line_number::4
<email>  email: dante@usc.edu email: katia@isi.edu   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> In this paper, we propose a congestion control  </abstract>::line_number::7
<abstract> mechanism for reliable multicast applications that  </abstract>::line_number::8
<abstract> uses a small set of group members, or representatives,  </abstract>::line_number::9
<abstract> to provide timely and accurate feedback on behalf of  </abstract>::line_number::10
<abstract> congested subtrees of a multicast distribution tree.  </abstract>::line_number::11
<abstract> Our algorithm does not need to compute round-trip  </abstract>::line_number::12
<abstract> time (RTT) from all receivers to the source, nor does  </abstract>::line_number::13
<abstract> it require knowledge of group membership or network  </abstract>::line_number::14
<abstract> topology. Through simulations, we evaluate our algorithm with and without TCP cross traffic. This initial evaluation study shows that our algorithm takes  </abstract>::line_number::15
<abstract> advantage of network bandwidth when available, yet  </abstract>::line_number::16
<abstract> does not starve competing flows.   </abstract>::line_number::17
<intro>  1 Introduction  </intro>::line_number::18

<title>  A Tool for Massively Replicating Internet Archives:  </title>::line_number::0
<title> Design, Implementation, and Experience   </title>::line_number::1
<author>  Katia Obraczka   </author>::line_number::2
<affiliation>  University of Southern California  </affiliation>::line_number::3
<affiliation> Information Science Institute   </affiliation>::line_number::4
<address>  4676 Admiralty Way  </address>::line_number::5
<address> Marina del Rey, CA 90292, USA   </address>::line_number::6
<email>  katia@isi.edu   </email>::line_number::7
<author>  Peter Danzig, Dante DeLucia, Erh-Yuan Tsai   </author>::line_number::8
<affiliation>  University of Southern California  </affiliation>::line_number::9
<affiliation> Computer Science Department   </affiliation>::line_number::10
<address>  Los Angeles, CA 90089-0781   </address>::line_number::11
<email>  fdanzig, dante, erhyuantg@usc.edu   </email>::line_number::12
<abstract>  Abstract  </abstract>::line_number::13
<abstract> This paper reports the design, implementation, and performance of a scalable and efficient tool to replicate Internet information services. Our tool targets replication  </abstract>::line_number::14
<abstract> degrees of tens of thousands of weakly-consistent replicas scattered throughout the Internet's thousands of autonomously administered domains. The main goal of our  </abstract>::line_number::15
<abstract> replication tool is to make existing replication algorithms  </abstract>::line_number::16
<abstract> scale in today's exponentially-growing, autonomously-managed internetworks.   </abstract>::line_number::17
<intro>  1. Introduction  </intro>::line_number::18

<title>  Information Gathering Plans With Sensing Actions   </title>::line_number::0
<author>  Naveen Ashish and Craig A. Knoblock Alon Levy   </author>::line_number::1
<affiliation>  Information Sciences Institute and AT&T Bell Laboratories  </affiliation>::line_number::2
<affiliation> Department of Computer Science AI Principles Research Dept.   </affiliation>::line_number::3
<affiliation>  University of Southern California   600 Mountain Ave., Room 2A-440  </affiliation>::line_number::4
<affiliation> 4676 Admiralty Way Murray Hill, NJ 07974  </affiliation>::line_number::5
<email> Marina del Rey, CA 90292   levy@research.att.com  </email>::line_number::6
<email> fashish,knoblockg@isi.edu   </email>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> Information gathering agents can automate the task of retrieving and integrating data  </abstract>::line_number::9
<abstract> from a large number of diverse information sources. The key issue in their performance is  </abstract>::line_number::10
<abstract> efficient query planning that minimizes the number of information sources used to answer  </abstract>::line_number::11
<abstract> a query. Previous work on query planning has considered generating information gathering  </abstract>::line_number::12
<abstract> plans solely based on compile-time analysis of the query and the models of the information  </abstract>::line_number::13
<abstract> sources. We argue that at compile-time it may not be possible to generate an efficient  </abstract>::line_number::14
<abstract> plan for retrieving the requested information because of the large number of possibly  </abstract>::line_number::15
<abstract> relevant sources. We describe an approach that naturally extends query planning to use  </abstract>::line_number::16
<abstract> run-time information to optimize queries that involve many sources. First, we describe an  </abstract>::line_number::17
<abstract> algorithm for generating a discrimination matrix, which is a data structure that identifies  </abstract>::line_number::18
<abstract> the information that can be sensed at run-time to optimize a query plan. Next, we describe  </abstract>::line_number::19
<abstract> how the discrimination matrix is used to decide which of the possible run-time sensing  </abstract>::line_number::20
<abstract> actions to perform. Finally, we demonstrate that this approach yields significant savings  </abstract>::line_number::21
<abstract> (over 90% for some queries) in a real-world task.   </abstract>::line_number::22
<note>  The first and second authors is supported in part by Rome Laboratory of the Air Force Systems Command  </note>::line_number::23
<note> and the Advanced Research Projects Agency under contract no. F30602-94-C-0210, and in part by the National  </note>::line_number::24
<note> Science Foundation under grant number IRI-9313993. The views and conclusions contained in this paper are the  </note>::line_number::25
<note> author's and should not be interpreted as representing the official opinion or policy of ARPA, RL, NSF, AT&T  </note>::line_number::26
<note> Labs, or any person or agency connected with them.   </note>::line_number::27
<page>  +PAGE+  </page>::line_number::28

<title>  Rule Induction for Semantic Query Optimization   </title>::line_number::0
<author>  Chun-Nan Hsu and Craig A. Knoblock   </author>::line_number::1
<affiliation>  Information Sciences Institute and Department of Computer Science  </affiliation>::line_number::2
<affiliation> University of Southern California   </affiliation>::line_number::3
<address>  4676 Admiralty Way, Marina del Rey, CA 90292   </address>::line_number::4
<email>  fchunnan,knoblockg@isi.edu   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Semantic query optimization can dramatically speed up database query answering by  </abstract>::line_number::7
<abstract> knowledge intensive reformulation. But the  </abstract>::line_number::8
<abstract> problem of how to learn required semantic  </abstract>::line_number::9
<abstract> rules has not previously been solved. This  </abstract>::line_number::10
<abstract> paper describes an approach using an inductive learning algorithm to solve the problem. In our approach, learning is triggered  </abstract>::line_number::11
<abstract> by user queries and then the system induces semantic rules from the information in  </abstract>::line_number::12
<abstract> databases. The inductive learning algorithm  </abstract>::line_number::13
<abstract> used in this approach can select an appropriate set of relevant attributes from a potentially huge number of attributes in real-world  </abstract>::line_number::14
<abstract> databases. Experimental results demonstrate  </abstract>::line_number::15
<abstract> that this approach can learn sufficient background knowledge to reformulate queries and  </abstract>::line_number::16
<abstract> provide a 57 percent average performance improvement.   </abstract>::line_number::17
<intro>  1 INTRODUCTION  </intro>::line_number::18

<title>  A Synergy of Agent Components:  </title>::line_number::0
<title> Social Comparison for Failure Detection   </title>::line_number::1
<author>  Gal A. Kaminka Milind Tambe   </author>::line_number::2
<affiliation>  Information Sciences Institute and Computer Science Department  </affiliation>::line_number::3
<affiliation> University of Southern California   </affiliation>::line_number::4
<address>  4676 Admiralty Way, Marina del Rey, CA 90292   </address>::line_number::5
<email>  galk, tambe-@isi.edu   </email>::line_number::6
<intro>  1 Overview  </intro>::line_number::7

<title>  Learning Finite Automata Using Local Distinguishing Experiments +L + </title>::line_number::0
<author>  Wei-Min Shen   </author>::line_number::1
<affiliation>  Microelectronics and Computer Technology Corporation   </affiliation>::line_number::2
<address>  3500 West Balcones Center Drive  </address>::line_number::3
<address> Austin, TX 78759, U.S.A.   </address>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> One of the open problems listed in [ Rivest and  </abstract>::line_number::6
<abstract> Schapire, 1989 ] is whether and how that the  </abstract>::line_number::7
<abstract> copies of L in their algorithm can be combined into one for better performance. This  </abstract>::line_number::8
<abstract> paper describes an algorithm called D that  </abstract>::line_number::9
<abstract> does that combination. The idea is to represent  </abstract>::line_number::10
<abstract> the states of the learned model using observable  </abstract>::line_number::11
<abstract> symbols as well as hidden symbols that are constructed during learning. These hidden symbols are created to reflect the distinct behaviors  </abstract>::line_number::12
<abstract> of the model states. The distinct behaviors are  </abstract>::line_number::13
<abstract> represented as local distinguishing experiments  </abstract>::line_number::14
<abstract> (LDEs) (not to be confused with global distinguishing sequences), and these LDEs are created when the learner's prediction mismatches  </abstract>::line_number::15
<abstract> the actual observation from the unknown machine. To synchronize the model with the environment, these LDEs can also be concatenated to form a homing sequence. It can  </abstract>::line_number::16
<abstract> be shown that D can learn, with probability  </abstract>::line_number::17
<abstract> 1 ~, a model that is an *-approximation of  </abstract>::line_number::18
<abstract> the unknown machine, in a number of actions  </abstract>::line_number::19
<abstract> polynomial in the size of the environment and   </abstract>::line_number::20
<intro>  1 Introduction  </intro>::line_number::21

<title>  Adaptive Agent Tracking in Real-world  </title>::line_number::0
<title> Multi-Agent Domains: A Preliminary Report   </title>::line_number::1
<author>  Milind Tambe, Lewis Johnson and Wei-Min Shen   </author>::line_number::2
<affiliation>  Information Sciences Institute and Computer Science Department  </affiliation>::line_number::3
<affiliation> University of Southern California   </affiliation>::line_number::4
<address>  4676 Admiralty Way, Marina del Rey, CA 90292   </address>::line_number::5
<email>  ftambe,johnson,sheng@isi.edu   </email>::line_number::6
<date>  October 30, 1996   </date>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> Intelligent interaction in multi-agent domains frequently requires an agent to track other  </abstract>::line_number::9
<abstract> agents' mental states: their current goals, beliefs, and intentions. Accuracy in this agent  </abstract>::line_number::10
<abstract> tracking task is critically dependent on the accuracy of the tracker's (tracking agent's) model  </abstract>::line_number::11
<abstract> of the trackee (tracked agent). Unfortunately, in real-world situations, model imperfections  </abstract>::line_number::12
<abstract> arise due to the tracker's resource and information constraints, as well as due to trackees'  </abstract>::line_number::13
<abstract> dynamic behavior modification. While such model imperfections are unavoidable, a tracker  </abstract>::line_number::14
<abstract> must nonetheless attempt to be adaptive in its agent tracking. This article identifies key issues  </abstract>::line_number::15
<abstract> in adaptive agent tracking and presents an approach called DEFT. At its core, DEFT is based  </abstract>::line_number::16
<abstract> on discrimination-based learning. The main idea is to identify the deficiency of a model based  </abstract>::line_number::17
<abstract> on tracking failures, and revise the model by using features that are critical in discriminating  </abstract>::line_number::18
<abstract> successful and failed tracking episodes. Because in real-world situations the set of candidate  </abstract>::line_number::19
<abstract> discriminating features is very large, DEFT relies on knowledge-based focusing to limit the  </abstract>::line_number::20
<abstract> discrimination to those features that it determines were relevant in successful tracking episodes  </abstract>::line_number::21
<abstract> with an autonomous explanation capability as a major source of this knowledge. This article  </abstract>::line_number::22
<abstract> reports on experiments with an implementation of key aspects of DEFT in a complex synthetic  </abstract>::line_number::23
<abstract> air-to-air combat domain.   </abstract>::line_number::24
<page>  +PAGE+  </page>::line_number::25

<note>  To appear in the Proceedings of the Fifteenth National Conference on Artificial Intelligence (AAAI-98)   </note>::line_number::0
<title>  Learning to Predict User Operations for Adaptive Scheduling   </title>::line_number::1
<author>  Melinda T. Gervasio and Wayne Iba and Pat Langley   </author>::line_number::2
<affiliation>  Institute for the Study of Learning and Expertise   </affiliation>::line_number::3
<address>  2164 Staunton Court, Palo Alto, California 94306   </address>::line_number::4
<email>  fgervasio,iba,langleyg@isle.org   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Mixed-initiative systems present the challenge of finding an effective level of interaction between humans  </abstract>::line_number::7
<abstract> and computers. Machine learning presents a promising approach to this problem in the form of systems  </abstract>::line_number::8
<abstract> that automatically adapt their behavior to accommodate different users. In this paper, we present an empirical study of learning user models in an adaptive  </abstract>::line_number::9
<abstract> assistant for crisis scheduling. We describe the problem domain and the scheduling assistant, then present  </abstract>::line_number::10
<abstract> an initial formulation of the adaptive assistant's learning task and the results of a baseline study. After this,  </abstract>::line_number::11
<abstract> we report the results of three subsequent experiments  </abstract>::line_number::12
<abstract> that investigate the effects of problem reformulation  </abstract>::line_number::13
<abstract> and representation augmentation. The results suggest  </abstract>::line_number::14
<abstract> that problem reformulation leads to significantly better accuracy without sacrificing the usefulness of the  </abstract>::line_number::15
<abstract> learned behavior. The studies also raise several interesting issues in adaptive assistance for scheduling.   </abstract>::line_number::16
<intro>  Introduction  </intro>::line_number::17

<note>  To appear in Proceedings of the Second International Conference on AI Planning Systems (1994). Chicago: AAAI Press.   </note>::line_number::0
<title>  Reactive and Automatic Behavior in Plan Execution   </title>::line_number::1
<author>  Pat Langley Wayne Iba Jeff Shrager   </author>::line_number::2
<affiliation>  Robotics Laboratory Recom Technologies Palo Alto Research Center  </affiliation>::line_number::3
<address> Computer Science Dept.   Mail Stop 269-2   Xerox Corporation  </address>::line_number::4
<address> Stanford University NASA Ames Research Center   3333 Coyote Hill Road  </address>::line_number::5
<address> Stanford, CA 94305 Moffett Field, CA 94035 Palo Alto, CA 94304   </address>::line_number::6
<email>  langley@cs.stanford.edu iba@wind.arc.nasa.gov shrager@xerox.com   </email>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> Much of the work on execution assumes that the agent  </abstract>::line_number::9
<abstract> constantly senses the environment, which lets it respond  </abstract>::line_number::10
<abstract> immediately to errors or unexpected events. In this paper, we argue that this purely reactive strategy is only  </abstract>::line_number::11
<abstract> optimal if sensing is inexpensive, and we formulate a simple model of execution that incorporates the cost of sensing. We present an average-case analysis of this model,  </abstract>::line_number::12
<abstract> which shows that in domains with high sensing cost or  </abstract>::line_number::13
<abstract> low probability of error, a more `automatic' strategy -  </abstract>::line_number::14
<abstract> one with long intervals between sensing can lead to  </abstract>::line_number::15
<abstract> less expensive execution. The analysis also shows that  </abstract>::line_number::16
<abstract> the distance to the goal has no effect on the optimal sensing interval. These results run counter to the prevailing  </abstract>::line_number::17
<abstract> wisdom in the planning community, but they promise a  </abstract>::line_number::18
<abstract> more balanced approach to the interleaving of execution  </abstract>::line_number::19
<abstract> and sensing.   </abstract>::line_number::20
<intro>  Reactive and Automatic Execution  </intro>::line_number::21

<title>  Where Do SE-trees Perform? (Part I)   </title>::line_number::0
<author>  Ron Rymon    </author>::line_number::1
<affiliation>  Intelligent Systems Program   </affiliation>::line_number::2
<address>  901 Cathedral of Learning   </address>::line_number::3
<affiliation>  University of Pittsburgh   </affiliation>::line_number::4
<address>  Pittsburgh, PA 15260   </address>::line_number::5
<email>  E-mail: Rymon@ISP.Pitt.edu   </email>::line_number::6
<date>  March 5, 1995   </date>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> As a classifier, a Set Enumeration (SE) tree can be viewed as a generalization of  </abstract>::line_number::9
<abstract> decision trees. We empirically characterize domains in which SE-trees are particularly  </abstract>::line_number::10
<abstract> advantageous relative to decision trees. Specifically, we show that:  </abstract>::line_number::11
<abstract> 1. SE-trees excel in domains in which relatively few examples are available; and  </abstract>::line_number::12

<title>  Advanced Transaction Processing in Multilevel Secure File  </title>::line_number::0
<title> Stores   </title>::line_number::1
<author>  Elisa Bertino Sushil Jajodia Luigi Mancini Indrajit Ray x   </author>::line_number::2
<abstract>  Abstract  </abstract>::line_number::3
<abstract> The concurrency control requirements for transaction processing in a multilevel secure file system are different from those in conventional transaction processing systems.  </abstract>::line_number::4
<abstract> In particular, there is the need to coordinate transactions at different security levels  </abstract>::line_number::5
<abstract> avoiding both potential timing covert channels and the starvation of transactions at  </abstract>::line_number::6
<abstract> higher security levels. Suppose a transaction at a lower security level attempts to write  </abstract>::line_number::7
<abstract> a data item that is being read by a transaction at a higher security level. On the one  </abstract>::line_number::8
<abstract> hand, a timing covert channel arises if the transaction at the lower security level is either  </abstract>::line_number::9
<abstract> delayed or aborted by the scheduler. On the other hand, the transaction at the high  </abstract>::line_number::10
<abstract> security level may be subjected to an indefinite delay if it is forced to abort repeatedly.  </abstract>::line_number::11
<abstract> This paper extends the classical two-phase locking mechanism to multilevel secure  </abstract>::line_number::12
<abstract> file systems. The scheme presented here prevents potential timing covert channels and  </abstract>::line_number::13
<abstract> avoids the abort of higher level transactions nonetheless guaranteeing serializability.  </abstract>::line_number::14
<abstract> The programmer is provided with a powerful set of linguistic constructs that supports  </abstract>::line_number::15
<abstract> exception handling, partial rollback and forward recovery. The proper use of these  </abstract>::line_number::16
<abstract> constructs can prevent the indefinite delay in completion of a higher level transaction,  </abstract>::line_number::17
<abstract> and allows the programmer to trade off starvation with transaction isolation.   </abstract>::line_number::18
<keyword>  Index Terms|Data management system, File system management, Transaction processing, Concurrency control, Two-phase locking, Exception handling, Security kernel,  </keyword>::line_number::19
<keyword> Mandatory access control, Covert channels.   </keyword>::line_number::20
<intro>  1 Introduction  </intro>::line_number::21

<title>  Image Indexing and Retrieval Based on  </title>::line_number::0
<title> Human Perceptual Color Clustering    </title>::line_number::1
<author>  Yihong Gong, Guido Proietti , and Christos Faloutsos    </author>::line_number::2
<affiliation>  Robotics Institute, Carnegie Mellon University   </affiliation>::line_number::3
<address>  5000 Forbes Avenue, Pittsburgh, PA 15213   </address>::line_number::4
<email>  fygong, proietti, christosg@cs.cmu.edu   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> We propose a new image retrieval method based  </abstract>::line_number::7
<abstract> on human perceptual clustering of color images. This  </abstract>::line_number::8
<abstract> color clustering produces for each image a small set of  </abstract>::line_number::9
<abstract> representative colors which captures the color properties of the image, and a small set of sizable contiguous  </abstract>::line_number::10
<abstract> regions which captures the spatial/geometrical properties of the image. The proposed method outperforms  </abstract>::line_number::11
<abstract> the traditional histogram and its improved methods not  </abstract>::line_number::12
<abstract> only with its richer image retrieval capabilities which  </abstract>::line_number::13
<abstract> cover a wider spectrum of user requirements, but also  </abstract>::line_number::14
<abstract> with its powerful indexing scheme which is essential to  </abstract>::line_number::15
<abstract> cater for large scale image databases.   </abstract>::line_number::16
<intro>  1 Introduction  </intro>::line_number::17

<note>  Proceedings of the Thirteenth International Joint Conference on Artificial Intelligence, 1995.   </note>::line_number::0
<title>  Using Introspective Reasoning to Refine Indexing   </title>::line_number::1
<author>  Susan Fox and David B. Leake   </author>::line_number::2
<affiliation>  Computer Science Department   </affiliation>::line_number::3
<address>  Lindley Hall 215   </address>::line_number::4
<affiliation>  Indiana University   </affiliation>::line_number::5
<address>  Bloomington, IN 47405 USA   </address>::line_number::6
<email>  E-mail: fsfox,leakeg@cs.indiana.edu   </email>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> Introspective reasoning about a system's own  </abstract>::line_number::9
<abstract> reasoning processes can form the basis for  </abstract>::line_number::10
<abstract> learning to refine those reasoning processes.  </abstract>::line_number::11
<abstract> The ROBBIE 1 system uses introspective reasoning to monitor the retrieval process of a  </abstract>::line_number::12
<abstract> case-based planner to detect retrieval of inappropriate cases. When retrieval problems  </abstract>::line_number::13
<abstract> are detected, the source of the problems is explained and the explanations are used to determine new indices to use during future case  </abstract>::line_number::14
<abstract> retrieval. The goal of ROBBIE's learning is to  </abstract>::line_number::15
<abstract> increase its ability to focus retrieval on relevant  </abstract>::line_number::16
<abstract> cases, with the aim of simultaneously decreasing the number of candidates to consider and  </abstract>::line_number::17
<abstract> increasing the likelihood that the system will be  </abstract>::line_number::18
<abstract> able to successfully adapt the retrieved cases to  </abstract>::line_number::19
<abstract> fit the current situation. We evaluate the benefits of the approach in light of empirical results  </abstract>::line_number::20
<abstract> examining the effects of index learning in the  </abstract>::line_number::21
<abstract> ROBBIE system.   </abstract>::line_number::22
<intro>  1 Introduction  </intro>::line_number::23

<title>  ACCESSIBILITY UNDER SAMPLING   </title>::line_number::0
<author>  * Eduardo D. Sontag ** Hector J. Sussmann   </author>::line_number::1
<affiliation>  Department of Mathematics  </affiliation>::line_number::2
<affiliation> Rutgers University   </affiliation>::line_number::3
<address>  New Brunswick, NJ 08903   </address>::line_number::4
<abstract>  ABSTRACT  </abstract>::line_number::5
<abstract> This note addresses the following problem: Find conditions under which a continuous-time (nonlinear)  </abstract>::line_number::6
<abstract> system gives rise, under constant rate sampling, to a discrete-time system which satisfies the accessibility  </abstract>::line_number::7
<abstract> property.   </abstract>::line_number::8
<note>  * Research supported in part by US Air Force Grant AFOSR 80-0196  </note>::line_number::9
<note> ** Research supported in part under an NSF Grant   </note>::line_number::10
<page>  +PAGE+  </page>::line_number::11

<title>  NEURAL NETWORKS FOR CONTROL   </title>::line_number::0
<author>  Eduardo D. Sontag   </author>::line_number::1
<affiliation>  Department of Mathematics, Rutgers University   </affiliation>::line_number::2
<address>  New Brunswick, NJ 08903, USA   </address>::line_number::3
<abstract>  Abstract  </abstract>::line_number::4
<abstract> This paper starts by placing neural net techniques in a general nonlinear  </abstract>::line_number::5
<abstract> control framework. After that, several basic theoretical results on networks  </abstract>::line_number::6
<abstract> are surveyed.   </abstract>::line_number::7
<intro>  1 Introduction  </intro>::line_number::8

<title>  Global Stabilization of Linear Discrete-Time Systems  </title>::line_number::0
<title> with Bounded Feedback   </title>::line_number::1
<author>  Yudi Yang   </author>::line_number::2
<affiliation>  IBM,   MD340  </affiliation>::line_number::3
<affiliation> 1311 Mamaroneck Ave  </affiliation>::line_number::4
<affiliation> White Plains, NY 10605   </affiliation>::line_number::5
<email>  yudiy@vnet.ibm.com   </email>::line_number::6
<author>  Eduardo D. Sontag    </author>::line_number::7
<affiliation>  Department of Mathematics  </affiliation>::line_number::8
<affiliation> Rutgers University   </affiliation>::line_number::9
<address>  New Brunswick, NJ 08903   </address>::line_number::10
<email>  sontag@hilbert.rutgers.edu   </email>::line_number::11
<author>  Hector J. Sussmann    </author>::line_number::12
<affiliation>  Department of Mathematics  </affiliation>::line_number::13
<affiliation> Rutgers University   </affiliation>::line_number::14
<address>  New Brunswick, NJ 08903   </address>::line_number::15
<email>  sussmann@hilbert.rutgers.edu   </email>::line_number::16
<abstract>  Abstract  </abstract>::line_number::17
<abstract> This paper deals with the problem of global stabilization of linear discrete time systems by means of  </abstract>::line_number::18
<abstract> bounded feedback laws. The main result proved is an analog of one proved for the continuous time case  </abstract>::line_number::19
<abstract> by the authors, and shows that such stabilization is possible if and only if the system is stabilizable  </abstract>::line_number::20
<abstract> with arbitrary controls and the transition matrix has spectral radius less or equal to one. The proof  </abstract>::line_number::21
<abstract> provides in principle an algorithm for the construction of such feedback laws, which can be implemented  </abstract>::line_number::22
<abstract> either as cascades or as parallel connections ("single hidden layer neural networks") of simple saturation  </abstract>::line_number::23
<abstract> functions.   </abstract>::line_number::24
<intro>  1 Introduction  </intro>::line_number::25

<title>  A Construction of a Cipher  </title>::line_number::0
<title> From a Single Pseudorandom Permutation   </title>::line_number::1
<author>  Shimon Even 1 and Yishay Mansour 2   </author>::line_number::2
<abstract>  Abstract  </abstract>::line_number::3
<abstract> We suggest a scheme for a block cipher which uses only one randomly chosen permutation, F . The key, consisting of two blocks, K 1  </abstract>::line_number::4
<abstract> and K 2 is used in the following way: The message block is XORed  </abstract>::line_number::5
<abstract> with K 1 before applying F , and the outcome is XORed with K 2 , to  </abstract>::line_number::6
<abstract> produce the cryptogram block. We show that the resulting cipher  </abstract>::line_number::7
<abstract> is secure (when the permutation is random or pseudorandom). This  </abstract>::line_number::8
<abstract> removes the need to store, or generate a multitude of permutations.   </abstract>::line_number::9
<affiliation>  1 Comp. Sci. Dept., Technion, Israel Institute of Technology,   Haifa, Israel 32000.  </affiliation>::line_number::10

<title>  ON COMPUTABLE BELIEFS OF RATIONAL MACHINES   </title>::line_number::0
<author>  Nimrod Megiddo    </author>::line_number::1
<abstract>  Abstract. Traditional decision theory has assumed that agents have complete, consistent and readily available beliefs and preferences. Obviously, even if  </abstract>::line_number::2
<abstract> an expert system has complete and consistent beliefs, it cannot have them readily  </abstract>::line_number::3
<abstract> available. Moreover, some beliefs about beliefs are not even approximately computable. It is shown that if all players have complete and consistent beliefs, they  </abstract>::line_number::4
<abstract> can compute approximate beliefs about beliefs of any order by considering events  </abstract>::line_number::5
<abstract> arbitrarily close in some well-defined sense to the ones in question.   </abstract>::line_number::6
<intro>  1. Introduction  </intro>::line_number::7

<title>  Constructing Small Sample Spaces Satisfying Given  </title>::line_number::0
<title> Constraints   </title>::line_number::1
<author>  Daphne Koller    </author>::line_number::2
<email>  e-mail: daphne@cs.stanford.edu   </email>::line_number::3
<author>  Nimrod Megiddo    </author>::line_number::4
<email>  e-mail: megiddo@almaden.ibm.com   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Abstract. The subject of this paper is finding small sample spaces for joint distributions of  </abstract>::line_number::7
<abstract> n discrete random variables. Such distributions  </abstract>::line_number::8
<abstract> are often only required to obey a certain limited set of constraints of the form P r(E) = .  </abstract>::line_number::9
<abstract> We show that the problem of deciding whether  </abstract>::line_number::10
<abstract> there exists any distribution satisfying a given  </abstract>::line_number::11
<abstract> set of constraints is NP-hard. However, if the  </abstract>::line_number::12
<abstract> constraints are consistent, then there exists a distribution satisfying them which is supported by  </abstract>::line_number::13
<abstract> a "small" sample space (one whose cardinality is  </abstract>::line_number::14
<abstract> equal to the number of constraints). For the important case of independence constraints, where  </abstract>::line_number::15
<abstract> the constraints have a certain form and are consistent with a joint distribution of n independent  </abstract>::line_number::16
<abstract> random variables, a small sample space can be  </abstract>::line_number::17
<abstract> constructed in polynomial time. This last result  </abstract>::line_number::18
<abstract> is also useful for de-randomizing algorithms. We  </abstract>::line_number::19
<abstract> demonstrate this technique by an application to  </abstract>::line_number::20
<abstract> the problem of finding large independent sets in  </abstract>::line_number::21
<abstract> sparse hypergraphs.   </abstract>::line_number::22
<affiliation>  Department of Computer Science, Stanford University,   Stanford, CA 94305;   and IBM Almaden Research  </affiliation>::line_number::23
<address> Center,   650 Harry Road, San Jose, CA 95120.   </address>::line_number::24
<affiliation>  IBM Almaden Research Center,   650 Harry Road, San  </affiliation>::line_number::25
<affiliation> Jose, CA 95120;   and School of Mathematical Sciences, Tel  </affiliation>::line_number::26
<address> Aviv University,   Tel Aviv, Israel.   </address>::line_number::27
<note>  Research supported in part by ONR Contract N00014-91-C-0026 and by the Air Force Office of Scientific  </note>::line_number::28
<note> Research (AFSC), under Contract F49620-91-C-0080.  </note>::line_number::29
<note> (Paste copyright notice here.)   </note>::line_number::30
<intro>  1. Introduction  </intro>::line_number::31

<note>  Published in SPIE Proceeding #1667 Practical Holography VI (SPIE, Bellingham, WA, February 1992) paper #04 (in press).   </note>::line_number::0
<title>  Optimization of Hologram Computation for Real-Time Display   </title>::line_number::1
<author>  Mark Lucente   </author>::line_number::2
<affiliation>  MIT Media Laboratory  </affiliation>::line_number::3
<affiliation> Spatial Imaging Group   </affiliation>::line_number::4
<address>  20 Ames St.  </address>::line_number::5
<address> Cambridge, MA 02139  </address>::line_number::6
<address> USA   </address>::line_number::7
<abstract>  ABSTRACT  </abstract>::line_number::8
<abstract> Several methods of increasing the speed and simplicity of the computation of off-axis transmission holograms are  </abstract>::line_number::9
<abstract> presented, with applications to the real-time display of holographic images. A bipolar intensity approach enables a  </abstract>::line_number::10
<abstract> linear summation of interference fringes, a factor of two speed increase, and the elimination of image noise caused by  </abstract>::line_number::11
<abstract> object self-interference. An order of magnitude speed increase is obtained through the use of precomputed look-up  </abstract>::line_number::12
<abstract> tables containing a large array of elemental interference patterns corresponding to point source contributions from  </abstract>::line_number::13
<abstract> each of the possible locations in image space. Results achieved using a data-parallel supercomputer to compute  </abstract>::line_number::14
<abstract> horizontal-parallax-only holographic patterns containing 6 megasamples indicate that an image comprised of 10,000  </abstract>::line_number::15
<abstract> points with arbitrary brightness (grayscale) can be computed in under one second.   </abstract>::line_number::16
<intro>  INTRODUCTION  </intro>::line_number::17

<title>  Authoring and Transcription Tools  </title>::line_number::0
<title> for Speech-Based Hypermedia Systems   </title>::line_number::1
<author>  Barry Arons   </author>::line_number::2
<affiliation>  MIT Media Laboratory   </affiliation>::line_number::3
<address>  20 Ames Street, E15-353  </address>::line_number::4
<address> Cambridge MA, 02139   </address>::line_number::5
<phone>  Phone: +1 617-253-2245   </phone>::line_number::6
<email>  E-mail: barons@media-lab.mit.edu   </email>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> Authoring is usually one of the most difficult parts in the design and implementation of hypertext and  </abstract>::line_number::9
<abstract> hypermedia systems. This problem is exacerbated if the data to be presented by the system is speech,  </abstract>::line_number::10
<abstract> rather than text or graphics, because of the slow and serial nature of speech. This paper provides an  </abstract>::line_number::11
<abstract> overview of speech-only hypermedia, discusses the difficulties associated with authoring databases for  </abstract>::line_number::12
<abstract> such a system, and explores a variety of techniques to assist in the authoring process.   </abstract>::line_number::13
<intro>  Speech-Only Hypermedia  </intro>::line_number::14

<title>  The Evolution of Memory and Mental Models  </title>::line_number::0
<title> Using Genetic Programming   </title>::line_number::1
<author>  Scott Brave   </author>::line_number::2
<affiliation>  Computer Science Dept.  </affiliation>::line_number::3
<affiliation> Stanford University   </affiliation>::line_number::4
<address>  Stanford, California 94305   </address>::line_number::5
<email>  brave@cs.stanford.edu   </email>::line_number::6
<abstract>  ABSTRACT  </abstract>::line_number::7
<abstract> This paper applies genetic programming  </abstract>::line_number::8
<abstract> to the evolution of intelligent agents that  </abstract>::line_number::9
<abstract> gradually build internal representations of  </abstract>::line_number::10
<abstract> their surroundings for later use in  </abstract>::line_number::11
<abstract> planning. The method used allows for the  </abstract>::line_number::12
<abstract> creation of dynamically determined  </abstract>::line_number::13
<abstract> representations that are not pre-designed  </abstract>::line_number::14
<abstract> by the human creator of the system. In an  </abstract>::line_number::15
<abstract> illustrative path-planning problem, evolved  </abstract>::line_number::16
<abstract> programs learn a model of their world and  </abstract>::line_number::17
<abstract> use this internal representation to plan  </abstract>::line_number::18
<abstract> their successive actions. The results show  </abstract>::line_number::19
<abstract> that the proposed method is successful in  </abstract>::line_number::20
<abstract> evolving programs that solve the planning  </abstract>::line_number::21
<abstract> problem and is thus a worthy basis for  </abstract>::line_number::22
<abstract> further investigation.   </abstract>::line_number::23
<intro>  1. Introduction  </intro>::line_number::24

<title>  DESIGNING AN ECOLOGY OF DISTRIBUTED AGENTS   </title>::line_number::0
<author>  by  </author>::line_number::1
<author> Nelson Minar   </author>::line_number::2
<degree>  B.A. Mathematics (1994)  </degree>::line_number::3
<degree> Reed College   </degree>::line_number::4
<email>  &lt;nelson@media.mit.edu&gt;   </email>::line_number::5
<web>  http://www.media.mit.edu/nelson/   </web>::line_number::6
<degree>  Submitted to the Program in Media Arts and Sciences, School of Architecture and  </degree>::line_number::7
<degree> Planning, in partial fulfillment of the requirements for the degree of Master of Science in  </degree>::line_number::8
<degree> Media Arts and Sciences at the Massachusetts Institute of Technology   </degree>::line_number::9
<date>  September 1998   </date>::line_number::10
<note>  c fl1998 Massachusetts Institute of Technology. All rights reserved.   </note>::line_number::11
<note>  Author  </note>::line_number::12
<note> Nelson Minar  </note>::line_number::13
<note> Department of Media Arts and Sciences  </note>::line_number::14
<note> August 7, 1998   </note>::line_number::15
<degree>  Certified by  </degree>::line_number::16
<degree> Pattie Maes  </degree>::line_number::17
<degree> Associate Professor of Media Arts and Sciences  </degree>::line_number::18
<degree> MIT Media Lab  </degree>::line_number::19
<degree> Accepted by  </degree>::line_number::20
<degree> Stephen A. Benton  </degree>::line_number::21
<degree> Professor of Media Arts and Sciences  </degree>::line_number::22
<degree> Chair, Departmental Committee on Graduate Students  </degree>::line_number::23
<degree> Program in Media Arts and Sciences  </degree>::line_number::24
<degree>  </degree>::line_number::25
<page>  +PAGE+  </page>::line_number::26

<title>  State Reconstruction for Determining Predictability  </title>::line_number::0
<title> in Driven Nonlinear Acoustical Systems   </title>::line_number::1
<degree>  Diploma Thesis   </degree>::line_number::2
<affiliation>  MEDIA LABORATORY  </affiliation>::line_number::3
<affiliation> Massachusetts Institute of Technology   </affiliation>::line_number::4
<degree>  Professor Neil Gershenfeld  </degree>::line_number::5
<degree> Institut fur Elektrische Nachrichtentechnik  </degree>::line_number::6
<degree> Rheinisch-Westphalische Technische Hochschule Aachen  </degree>::line_number::7
<degree> Univ. Professor Dr.-Ing. H.D. Luke   </degree>::line_number::8
<author>  by  </author>::line_number::9
<author> Bernd Schoner   </author>::line_number::10
<date>  May 1996   </date>::line_number::11
<page>  +PAGE+  </page>::line_number::12

<title>  Stability of the replica symmetric solution for the information  </title>::line_number::0
<title> conveyed by a neural network   </title>::line_number::1
<author>  Simon Schultzy and Alessandro Trevesz   </author>::line_number::2
<affiliation>  Department of Experimental Psychology,   South Parks Rd.,   University of Oxford,   Oxford OX1  </affiliation>::line_number::3
<affiliation> 3UD, U.K.   </affiliation>::line_number::4
<affiliation>  Programme in Neuroscience, International School for Advanced Studies,   via Beirut 2-4, 34013  </affiliation>::line_number::5
<affiliation> Trieste, Italy   </affiliation>::line_number::6
<date>  (November 7, 1997)   </date>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> The information that a pattern of firing in the output layer of a feedforward  </abstract>::line_number::9
<abstract> network of threshold-linear neurons conveys about the network's inputs is  </abstract>::line_number::10
<abstract> considered. A replica-symmetric solution is found to be stable for all but  </abstract>::line_number::11
<abstract> small amounts of noise. The region of instability depends on the contribution  </abstract>::line_number::12
<abstract> of the threshold and the sparseness: for distributed pattern distributions,  </abstract>::line_number::13
<abstract> the unstable region extends to higher noise variances than for very sparse  </abstract>::line_number::14
<abstract> distributions, for which it is almost nonexistant.   </abstract>::line_number::15
<note>  84.35.+i,89.70.+c,87.10.+e  </note>::line_number::16
<note> Typeset using REVT E X   </note>::line_number::17
<page>  +PAGE+  </page>::line_number::18

<title>  An Optimal Weighting Criterion of Case Indexing for Both Numeric  </title>::line_number::0
<title> and Symbolic Attributes   </title>::line_number::1
<author>  Takao Mohri and Hidehiko Tanaka   </author>::line_number::2
<affiliation>  Information Engineering Course, Faculty of Engineering  </affiliation>::line_number::3
<affiliation> The University of Tokyo   </affiliation>::line_number::4
<address>  7-3-1 Hongo Bunkyo-ku, Tokyo 113, Japan   </address>::line_number::5
<email>  fmohri,tanakag@MTL.T.u-tokyo.ac.jp   </email>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> Indexing of cases is an important topic for Memory-Based Reasoning(MBR). One key problem is how to  </abstract>::line_number::8
<abstract> assign weights to attributes of cases. Although several  </abstract>::line_number::9
<abstract> weighting methods have been proposed, some methods cannot handle numeric attributes directly, so it  </abstract>::line_number::10
<abstract> is necessary to discretize numeric values by classification. Furthermore, existing methods have no theoretical background, so little can be said about optimality.  </abstract>::line_number::11
<abstract> We propose a new weighting method based on a statistical technique called Quantification Method II. It can  </abstract>::line_number::12
<abstract> handle both numeric and symbolic attributes in the  </abstract>::line_number::13
<abstract> same framework. Generated attribute weights are optimal in the sense that they maximize the ratio of variance between classes to variance of all cases. Experiments on several benchmark tests show that in many  </abstract>::line_number::14
<abstract> cases, our method obtains higher accuracies than some  </abstract>::line_number::15
<abstract> other weighting methods. The results also indicate  </abstract>::line_number::16
<abstract> that it can distinguish relevant attributes from irrelevant ones, and can tolerate noisy data.   </abstract>::line_number::17
<intro>  Introduction  </intro>::line_number::18

<title>  A Comparative Study of Reliable Error Estimators  </title>::line_number::0
<title> for Pruning Regression Trees   </title>::line_number::1
<author>  Lus Torgo   </author>::line_number::2
<affiliation>  LIACC/FEP University of Porto   </affiliation>::line_number::3
<address>  R. Campo Alegre, 823, 2 - 4150 PORTO - PORTUGAL   </address>::line_number::4
<phone>  Phone : (+351) 2 607 8830 Fax : (+351) 2 600 3654   </phone>::line_number::5
<email>  email : ltorgo@ncc.up.pt   WWW : http://www.ncc.up.pt/~ltorgo   </email>::line_number::6
<abstract>  Abstract. This paper presents a comparative study of several methods for estimating  </abstract>::line_number::7
<abstract> the true error of treestructured regression models. We evaluate these methods in the  </abstract>::line_number::8
<abstract> context of regression tree pruning. Pruning is considered a key issue for obtaining  </abstract>::line_number::9
<abstract> reliable treestructured models in a real world scenario. The major step of a pruning  </abstract>::line_number::10
<abstract> process consists of obtaining accurate estimates of the error of alternative tree  </abstract>::line_number::11
<abstract> models. We evaluate experimentally four methods for obtaining these estimates in  </abstract>::line_number::12
<abstract> twelve domains. The goal of this evaluation was to characterise the performance of  </abstract>::line_number::13
<abstract> the methods in the task of selecting the best possible tree among the set of trees  </abstract>::line_number::14
<abstract> considered during pruning. The results of the comparison show that certain  </abstract>::line_number::15
<abstract> estimators lead to poor decisions in some domains. The Cross Validation variant that  </abstract>::line_number::16
<abstract> we have proposed achieved the best results on the setups we have considered.   </abstract>::line_number::17
<keyword>  Keywords : Machine Learning, Regression Trees, Pruning methods.   </keyword>::line_number::18
<intro>  1 Introduction  </intro>::line_number::19

<title>  Rule Combination  </title>::line_number::0
<title> in  </title>::line_number::1
<title> Inductive Learning   </title>::line_number::2
<author>  Luis Torgo   </author>::line_number::3
<affiliation>  LIACC   </affiliation>::line_number::4
<address>  R.Campo Alegre, 823 - 2.  </address>::line_number::5
<address> 4100 PORTO  </address>::line_number::6
<address> PORTUGAL   </address>::line_number::7
<phone>  Telf. : (+351) 2 600 16 72 - Ext. 115  </phone>::line_number::8
<phone> Fax : (+351) 2 600 3654   </phone>::line_number::9
<email>  email : ltorgo@ciup1.ncc.up.pt   </email>::line_number::10
<abstract>  Abstract. This paper describes the work on methods for combining rules  </abstract>::line_number::11
<abstract> obtained by machine learning systems. Three methods for obtaining the  </abstract>::line_number::12
<abstract> classification of examples with those rules are compared. The advantages and  </abstract>::line_number::13
<abstract> disadvantages of each method are discussed and the results obtained on three  </abstract>::line_number::14
<abstract> real world domains are commented. The methods compared are: selection of  </abstract>::line_number::15
<abstract> the best rule; PROSPECTOR-like probabilistic approximation for rule  </abstract>::line_number::16
<abstract> combination; and MYCIN-like approximation. Results show significant  </abstract>::line_number::17
<abstract> differences between methods indicating that the problemsolving strategy is  </abstract>::line_number::18
<abstract> important for accuracy of learning systems.   </abstract>::line_number::19
<intro>  1 Introduction  </intro>::line_number::20

<title>  Rule Revision with Recurrent Neural Networks   </title>::line_number::0
<author>  Christian W. Omlin a;b and C.L. Giles a;c   </author>::line_number::1
<affiliation>  a NEC Research Institute,   4 Independence Way, Princeton, New Jersey   </affiliation>::line_number::2
<affiliation>  b Computer Science Department, Rensselaer Polytechnic Institute,   Troy, New York   </affiliation>::line_number::3
<affiliation>  c Institute for Advanced Computer Studies, University of Maryland,   College Park, Maryland   </affiliation>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> Recurrent neural networks readily process, recognize and generate temporal sequences. By encoding  </abstract>::line_number::6
<abstract> grammatical strings as temporal sequences, recurrent neural networks can be trained to behave like deterministic sequential finite-state automata. Algorithms have been developed for extracting grammatical  </abstract>::line_number::7
<abstract> rules from trained networks. Using a simple method for inserting prior knowledge (or rules) into recurrent  </abstract>::line_number::8
<abstract> neural networks, we show that recurrent neural networks are able to perform rule revision. Rule revision  </abstract>::line_number::9
<abstract> is performed by comparing the inserted rules with the rules in the finite-state automata extracted from  </abstract>::line_number::10
<abstract> trained networks. The results from training a recurrent neural network to recognize a known non-trivial,  </abstract>::line_number::11
<abstract> randomly generated regular grammar show that not only do the networks preserve correct rules but that  </abstract>::line_number::12
<abstract> they are able to correct through training inserted rules which were initially incorrect. (By incorrect, we  </abstract>::line_number::13
<abstract> mean that the rules were not the ones in the randomly generated grammar.)   </abstract>::line_number::14
<keyword>  Index Terms: Deterministic Finite-State Automata, Genuine and Incorrect Rules, Knowledge Insertion  </keyword>::line_number::15
<keyword> and Extraction, Recurrent Neural Networks, Regular Languages, Rule Revision.   </keyword>::line_number::16
<note>  Published in IEEE Trans. on Knowledge and Data Engineering, vol. 8, no. 1, p. 183, 1996. Copyright IEEE.   </note>::line_number::17
<page>  +PAGE+  </page>::line_number::18

<title>  A Delay Damage Model Selection Algorithm for NARX  </title>::line_number::0
<title> Neural Networks    </title>::line_number::1
<author>  Tsungnan Lin 1;2y ,C. Lee Giles 1;3 , Bill G. Horne 1 , S.Y. Kung 2   </author>::line_number::2
<affiliation>  1 NEC Research Institute,   4 Independence Way, Princeton, NJ 08540   </affiliation>::line_number::3
<affiliation>  2 Department of Electrical Engineering, Princeton University,   Princeton, NJ 08540   </affiliation>::line_number::4
<affiliation>  3 UMIACS, University of Maryland,   College Park, MD 20742   </affiliation>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> Recurrent neural networks have become popular models for system identification and time  </abstract>::line_number::7
<abstract> series prediction. NARX (Nonlinear AutoRegressive models with eXogenous inputs) neural  </abstract>::line_number::8
<abstract> network models are a popular subclass of recurrent networks and have been used in many  </abstract>::line_number::9
<abstract> applications. Though embedded memory can be found in all recurrent network models, it is  </abstract>::line_number::10
<abstract> particularly prominent in NARX models.  </abstract>::line_number::11
<abstract> We show that using intelligent memory order selection through pruning and good initial  </abstract>::line_number::12
<abstract> heuristics significantly improves the generalization and predictive performance of these nonlinear  </abstract>::line_number::13
<abstract> systems on problems as diverse as grammatical inference and time series prediction.   </abstract>::line_number::14
<keyword>  Keywords: Recurrent neural networks, tapped-delay lines, long-term dependencies,  </keyword>::line_number::15
<keyword> time series, automata, memory, temporal sequences, gradient descent training, latching,  </keyword>::line_number::16
<keyword> NARX networks, auto-regressive, pruning, embedding theory.   </keyword>::line_number::17
<note>  Published in IEEE Transactions on Signal Processing, "Special Issue on Neural Networks," vol. 45, no. 11, p.  </note>::line_number::18
<note> 2719-2730, 1997. Copyright IEEE.  </note>::line_number::19
<affiliation> Current address:   Epson Palo Alto Laboratory,    3145 Porter Drive, Suite 104, Palo Alto, CA 94304   </affiliation>::line_number::20
<page>  +PAGE+  </page>::line_number::21

<title>  What Size Neural Network Gives Optimal Generalization?  </title>::line_number::0
<title> Convergence Properties of Backpropagation   </title>::line_number::1
<author>  Steve Lawrence 1;2 , C. Lee Giles 1 , Ah Chung Tsoi 2   </author>::line_number::2
<email>  flawrence,actg@elec.uq.edu.au, giles@research.nj.nec.com   </email>::line_number::3
<affiliation>  1 NEC Research Institute,   4 Independence Way, Princeton, NJ 08540   </affiliation>::line_number::4
<affiliation>  2 Department of Electrical and Computer Engineering  </affiliation>::line_number::5
<address> University of Queensland,   St. Lucia 4072, Australia   </address>::line_number::6
<pubnum>  Technical Report  </pubnum>::line_number::7
<pubnum> UMIACS-TR-96-22 and CS-TR-3617   </pubnum>::line_number::8
<affiliation>  Institute for Advanced Computer Studies  </affiliation>::line_number::9
<affiliation> University of Maryland   </affiliation>::line_number::10
<address>  College Park, MD 20742   </address>::line_number::11
<date>  June 1996   (Revised August 1996)   </date>::line_number::12
<abstract>  Abstract  </abstract>::line_number::13
<abstract> One of the most important aspects of any machine learning paradigm is how it scales according  </abstract>::line_number::14
<abstract> to problem size and complexity. Using a task with known optimal training error, and a pre-specified  </abstract>::line_number::15
<abstract> maximum number of training updates, we investigate the convergence of the backpropagation algorithm  </abstract>::line_number::16
<abstract> with respect to a) the complexity of the required function approximation, b) the size of the network in  </abstract>::line_number::17
<abstract> relation to the size required for an optimal solution, and c) the degree of noise in the training data. In  </abstract>::line_number::18
<abstract> general, for a) the solution found is worse when the function to be approximated is more complex, for  </abstract>::line_number::19
<abstract> b) oversized networks can result in lower training and generalization error in certain cases, and for c)  </abstract>::line_number::20
<abstract> the use of committee or ensemble techniques can be more beneficial as the level of noise in the training  </abstract>::line_number::21
<abstract> data is increased. For the experiments we performed, we do not obtain the optimal solution in any case.  </abstract>::line_number::22
<abstract> We further support the observation that larger networks can produce better training and generalization  </abstract>::line_number::23
<abstract> error using a face recognition example where a network with many more parameters than training points  </abstract>::line_number::24
<abstract> generalizes better than smaller networks.   </abstract>::line_number::25
<keyword>  Keywords: Local Minima, Generalization, Committees, Ensembles, Convergence, Backpropagation, Smoothness,  </keyword>::line_number::26
<keyword> Network Size, Problem Complexity, Function Approximation, Curse of Dimensionality.   </keyword>::line_number::27
<web>  http://www.neci.nj.nec.com/homepages/lawrence   </web>::line_number::28
<note>  Also with the   Institute for Advanced Computer Studies, University of Maryland,   College Park, MD 20742.   </note>::line_number::29
<web>  http://www.neci.nj.nec.com/homepages/giles.html   </web>::line_number::30
<page>  +PAGE+  </page>::line_number::31

<note>  Appears in the Seventh International World Wide Web Conference, Brisbane, Australia, Elsevier Science, pp.  </note>::line_number::0
<note> 95-105, 1998.   </note>::line_number::1
<title>  Inquirus, the NECI meta search engine   </title>::line_number::2
<author>  Steve Lawrence and C. Lee Giles   </author>::line_number::3
<affiliation>  NEC Research Institute,   </affiliation>::line_number::4
<address>  4 Independence Way, Princeton, NJ 08540, U.S.A.   </address>::line_number::5
<email>  lawrence@research.nj.nec.com and giles@research.nj.nec.com   </email>::line_number::6
<abstract>  Abstract   </abstract>::line_number::7
<abstract> World Wide Web (WWW) search engines (e.g. AltaVista, Infoseek, HotBot, etc.) have a number of  </abstract>::line_number::8
<abstract> deficiencies including: periods of downtime, low coverage of the WWW, inconsistent and inefficient user  </abstract>::line_number::9
<abstract> interfaces, out of date databases, poor relevancy ranking and precision, and difficulties with spamming  </abstract>::line_number::10
<abstract> techniques. Meta search engines have been introduced which address some of these and other difficulties in  </abstract>::line_number::11
<abstract> searching the WWW. However, current meta search engines retain some of these difficulties and may also  </abstract>::line_number::12
<abstract> introduce their own problems (e.g. reduced relevance because one or more of the search engines returns results  </abstract>::line_number::13
<abstract> with poor relevance). We present Inquirus, the NECI meta search engine, which addresses many of the  </abstract>::line_number::14
<abstract> deficiencies in current techniques. Rather than working with the list of documents and summaries returned by  </abstract>::line_number::15
<abstract> search engines, as current meta search engines typically do, the Inquirus meta search engine works by  </abstract>::line_number::16
<abstract> downloading and analyzing the individual documents. The Inquirus meta search engine makes improvements  </abstract>::line_number::17
<abstract> over existing search engines in a number of areas, e.g.: more useful document summaries incorporating query  </abstract>::line_number::18
<abstract> term context, identification of both pages which no longer exist and pages which no longer contain the query  </abstract>::line_number::19
<abstract> terms, advanced detection of duplicate pages, improved document ranking using proximity information,  </abstract>::line_number::20
<abstract> dramatically improved precision for certain queries by using specific expressive forms, and quick jump links  </abstract>::line_number::21
<abstract> and highlighting when viewing the full documents.    </abstract>::line_number::22
<keyword>  Keywords   </keyword>::line_number::23
<keyword> Information retrieval; Search engine; Meta search; Context-based search    </keyword>::line_number::24
<intro>  1. Introduction  </intro>::line_number::25

<title>  On the uniqueness of the convolution theorem for  </title>::line_number::0
<title> the fourier transform   </title>::line_number::1
<author>  Harold S. Stone  </author>::line_number::2
<author> Lance R. Williams   </author>::line_number::3
<affiliation>  NEC Research Institute   </affiliation>::line_number::4
<address>  4 Independence Way  </address>::line_number::5
<address> Princeton, NJ 08540   </address>::line_number::6
<note>  Revision 1,   13 February 1995   </note>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> This paper shows that members of the fourier transform family are the only linear  </abstract>::line_number::9
<abstract> transforms that have a convolution theorem, that is, that can replace O(N 2 ) operations  </abstract>::line_number::10
<abstract> of a convolution in a time domain by O(N) operations in a transform domain. Generally,  </abstract>::line_number::11
<abstract> there is an additional cost to compute the transform itself. Our observation is motivated by  </abstract>::line_number::12
<abstract> recent activity in wavelet and subband decompositions and related spectral analyses, which  </abstract>::line_number::13
<abstract> are attractive alternatives for signal compression applications. A natural question when  </abstract>::line_number::14
<abstract> using such techniques is to determine if convolutions of N -point signals can be calculated  </abstract>::line_number::15
<abstract> with fewer operations in a compressed transform domain than in an uncompressed time  </abstract>::line_number::16
<abstract> domain. The answer is negative for a broad set of assumptions. This paper indicates what  </abstract>::line_number::17
<abstract> assumptions must be relaxed in seeking a linear transform that has a convolution theorem  </abstract>::line_number::18
<abstract> comparable to the convolution theorem for fourier transforms.   </abstract>::line_number::19
<intro>  1 Introduction  </intro>::line_number::20

<note>  Chapter 1   </note>::line_number::0
<title>  Scheduling To Minimize Average Completion Time:  </title>::line_number::1
<title> Off-line and On-line Algorithms   </title>::line_number::2
<author>  Leslie A. Hall David B. Shmoys Joel Wein    </author>::line_number::3
<abstract>  Abstract  </abstract>::line_number::4
<abstract> Time-indexed linear programming formulations have recently received a great deal of attention for their practical  </abstract>::line_number::5
<abstract> effectiveness in solving a number of single-machine scheduling problems. We show that these formulations are also an  </abstract>::line_number::6
<abstract> important tool in the design of approximation algorithms  </abstract>::line_number::7
<abstract> with good worst-case performance guarantees. We give simple new rounding techniques to convert an optimal fractional  </abstract>::line_number::8
<abstract> solution into a feasible schedule for which we can prove a  </abstract>::line_number::9
<abstract> constant-factor performance guarantee, thereby giving the  </abstract>::line_number::10
<abstract> first theoretical evidence of the strength of these relaxations.  </abstract>::line_number::11
<abstract> Specifically, we consider the problem of minimizing the  </abstract>::line_number::12
<abstract> total weighted job completion time on a single machine  </abstract>::line_number::13
<abstract> subject to precedence constraints, and give a polynomial-time (4 + *)-approximation algorithm, for any * &gt; 0;  </abstract>::line_number::14
<abstract> the best previously known guarantee for this problem was  </abstract>::line_number::15
<abstract> superlogarithmic. With somewhat larger constants, we also  </abstract>::line_number::16
<abstract> show how to extend this result to the case with release date  </abstract>::line_number::17
<abstract> constraints, and still more generally, to the case with m  </abstract>::line_number::18
<abstract> identical parallel machines. We give two other techniques for  </abstract>::line_number::19
<abstract> problems in which there are release dates, but no precedence  </abstract>::line_number::20
<abstract> constraints: the first is based on other new LP rounding  </abstract>::line_number::21
<abstract> algorithms, whereas the second is a general framework for  </abstract>::line_number::22
<abstract> designing on-line algorithms to minimize the total weighted  </abstract>::line_number::23
<abstract> completion time.   </abstract>::line_number::24
<intro>  1 Introduction  </intro>::line_number::25

<title>  The Anisotropy in the Cosmic Microwave Background  </title>::line_number::0
<title> At Degree Angular Scales.   </title>::line_number::1
<author>  C. B. Netterfield, N. Jarosik, L. Page, D. Wilkinson, & E. Wollack 1  </author>::line_number::2
<author>  </author>::line_number::3
<affiliation>  Princeton University, Department of Physics,   Jadwin Hall, P.O. Box 708, Princeton, NJ  </affiliation>::line_number::4
<affiliation> 08544   </affiliation>::line_number::5
<note>  Received ; accepted  </note>::line_number::6
<note> Submitted Ap. J. Letters   </note>::line_number::7
<affiliation>  1 NRAO,   2015 Ivy Rd., Charlottesville, VA, 22903   </affiliation>::line_number::8
<page>  +PAGE+  </page>::line_number::9

<note>  BUTP-98/   </note>::line_number::0
<title>  Relation between the simple, guessed,  </title>::line_number::1
<title> and the complicated, derived,  </title>::line_number::2
<title> super-Hamiltonians for shell dynamics   </title>::line_number::3
<author>  P. Hajcek   </author>::line_number::4
<affiliation>  Institute for Theoretical Physics  </affiliation>::line_number::5
<affiliation> University of Bern   </affiliation>::line_number::6
<address>  Sidlerstrasse 5, CH-3012 Bern, Switzerland  </address>::line_number::7
<address>  </address>::line_number::8
<date>  March 1998   </date>::line_number::9
<abstract>  Abstract  </abstract>::line_number::10
<abstract> The Hamiltonian dynamics of spherically symmetric massive thin shells  </abstract>::line_number::11
<abstract> in the general relativity is considered. Two different constraint dynamical  </abstract>::line_number::12
<abstract> systems representing this dynamics have been described recently; the relation  </abstract>::line_number::13
<abstract> of these two systems is investigated. The symmetry groups of both systems  </abstract>::line_number::14
<abstract> are found. The systems are reduced to the presymplectic manifolds 1 and 2 ,  </abstract>::line_number::15
<abstract> lest non-physical aspects like gauge fixings or embeddings in extended phase  </abstract>::line_number::16
<abstract> spaces hinder the argument. The following facts are shown. 1 is three- and 2  </abstract>::line_number::17
<abstract> is five-dimensional; the description of the shell dynamics by 1 is incomplete  </abstract>::line_number::18
<abstract> so that some measurable properties of the shell cannot be predicted. 1 is  </abstract>::line_number::19
<abstract> locally equivalent to a subsystem of 2 and the corresponding local morphisms  </abstract>::line_number::20
<abstract> are not unique, due to the large symmetry group of 2 . The local equivalence  </abstract>::line_number::21
<abstract> explains why the same radial equation results from both systems; what is,  </abstract>::line_number::22
<abstract> however, the physical importance of just local, but not global equivalence of  </abstract>::line_number::23
<abstract> constraint dynamical systems remains unclear.   </abstract>::line_number::24
<page>  +PAGE+  </page>::line_number::25

<title>  Laser Remote Sensing Techniques for Vertical Profiling of Cloud and  </title>::line_number::0
<title> Aerosol Extinction and Back-scatter in the Lower Atmosphere.  </title>::line_number::1
<title> A Brief Review   </title>::line_number::2
<author>  $flfl Papayannis*, E. Fokitis   </author>::line_number::3
<affiliation>  National Technical University of Athens, Physics Department   </affiliation>::line_number::4
<address>  Zografou Campus, 15780 Zografou, GREECE   </address>::line_number::5
<email>  Email: apdlidar@central.ntua.gr   </email>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> In this brief contribution we present the three principal laser remote  </abstract>::line_number::8
<abstract> sensing ( lidar) techniques developed to retrieve the vertical profiling of  </abstract>::line_number::9
<abstract> clouds and of the suspended aerosols (extinction and backscatter) in the  </abstract>::line_number::10
<abstract> lower atmosphere, namely in the 0-7 km altitude region. The three lidar  </abstract>::line_number::11
<abstract> techniques include the elastic ( Klett inversion, Doppler broadening) and  </abstract>::line_number::12
<abstract> the nonelastic backscattering techniques ( Raman scattering). We report  </abstract>::line_number::13
<abstract> on the potential of these techniques, as well as on the typical accuracies  </abstract>::line_number::14
<abstract> of these techniques in the retrieval of the cloud and aerosol extinction  </abstract>::line_number::15
<abstract> and backscatter vertical profiles in the troposphere (0-7 km ASL).   </abstract>::line_number::16
<intro>  flfl Introduction  </intro>::line_number::17

<title>  Designing Distributed Applications  </title>::line_number::0
<title> with Mobile Code Paradigms   </title>::line_number::1
<author>  Antonio Carzaniga   </author>::line_number::2
<affiliation>  Politecnico di Milano   </affiliation>::line_number::3
<address>  Piazza Leonardo da Vinci, 32  </address>::line_number::4
<address> 20133 Milano, Italy   </address>::line_number::5
<phone>  +39-2-2399-3638   </phone>::line_number::6
<email>  carzaniga@elet.polimi.it   </email>::line_number::7
<author>  Gian Pietro Picco   </author>::line_number::8
<affiliation>  Politecnico di Torino   </affiliation>::line_number::9
<address>  Corso Duca degli Abruzzi, 24  </address>::line_number::10
<address> 10129 Torino, Italy   </address>::line_number::11
<phone>  +39-11-564-7008   </phone>::line_number::12
<email>  picco@athena.polito.it   </email>::line_number::13
<author>  Giovanni Vigna   </author>::line_number::14
<affiliation>  Politecnico di Milano   </affiliation>::line_number::15
<address>  Piazza Leonardo da Vinci, 32  </address>::line_number::16
<address> 20133 Milano, Italy   </address>::line_number::17
<phone>  +39-2-2399-3666   </phone>::line_number::18
<email>  vigna@elet.polimi.it   </email>::line_number::19
<abstract>  ABSTRACT  </abstract>::line_number::20
<abstract> Large scale distributed systems are becoming of  </abstract>::line_number::21
<abstract> paramount importance, due to the evolution of technology and to the interest of market. Their development,  </abstract>::line_number::22
<abstract> however, is not yet supported by a sound technological and methodological background, as the results developed for small size distributed systems often do not  </abstract>::line_number::23
<abstract> scale up. Recently, mobile code languages (MCLs) have  </abstract>::line_number::24
<abstract> been proposed as a technological answer to the problem.  </abstract>::line_number::25
<abstract> In this work, we abstract away from the details of these  </abstract>::line_number::26
<abstract> languages by deriving design paradigms exploiting code  </abstract>::line_number::27
<abstract> mobility that are independent of any particular technology. We present such design paradigms, together  </abstract>::line_number::28
<abstract> with a discussion of their features, their application domain, and some hints about the selection of the correct  </abstract>::line_number::29
<abstract> paradigm for a given distributed application.   </abstract>::line_number::30
<keyword>  Keywords  </keyword>::line_number::31
<keyword> Mobile code, design paradigms, distributed applications.   </keyword>::line_number::32
<intro>  INTRODUCTION  </intro>::line_number::33

<note>  Proceedings of the 19th Annual Conference of the Cognitive  </note>::line_number::0
<note> Science Society, Mahwah, NJ:Erlbaum p. 253-258 (1997).  </note>::line_number::1
<note> 253   </note>::line_number::2
<title>  The Dynamics of Prefrontal Cortico-Thalamo-Basal Ganglionic Loops and  </title>::line_number::3
<title> Short-Term Memory Interference Phenomena   </title>::line_number::4
<author>  Jack Gelfand 1 , Vijay Gullapalli 1 , Marcia Johnson 1 , Carol Raye 1 and  </author>::line_number::5
<author> Jeffrey Henderson 2   </author>::line_number::6
<affiliation>  Department of Psychology 1 and Department of Computer Science 2  </affiliation>::line_number::7
<affiliation> Princeton University   </affiliation>::line_number::8
<address>  Princeton, NJ 08544   </address>::line_number::9
<email>  jjg@princeton.edu   </email>::line_number::10
<abstract>  Abstract  </abstract>::line_number::11
<abstract> We present computer simulations of a model of the brain  </abstract>::line_number::12
<abstract> mechanisms operating in short-term memory tasks that are  </abstract>::line_number::13
<abstract> consistent with the anatomy and physiology of prefrontal  </abstract>::line_number::14
<abstract> cortex and associated subcortical structures. These  </abstract>::line_number::15
<abstract> simulations include dynamical processes in thalamo-cortical loops which are used to generate short-term  </abstract>::line_number::16
<abstract> persistent responses in prefrontal cortex. We discuss this  </abstract>::line_number::17
<abstract> model in terms of the representation of input stimuli in  </abstract>::line_number::18
<abstract> cortical association areas and prefrontal short-term  </abstract>::line_number::19
<abstract> memory areas. We report on interference phenomena that  </abstract>::line_number::20
<abstract> result from the interaction of these dynamical processes  </abstract>::line_number::21
<abstract> and lateral projections within cortical columns. These  </abstract>::line_number::22
<abstract> interference phenomena can be used to elucidate the  </abstract>::line_number::23
<abstract> representational organization of short-term memory.   </abstract>::line_number::24
<intro>  Introduction  </intro>::line_number::25

<title>  Uniform Actions in Asynchronous Distributed  </title>::line_number::0
<title> Systems   </title>::line_number::1
<author>  Dalia Malki Ken Birman Aleta Ricciardi Andre Schiper x   </author>::line_number::2
<pubnum>  TR 94-1447   </pubnum>::line_number::3
<affiliation>  Department of Computer Science, Cornell University   </affiliation>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> We develop necessary conditions for the development of asynchronous distributed  </abstract>::line_number::6
<abstract> software that will perform uniform actions (events that if performed by any process,  </abstract>::line_number::7
<abstract> must be performed at all processes). The paper focuses on dynamic uniformity, which  </abstract>::line_number::8
<abstract> differs from the classical problems in that processes continually leave and join the  </abstract>::line_number::9
<abstract> ongoing computation. Here, we first treat a static version of the problem (lacking joins),  </abstract>::line_number::10
<abstract> and then extend the results so obtained to also include joins. Our results demonstrate  </abstract>::line_number::11
<abstract> that in contrast to Consensus, which cannot be solved in asynchronous systems with  </abstract>::line_number::12
<abstract> even a single faulty process, dynamic uniformity can be solved using a failure detection  </abstract>::line_number::13
<abstract> mechanism that makes bounded numbers of mistakes. Because dynamic uniformity  </abstract>::line_number::14
<abstract> arises in systems that maintain safety within a "primary partition" of a network, our  </abstract>::line_number::15
<abstract> paper provides a rigorous characterization of the framework upon which several existing  </abstract>::line_number::16
<abstract> distributed programming environments are based.   </abstract>::line_number::17
<intro>  1 Introduction  </intro>::line_number::18

<title>  On the Boosting Ability of Top-Down  </title>::line_number::0
<title> Decision Tree Learning Algorithms    </title>::line_number::1
<author>  Michael Kearns   </author>::line_number::2
<affiliation>  AT&T Research   </affiliation>::line_number::3
<author>  Yishay Mansour   </author>::line_number::4
<affiliation>  Tel-Aviv University   </affiliation>::line_number::5
<date>  May 1996   </date>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> We analyze the performance of top-down algorithms for decision tree learning, such as those employed  </abstract>::line_number::8
<abstract> by the widely used C4.5 and CART software packages. Our main result is a proof that such algorithms  </abstract>::line_number::9
<abstract> are boosting algorithms. By this we mean that if the functions that label the internal nodes of the  </abstract>::line_number::10
<abstract> decision tree can weakly approximate the unknown target function, then the top-down algorithms we  </abstract>::line_number::11
<abstract> study will amplify this weak advantage to build a tree achieving any desired level of accuracy. The bounds  </abstract>::line_number::12
<abstract> we obtain for this amplification show an interesting dependence on the splitting criterion used by the  </abstract>::line_number::13
<abstract> top-down algorithm. More precisely, if the functions used to label the internal nodes have error 1=2   </abstract>::line_number::14
<abstract> as approximations to the target function, then for the splitting criteria used by CART and C4.5, trees  </abstract>::line_number::15
<abstract> of size (1=*) O(1= 2 * 2 ) and (1=*) O(log(1=*)= 2 ) (respectively) suffice to drive the error below *. Thus (for  </abstract>::line_number::16
<abstract> example), a small constant advantage over random guessing is amplified to any larger constant advantage  </abstract>::line_number::17
<abstract> with trees of constant size. For a new splitting criterion suggested by our analysis, the much stronger  </abstract>::line_number::18
<abstract> bound of (1=*) O(1= 2 ) (which is polynomial in 1=*) is obtained, which is provably optimal for decision  </abstract>::line_number::19
<abstract> tree algorithms. The differing bounds have a natural explanation in terms of concavity properties of the  </abstract>::line_number::20
<abstract> splitting criterion.  </abstract>::line_number::21
<abstract> The primary contribution of this work is in proving that some popular and empirically successful  </abstract>::line_number::22
<abstract> heuristics that are based on first principles meet the criteria of an independently motivated theoretical  </abstract>::line_number::23
<abstract> model.   </abstract>::line_number::24
<note>  A preliminary version of this paper appears in Proceedings of the Twenty-Eighth Annual ACM Symposium on the Theory of  </note>::line_number::25
<author> Computing, pages 459-468, ACM Press, 1996. Authors' addresses:   M. Kearns,   AT&T Research,   600 Mountain Avenue, Room  </author>::line_number::26
<email> 2A-423, Murray Hill, New Jersey 07974;   electronic mail mkearns@research.att.com.   Y. Mansour,   Department of Computer  </email>::line_number::27
<address> Science, Tel Aviv University,   Tel Aviv, Israel;   electronic mail mansour@math.tau.ac.il.   Y. Mansour was supported in part by  </address>::line_number::28
<address> the Israel Science Foundation, administered by the Israel Academy of Science and Humanities, and by a grant of the Israeli  </address>::line_number::29
<address> Ministry of Science and Technology.   </address>::line_number::30
<page>  +PAGE+  </page>::line_number::31

<title>  Update rules for parameter estimation in Bayesian networks   </title>::line_number::0
<author>  Eric Bauer   </author>::line_number::1
<affiliation>  Stanford University   </affiliation>::line_number::2
<email>  ebauer@cs.stanford.edu   </email>::line_number::3
<author>  Daphne Koller   </author>::line_number::4
<affiliation>  Stanford University   </affiliation>::line_number::5
<email>  koller@cs.stanford.edu   </email>::line_number::6
<author>  Yoram Singer   </author>::line_number::7
<affiliation>  AT&T Labs   </affiliation>::line_number::8
<email>  singer@research.att.com   </email>::line_number::9
<abstract>  Abstract  </abstract>::line_number::10
<abstract> This paper re-examines the problem of parameter estimation in Bayesian networks with missing values and  </abstract>::line_number::11
<abstract> hidden variables from the perspective of recent work in  </abstract>::line_number::12
<abstract> on-line learning [12]. We provide a unified framework  </abstract>::line_number::13
<abstract> for parameter estimation that encompasses both on-line  </abstract>::line_number::14
<abstract> learning, where the model is continuously adapted to new  </abstract>::line_number::15
<abstract> data cases as they arrive, and the more traditional batch  </abstract>::line_number::16
<abstract> learning, where a pre-accumulated set of samples is used  </abstract>::line_number::17
<abstract> in a one-time model selection process. In the batch case,  </abstract>::line_number::18
<abstract> our framework encompasses both the gradient projection  </abstract>::line_number::19
<abstract> algorithm [2, 3] and the EM algorithm [14] for Bayesian  </abstract>::line_number::20
<abstract> networks. The framework also leads to new on-line and  </abstract>::line_number::21
<abstract> batch parameter update schemes, including a parameterized version of EM. We provide both empirical and theoretical results indicating that parameterized EM allows  </abstract>::line_number::22
<abstract> faster convergence to the maximum likelihood parame  </abstract>::line_number::23
<abstract> ters than does standard EM.   </abstract>::line_number::24
<intro>  1 Introduction  </intro>::line_number::25

<title>  A Systematic Approach to  </title>::line_number::0
<title> Host Interface Design for High-Speed Networks   </title>::line_number::1
<author>  Peter Steenkiste   </author>::line_number::2
<affiliation>  School of Computer Science  </affiliation>::line_number::3
<affiliation> Carnegie Mellon University   </affiliation>::line_number::4
<address>  5000 Forbes Avenue  </address>::line_number::5
<address> Pittsburgh, Pennsylvania 15213-3891   </address>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> In recent years, networks with media rates of 100 Mbit/second or more have become widely available (FDDI, ATM,  </abstract>::line_number::8
<abstract> HIPPI, ..). However, many computer systems cannot make use of the available bandwidth because of the high  </abstract>::line_number::9
<abstract> overhead associated with network communication. In this paper we review the operations involved in communication over high-speed networks, and we describe optimizations of the network interface that improve network  </abstract>::line_number::10
<abstract> throughput. We also discuss how the payoff of the optimizations is influenced by features of the host software and  </abstract>::line_number::11
<abstract> architecture. This paper is based on our experience with the interfaces for the Nectar and Gigabit Nectar networks.   </abstract>::line_number::12
<keyword>  Keywords: network interfaces, high-speed networks, buffer management, memory hierarchy   </keyword>::line_number::13
<note>  This research was sponsored by the Defense Advanced Research Projects Agency (DOD) under contract number MDA972-90-C-0035, in part by the National Science Foundation and the Defense Advanced  </note>::line_number::14
<note> Research Projects Agency under Cooperative Agreement NCR-8919038 with the Corporation for National Research Initiatives.   </note>::line_number::15
<page>  +PAGE+  </page>::line_number::16

<title>  Automatically Selecting and Using Primary Effects  </title>::line_number::0
<title> in Planning: Theory and Experiments   </title>::line_number::1
<author>  Eugene Fink    </author>::line_number::2
<affiliation>  School of Computer Science  </affiliation>::line_number::3
<affiliation> Carnegie Mellon University   </affiliation>::line_number::4
<address>  Pittsburgh, PA 15213, USA   </address>::line_number::5
<email>  eugene@cs.cmu.edu   </email>::line_number::6
<web>  http://www.cs.cmu.edu/~eugene   </web>::line_number::7
<author>  Qiang Yang    </author>::line_number::8
<affiliation>  School of Computing Science  </affiliation>::line_number::9
<affiliation> Simon Fraser University   </affiliation>::line_number::10
<address>  Burnaby, BC V5A1S6, Canada   </address>::line_number::11
<email>  qyang@cs.sfu.ca   </email>::line_number::12
<web>  http://fas.sfu.ca/cs/people/Faculty/Yang   </web>::line_number::13
<abstract>  Abstract  </abstract>::line_number::14
<abstract> The use of primary effects of operators is an effective approach to improving the  </abstract>::line_number::15
<abstract> efficiency of planning. The characterization of "good" primary effects, however, has  </abstract>::line_number::16
<abstract> remained at an informal level and there have been no algorithms for selecting primary  </abstract>::line_number::17
<abstract> effects of operators.  </abstract>::line_number::18
<abstract> We formalize the use of primary effects in planning and present a criterion for  </abstract>::line_number::19
<abstract> selecting useful primary effects, which guarantees efficiency and completeness. We  </abstract>::line_number::20
<abstract> analyze the efficiency of planning with primary effects and the quality of the resulting  </abstract>::line_number::21
<abstract> plans.  </abstract>::line_number::22
<abstract> We then describe a learning algorithm that automatically selects primary effects  </abstract>::line_number::23
<abstract> and demonstrate, both analytically and empirically, that the use of this algorithm  </abstract>::line_number::24
<abstract> significantly reduces planning time and does not compromise completeness.   </abstract>::line_number::25
<note>  Eugene Fink is supported by Wright Laboratory, Aeronautical Systems Center, Air Force Materiel  </note>::line_number::26
<note> Command, USAF, and the Advanced Research Projects Agency (ARPA) under grant number F33615-93-1-1330. Qiang Yang is supported by Natural Sciences and Engineering Research Council of Canada (NSERC)  </note>::line_number::27
<note> under grant number OGP0184883.   </note>::line_number::28
<page>  +PAGE+  </page>::line_number::29

<title>  DYNAMIC COUPLING OF  </title>::line_number::0
<title> UNDERACTUATED MANIPULATORS   </title>::line_number::1
<author>  Marcel Bergerman Christopher Lee Yangsheng Xu   </author>::line_number::2
<affiliation>  The Robotics Institute  </affiliation>::line_number::3
<affiliation> Carnegie Mellon University   </affiliation>::line_number::4
<address>  Pittsburgh PA 15213   </address>::line_number::5
<email>  -mbergerm|chrislee|xu+-@cs.cmu.edu   </email>::line_number::6
<note>  Proceedings of the 4th IEEE Conference on Control Applications, Albany, USA, Sep. 1995, pp. 500-505.   </note>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> In recent years, researchers have been dedicated to the  </abstract>::line_number::9
<abstract> study of underactuated manipulators which have more  </abstract>::line_number::10
<abstract> joints than control actuators. In previous works,  </abstract>::line_number::11
<abstract> assumptions were made as to the existence of enough  </abstract>::line_number::12
<abstract> dynamic coupling between the active and the passive  </abstract>::line_number::13
<abstract> joints of the manipulator for it to be possible to control  </abstract>::line_number::14
<abstract> the position of the passive joints via the dynamic  </abstract>::line_number::15
<abstract> coupling. In this work, the authors aim to develop an  </abstract>::line_number::16
<abstract> index to measure the dynamic coupling, so as to address  </abstract>::line_number::17
<abstract> when control of the underactuated system is possible,  </abstract>::line_number::18
<abstract> and how the motion and robot configuration can be  </abstract>::line_number::19
<abstract> designed. We discuss extensively the nature of the  </abstract>::line_number::20
<abstract> dynamic coupling and of the proposed coupling index,  </abstract>::line_number::21
<abstract> and their applications in the analysis and design of  </abstract>::line_number::22
<abstract> underactuated systems, and in control and planning of  </abstract>::line_number::23
<abstract> robot motion configuration.   </abstract>::line_number::24
<intro>  1 Introduction  </intro>::line_number::25

<title>  Unification and Polymorphism in Region Inference   </title>::line_number::0
<author>  Mads Tofte,   Department of Computer Science, University of Copenhagen   </author>::line_number::1
<author>  Lars Birkedal,   School of Computer Science, Carnegie Mellon University   </author>::line_number::2
<note>  Dedicated to Robin Milner on the occasion of his 60th birthday.   </note>::line_number::3
<abstract>  Abstract  </abstract>::line_number::4
<abstract> Region Inference is a technique for inferring lifetimes of values in strict, higher-order programming languages such as Standard ML. The purpose of this paper is to show how ideas  </abstract>::line_number::5
<abstract> from Milner's polymorphic type discipline can serve as a basis for region inference, even in the  </abstract>::line_number::6
<abstract> presence of a limited form of polymorphic recursion.   </abstract>::line_number::7
<intro>  1 Introduction  </intro>::line_number::8

<title>  A Linear Spine Calculus   </title>::line_number::0
<author>  Iliano Cervesato and Frank Pfenning 1   </author>::line_number::1
<date>  April 10, 1997   </date>::line_number::2
<pubnum>  CMU-CS-97-125   </pubnum>::line_number::3
<affiliation>  School of Computer Science  </affiliation>::line_number::4
<affiliation> Carnegie Mellon University   </affiliation>::line_number::5
<address>  Pittsburgh, PA 15213   </address>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> We present the spine calculus S !ffi&&gt; as an efficient representation for the linear -calculus !ffi&&gt;  </abstract>::line_number::8
<abstract> which includes intuitionistic functions (!), linear functions (ffi), additive pairing (&), and additive unit  </abstract>::line_number::9
<abstract> (&gt;). S !ffi&&gt; enhances the representation of Church's simply typed -calculus as abstract Bohm trees  </abstract>::line_number::10
<abstract> by enforcing extensionality and by incorporating linear constructs. This approach permits procedures  </abstract>::line_number::11
<abstract> such as unification to retain the efficient head access that characterizes first-order term languages without  </abstract>::line_number::12
<abstract> the overhead of performing -conversions at run time. Potential applications lie in proof search, logic  </abstract>::line_number::13
<abstract> programming, and logical frameworks based on linear type theories. We define the spine calculus, give  </abstract>::line_number::14
<abstract> translations of !ffi&&gt; into S !ffi&&gt; and vice-versa, prove their soundness and completeness with respect  </abstract>::line_number::15
<abstract> to typing and reductions, and show that the spine calculus is strongly normalizing and admits unique  </abstract>::line_number::16
<abstract> canonical forms.   </abstract>::line_number::17
<note>  1 The authors can be reached at iliano@cs.cmu.edu and fp@cs.cmu.edu.  </note>::line_number::18

<title>  Sensor-based Registration and Stacking  </title>::line_number::0
<title> of Electronic Substrate Layers   </title>::line_number::1
<author>  Andrew E. Brennemann, 1 Robert Hammer, 2  </author>::line_number::2
<author> William V. Jecusco II, 3  </author>::line_number::3
<author> and Ralph L. Hollis 4   </author>::line_number::4
<affiliation>  IBM Research Division  </affiliation>::line_number::5
<affiliation> Thomas J. Watson Research Center   </affiliation>::line_number::6
<address>  Yorktown Heights, New York, USA   </address>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> Substrates for most of today's electronic products contain many wiring layers  </abstract>::line_number::9
<abstract> which are individually fabricated, mechanically registered with one another,  </abstract>::line_number::10
<abstract> and laminated together. Alignment tolerances of 0.05 mm to 0.1 mm are  </abstract>::line_number::11
<abstract> sufficient to register the vertical connection pads or vias on each layer. More  </abstract>::line_number::12
<abstract> aggressive designs of the future will, however, require manufacturing accuracies of at least an order of magnitude better to accommodate much finer  </abstract>::line_number::13
<abstract> wire widths and pin spacings. Conventional equipment relying on mechanical  </abstract>::line_number::14
<abstract> "pin-in-slot" methods will likely be inadequate, and a new approach will be  </abstract>::line_number::15
<abstract> needed.  </abstract>::line_number::16
<abstract> We describe here a sensor-based approach for registration and stacking  </abstract>::line_number::17
<abstract> of electronic substrate sublaminates that replaces pin-in-slot methods, yet  </abstract>::line_number::18
<abstract> does not require accurate automation equipment. A pilot work cell for this  </abstract>::line_number::19
<abstract> approach is presented, which has an IBM 7576 coarse-positioning robot, a  </abstract>::line_number::20
<abstract> specially-developed fine-positioning robot, optical sensors, and several routine  </abstract>::line_number::21
<abstract> low accuracy fixtures. A novel robot bracing method was used to minimize  </abstract>::line_number::22
<abstract> environmental vibration during sublaminate stacking.  </abstract>::line_number::23
<abstract> Pairs of test sublaminates, each containing an identical pattern of 100  </abstract>::line_number::24
<abstract> m holes, were aligned, stacked and bonded. The accuracy of registration   </abstract>::line_number::25
<note>  1 Retired,   4 Morningside Court, Ossining, NY, 10562.  </note>::line_number::26

<title>  Tactile Gestures for Human/Robot Interaction   </title>::line_number::0
<author>  Richard M. Voyles, Jr. Pradeep K. Khosla    </author>::line_number::1
<affiliation>  Robotics Ph.D. Program  </affiliation>::line_number::2
<affiliation> Dept. of Electrical and Computer Engineering  </affiliation>::line_number::3
<affiliation> Carnegie Mellon University   </affiliation>::line_number::4
<address>  Pittsburgh, PA 15213   </address>::line_number::5
<note>  7   </note>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> Gesture-Based Programming is a new paradigm to ease  </abstract>::line_number::8
<abstract> the burden of programming robots. By tapping in to the  </abstract>::line_number::9
<abstract> users wealth of experience with contact transitions,  </abstract>::line_number::10
<abstract> compliance, uncertainty and operations sequencing, we  </abstract>::line_number::11
<abstract> hope to provide a more intuitive programming environment  </abstract>::line_number::12
<abstract> for complex, real-world tasks based on the expressiveness  </abstract>::line_number::13
<abstract> of non-verbal communication. A requirement for this to be  </abstract>::line_number::14
<abstract> accomplished is the ability to interpret gestures to infer the  </abstract>::line_number::15
<abstract> intentions behind them. As a first step toward this goal, this  </abstract>::line_number::16
<abstract> paper presents an application of distributed perception for  </abstract>::line_number::17
<abstract> inferring a users intentions by observing tactile gestures.  </abstract>::line_number::18
<abstract> These gestures consist of sparse, inexact, physical  </abstract>::line_number::19
<abstract> nudges applied to the robots end effector for the  </abstract>::line_number::20
<abstract> purpose of modifying its trajectory in free space. A set of  </abstract>::line_number::21
<abstract> independent agents - each with its own local, fuzzified,  </abstract>::line_number::22
<abstract> heuristic model of a particular trajectory parameter -  </abstract>::line_number::23
<abstract> observes data from a wrist force/torque sensor to evaluate  </abstract>::line_number::24
<abstract> the gestures. The agents then independently determine the  </abstract>::line_number::25
<abstract> confidence of their respective findings and distributed  </abstract>::line_number::26
<abstract> arbitration resolves the interpretation through voting.   </abstract>::line_number::27
<intro>  1 Gesture-based programming  </intro>::line_number::28

<title>  Fundamentals of Texture Mapping and Image Warping   </title>::line_number::0
<degree>  Master's Thesis  </degree>::line_number::1
<degree> under the direction of Carlo Sequin   </degree>::line_number::2
<author>  Paul S. Heckbert   </author>::line_number::3
<affiliation>  Dept. of Electrical Engineering and Computer Science  </affiliation>::line_number::4
<address> University of California,   Berkeley, CA 94720   </address>::line_number::5
<note>  c fl1989 Paul S. Heckbert   </note>::line_number::6
<date>  June 17, 1989   </date>::line_number::7
<note>  This Postscript version is missing about 40 paste-up figures. To get a complete version,  </note>::line_number::8
<note> order report no. UCB/CSD 89/516 from the Computer Science Division at the address  </note>::line_number::9
<note> above.   </note>::line_number::10
<page>  +PAGE+  </page>::line_number::11

<title>  Using a DEM to Determine Geospatial Object Trajectories   </title>::line_number::0
<author>  Robert T. Collins, Yanghai Tsin, J. Ryan Miller and Alan J. Lipton   </author>::line_number::1
<affiliation>  The Robotics Institute, Carnegie Mellon University,   Pittsburgh, PA. 15213   </affiliation>::line_number::2
<email>  Email: frcollins,ytsin,jmce,ajlgcs.cmu.edu   </email>::line_number::3
<abstract>  Abstract  </abstract>::line_number::4
<abstract> This paper addresses the estimation of moving object trajectories within a geospatial coordinate system,  </abstract>::line_number::5
<abstract> using a network of video sensors. A high-resolution  </abstract>::line_number::6
<abstract> (0.5m grid spacing) digital elevation map (DEM) has  </abstract>::line_number::7
<abstract> been constructed using a helicopter-based laser range-finder. Object locations are estimated by intersecting viewing rays from a calibrated sensor platform  </abstract>::line_number::8
<abstract> with the DEM. Continuous object trajectories can then  </abstract>::line_number::9
<abstract> be assembled from sequences of single-frame location  </abstract>::line_number::10
<abstract> estimates using spatio-temporal filtering and domain  </abstract>::line_number::11
<abstract> knowledge.   </abstract>::line_number::12
<intro>  1 Introduction  </intro>::line_number::13

<title>  Optimizing ML with Run-Time Code Generation   </title>::line_number::0
<author>  Mark Leone Peter Lee   </author>::line_number::1
<date>  December 1995   </date>::line_number::2
<pubnum>  CMU-CS-95-205   </pubnum>::line_number::3
<affiliation>  School of Computer Science  </affiliation>::line_number::4
<affiliation> Carnegie Mellon University   </affiliation>::line_number::5
<address>  Pittsburgh, PA 15213   </address>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> We describe the design and implementation of a compiler that automatically translates ordinary  </abstract>::line_number::8
<abstract> programs written in a subset of ML into code that generates native code at run time. Run-time  </abstract>::line_number::9
<abstract> code generation can make use of values and invariants that cannot be exploited at compile time,  </abstract>::line_number::10
<abstract> yielding code that is superior to statically optimal code. But the cost of optimizing and generating  </abstract>::line_number::11
<abstract> code at run time can be prohibitive. We demonstrate how compile-time specialization can reduce  </abstract>::line_number::12
<abstract> the cost of run-time code generation by an order of magnitude without greatly affecting code  </abstract>::line_number::13
<abstract> quality. Several benchmark programs are examined, which exhibit an average cost of six cycles per  </abstract>::line_number::14
<abstract> instruction generated at run time.   </abstract>::line_number::15
<note>  The authors' electronic mail addresses are   Mark.Leone@cs.cmu.edu and Peter.Lee@cs.cmu.edu.   </note>::line_number::16
<note>  This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox  </note>::line_number::17
<note> Project: Advanced Langauges for Systems Software," ARPA Order No. C533, issued by ESC/ENS under Contract  </note>::line_number::18
<note> No. F19628-95-C-0050. The views and conclusions contained in this document are those of the authors and should  </note>::line_number::19
<note> not be interpreted as representing the official policies, either expressed or implied, of the Advanced Research Projects  </note>::line_number::20
<note> Agency or the U.S. Government.   </note>::line_number::21
<page>  +PAGE+  </page>::line_number::22

<note>  Formal Aspects of Computing (1998) 3: 1-000  </note>::line_number::0
<note> c 1998 BCS   </note>::line_number::1
<title>  Protective Interface Specifications   </title>::line_number::2
<author>  Gary T. Leavens 2 and Jeannette M. Wing 3   </author>::line_number::3
<affiliation>  1 Department of Computer Science, Iowa State University,   Ames, IA 50011 USA   </affiliation>::line_number::4
<affiliation>  2 Computer Science Department, Carnegie Mellon University,   Pittsburgh, PA 15213 USA   </affiliation>::line_number::5
<abstract>  Abstract. The interface specification of a procedure describes the procedure's  </abstract>::line_number::6
<abstract> behavior using pre- and postconditions. These pre- and postconditions are written using various functions. If some of these functions are partial, or underspec-ified, then the procedure specification may not be well-defined.  </abstract>::line_number::7
<abstract> We show how to write pre- and postcondition specifications that avoid such  </abstract>::line_number::8
<abstract> problems, by having the precondition "protect" the postcondition from the effects  </abstract>::line_number::9
<abstract> of partiality and underspecification. We formalize the notion of protection from  </abstract>::line_number::10
<abstract> partiality in the context of specification languages like VDM-SL and COLD-K.  </abstract>::line_number::11
<abstract> We also formalize the notion of protection from underspecification for the Larch  </abstract>::line_number::12
<abstract> family of specification languages, and for Larch show how one can prove that a  </abstract>::line_number::13
<abstract> procedure specification is protected from the effects of underspecification.   </abstract>::line_number::14
<intro>  1. The Problem  </intro>::line_number::15

<title>  A Field Guide to Boxology:  </title>::line_number::0
<title> Preliminary Classification of Architectural Styles for   </title>::line_number::1
<title> Software Systems   </title>::line_number::2
<author>  Mary Shaw and Paul Clements   </author>::line_number::3
<affiliation>  Computer Science Department and Software Engineering Institute  </affiliation>::line_number::4
<affiliation> Carnegie Mellon University   </affiliation>::line_number::5
<address>  Pittsburgh, PA 15213   </address>::line_number::6
<date>  April 1996   </date>::line_number::7
<abstract>  Abstract:  </abstract>::line_number::8
<abstract> Software architects use a number of commonly-recognized styles  </abstract>::line_number::9
<abstract> to guide their design of system structures. Each of these is appropriate for  </abstract>::line_number::10
<abstract> some classes of problems, but none is suitable for all problems. How, then,  </abstract>::line_number::11
<abstract> does a software designer choose an architecture suitable for the problem at  </abstract>::line_number::12
<abstract> hand? Two kinds of information are required: (1)   </abstract>::line_number::13
<abstract> careful discrimination  </abstract>::line_number::14
<abstract> among  </abstract>::line_number::15
<abstract> the candidate architectures and (2)   </abstract>::line_number::16
<abstract> design guidance  </abstract>::line_number::17
<abstract> on how to make  </abstract>::line_number::18
<abstract> appropriate choices. Here we support   </abstract>::line_number::19
<abstract> careful discrimination  </abstract>::line_number::20
<abstract> with a  </abstract>::line_number::21
<abstract> preliminary classification of styles. We use a two-dimensional classification  </abstract>::line_number::22
<abstract> strategy with control and data issues as the dominant organizing axes. We  </abstract>::line_number::23
<abstract> position the major styles within this space and use finer-grained  </abstract>::line_number::24
<abstract> discriminations to elaborate variations on the styles. This provides a  </abstract>::line_number::25
<abstract> framework for organizing   </abstract>::line_number::26
<abstract> design guidance  </abstract>::line_number::27
<abstract> , which we partially flesh out with  </abstract>::line_number::28
<abstract> rules of thumb.   </abstract>::line_number::29
<keyword>  Keywords:   </keyword>::line_number::30
<keyword> software architecture, architectural styles, style classification/taxonomy   </keyword>::line_number::31
<note>  This document was created with FrameMaker 4.0.4   </note>::line_number::32
<page>  +PAGE+  </page>::line_number::33

<title>  Geometric Sensing of Known Planar Shapes   </title>::line_number::0
<author>  Yan-Bin Jia Michael Erdmann   </author>::line_number::1
<affiliation>  The Robotics Institute and School of Computer Science  </affiliation>::line_number::2
<affiliation> Carnegie Mellon University   </affiliation>::line_number::3
<address>  Pittsburgh, Pennsylvania 15213-3891   </address>::line_number::4
<date>  March 12, 1995   </date>::line_number::5
<note>  International Journal of Robotics Research, 15(4):365-392, 1996.   </note>::line_number::6
<page>  +PAGE+  </page>::line_number::7

<title>  Exploiting Redundancy to Reduce Impact Force   </title>::line_number::0
<author>  Jin-Oh Kim 2 , Matthew Wayne Gertz 3 , and Pradeep K. Khosla 4   </author>::line_number::1
<affiliation>  </affiliation>::line_number::2
<affiliation> Advanced Manipulators Laboratory  </affiliation>::line_number::3
<affiliation> The Robotics Institute  </affiliation>::line_number::4
<affiliation> Carnegie Mellon University   </affiliation>::line_number::5
<address>  Pittsburgh, Pennsylvania 15213   </address>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> This paper presents two strategies for reducing the impact force resulting from the collision of a  </abstract>::line_number::8
<abstract> kinematically redundant manipulator with its environment, where it is assumed that the impact  </abstract>::line_number::9
<abstract> event has some finite duration. The first, an impact control strategy, involves adding torques to the  </abstract>::line_number::10
<abstract> joints of the redundant manipulator to impede motion into the environment with which it is colliding. The second, an impact planning strategy, involves choosing the configuration best suited for  </abstract>::line_number::11
<abstract> minimizing the impact force from an impact event, the approximate location of which is known  </abstract>::line_number::12
<abstract> ahead of time. Simulated results from both strategies are presented and discussed, and it is shown  </abstract>::line_number::13
<abstract> that both are successful in minimizing the impact force resulting from planned and unplanned collisions.   </abstract>::line_number::14
<note>  1. This research was funded in part by NASA (grant number NAG-1-1075), the Dept. of Elec. and Comp. Engineering,  </note>::line_number::15

<title>  Remote Access to Interactive Media   </title>::line_number::0
<author>  Roger B. Dannenberg   </author>::line_number::1
<affiliation>  Carnegie Mellon University, School of Computer Science   </affiliation>::line_number::2
<address>  Pittsburgh, PA 15213 USA   </address>::line_number::3
<email>  Email: dannenberg@cs.cmu.edu   </email>::line_number::4
<abstract>  ABSTRACT  </abstract>::line_number::5
<abstract> Digital interactive media augments interactive computing with video, audio, computer graphics and text,  </abstract>::line_number::6
<abstract> allowing multimedia presentations to be individually and dynamically tailored to the user. Multimedia, and  </abstract>::line_number::7
<abstract> particularly continuous media pose interesting problems for system designers, including those of latency  </abstract>::line_number::8
<abstract> and synchronization. These problems are especially evident when multimedia data is remote and must be  </abstract>::line_number::9
<abstract> accessed via networks. Latency and synchronization issues are discussed, and an integrated system,  </abstract>::line_number::10
<abstract> Tactus, is described. Tactus facilitates the implementation of interactive multimedia computer programs by  </abstract>::line_number::11
<abstract> managing latency and synchronization in the framework of an object-oriented graphical user interface  </abstract>::line_number::12
<abstract> toolkit.   </abstract>::line_number::13
<intro>  1. Introduction  </intro>::line_number::14

<title>  Improving Programming-by-Demonstration With Better Semantic Expression   </title>::line_number::0
<degree>  Thesis Proposal   </degree>::line_number::1
<author>  Richard McDaniel   </author>::line_number::2
<date>  November 14, 1995   </date>::line_number::3
<abstract>  Abstract  </abstract>::line_number::4
<abstract> The domain of applications that can be created with programming-by-demonstration  </abstract>::line_number::5
<abstract> (PBD) can be extended by improving the developers ability to communicate with the system. The  </abstract>::line_number::6
<abstract> techniques provided in this thesis will allow nonprogrammers to create a new variety of complete,  </abstract>::line_number::7
<abstract> interactive applications including many board games and educational software using PBD.  </abstract>::line_number::8
<abstract> A PBD software tool uses inferencing to induce programs by watching the developer demonstrate examples that show how the application should behave. Current systems reduce their scope  </abstract>::line_number::9
<abstract> or resort to having the developer program because they do not provide sufficient ways to express  </abstract>::line_number::10
<abstract> behaviors and the factors that affect them. Therefore, the goal of this thesis is to develop understandable forms of annotated expression and manipulation that help a system infer a broader range  </abstract>::line_number::11
<abstract> of behavior. To test these ideas, this proposal introduces a new system called Gamut that will  </abstract>::line_number::12
<abstract> present the techniques in a unified software tool.  </abstract>::line_number::13
<abstract> The first technique replaces the macro recorder method for demonstrating behavior used  </abstract>::line_number::14
<abstract> in other PBD systems with a technique called nudges. The developer demonstrates by correcting  </abstract>::line_number::15
<abstract> the system at important points during program execution and also using two nudge commands to  </abstract>::line_number::16
<abstract> communicate important situations. First, the Do Something! nudge causes the system to reconsider  </abstract>::line_number::17
<abstract> past learned behavior and try to generalize its knowledge to fit the current situation. Using the  </abstract>::line_number::18
<abstract> Stop That! nudge will point out improper behavior and generate negative examples.  </abstract>::line_number::19
<abstract> Second, Gamut will use a new deck-of-playing-cards metaphor to express concepts such  </abstract>::line_number::20
<abstract> as randomness, sequencing, and data storage. By constructing an appropriate deck, shufing, sorting, and playing cards at key moments, developers can incorporate many effects not available without programming in other systems.  </abstract>::line_number::21
<abstract> Third, Gamut will improve communication about behaviors by making them more manipulable than in previous systems. Behaviors will be represented as small icons near the objects they  </abstract>::line_number::22
<abstract> affect. Using the familiar cut, copy, and paste commands, the developer can transfer behavior  </abstract>::line_number::23
<abstract> between objects. Determining how to make a behavior operate in the new context will be inferred  </abstract>::line_number::24
<abstract> automatically. An objects state from the recent past will be represented as temporal ghosts in  </abstract>::line_number::25
<abstract> which objects become dimmed, translucent images. Many sorts of behavior refer to prior states  </abstract>::line_number::26
<abstract> such as a previous position or an old property value. The ghost objects will allow the developer to  </abstract>::line_number::27
<abstract> make explicit connections.  </abstract>::line_number::28
<abstract> Finally, to reduce the number of options the system must explore, the developer will be  </abstract>::line_number::29
<abstract> able to give hints by highlighting important objects and properties. A new inferencing algorithm  </abstract>::line_number::30
<abstract> will be created that will take advantage of the hints.  </abstract>::line_number::31
<abstract> By combining these techniques, Gamut will provide a rich medium for expressing developer intentions, fostering greater communication between the PBD system and the developer and  </abstract>::line_number::32
<abstract> enabling the developer to create highly interactive software with minimal programming expertise.   </abstract>::line_number::33
<page>  +PAGE+  </page>::line_number::34

<title>  A Whole Sentence  </title>::line_number::0
<title> Maximum Entropy Language Model   </title>::line_number::1
<author>  R. Rosenfeld   </author>::line_number::2
<affiliation>  School of Computer Science  </affiliation>::line_number::3
<affiliation> Carnegie Mellon University   </affiliation>::line_number::4
<address>  Pittsburgh, PA 15213   </address>::line_number::5
<abstract>  Abstract We introduce a new kind of language model, which models whole sentences or utterances directly using the Maximum Entropy  </abstract>::line_number::6
<abstract> paradigm. The new model is conceptually simpler, and more naturally  </abstract>::line_number::7
<abstract> suited to modeling whole-sentence phenomena, than the conditional ME  </abstract>::line_number::8
<abstract> models proposed to date. By avoiding the chain rule, the model treats  </abstract>::line_number::9
<abstract> each sentence or utterance as a "bag of features", where features are  </abstract>::line_number::10
<abstract> arbitrary computable properties of the sentence. The model is unnor-malizable, but this does not interfere with training (done via sampling)  </abstract>::line_number::11
<abstract> or with use. Using the model is computationally straightforward. The  </abstract>::line_number::12
<abstract> main computational cost of training the model is in generating sample  </abstract>::line_number::13
<abstract> sentences from a Gibbs distribution. Interestingly, this cost has different dependencies, and is potentially lower, than in the comparable  </abstract>::line_number::14
<abstract> conditional ME model.   </abstract>::line_number::15
<intro>  1 Motivation  </intro>::line_number::16

<title>  TOLERATING LATENCY THROUGH  </title>::line_number::0
<title> SOFTWARE-CONTROLLED DATA PREFETCHING   </title>::line_number::1
<degree>  a dissertation  </degree>::line_number::2
<affiliation> submitted to the   department of electrical engineering +L + </affiliation>::line_number::3
<degree>  and the committee on graduate studies  </degree>::line_number::4
<affiliation> of   stanford university   </affiliation>::line_number::5
<degree>  in partial fulfillment of the requirements  </degree>::line_number::6
<degree> for the degree of  </degree>::line_number::7
<degree> doctor of philosophy   </degree>::line_number::8
<author>  By  </author>::line_number::9
<author> Todd C. Mowry  </author>::line_number::10
<author>  </author>::line_number::11
<date>  March 1994   </date>::line_number::12
<page>  +PAGE+  </page>::line_number::13

<title>  Tolerating Latency Through Software-Controlled Prefetching  </title>::line_number::0
<title> in Shared-Memory Multiprocessors   </title>::line_number::1
<author>  Todd Mowry and Anoop Gupta   </author>::line_number::2
<affiliation>  Computer Systems Laboratory  </affiliation>::line_number::3
<affiliation> Stanford University, CA 94305   </affiliation>::line_number::4
<note>  To appear in the Journal of Parallel and Distributed Computing, June 1991.   </note>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> The large latency of memory accesses is a major obstacle in obtaining high processor utilization in large  </abstract>::line_number::7
<abstract> scale shared-memory multiprocessors. Although the provision of coherent caches in many recent machines  </abstract>::line_number::8
<abstract> has alleviated the problem somewhat, cache misses still occur frequently enough that they significantly lower  </abstract>::line_number::9
<abstract> performance. In this paper we evaluate the effectiveness of non-binding software-controlled prefetching, as  </abstract>::line_number::10
<abstract> proposed in the Stanford DASH Multiprocessor, to address this problem. The prefetches are non-binding in  </abstract>::line_number::11
<abstract> the sense that the prefetched data is brought to a cache close to the processor, but is still available to the cache  </abstract>::line_number::12
<abstract> coherence protocol to keep it consistent. Prefetching is software-controlled since the program must explicitly  </abstract>::line_number::13
<abstract> issue prefetch instructions.  </abstract>::line_number::14
<abstract> The paper presents results from detailed simulation studies done in the context of the Stanford DASH  </abstract>::line_number::15
<abstract> multiprocessor. Our results show that for applications with regular data access patterns|we evaluate a particle-based simulator used in aeronautics and an LU-decomposition application|prefetching can be very effective.  </abstract>::line_number::16
<abstract> It was easy to augment the applications to do prefetching and it increased their performance by 100-150% when  </abstract>::line_number::17
<abstract> we prefetched directly into the processor's cache. However, for applications with complex data usage patterns,  </abstract>::line_number::18
<abstract> prefetching was less successful. After much effort, the performance of a distributed-time logic simulation  </abstract>::line_number::19
<abstract> application that made extensive use of pointers and linked lists could be increased only by 30%. The paper  </abstract>::line_number::20
<abstract> also evaluates the effects of various hardware optimizations such as separate prefetch issue buffers, prefetching  </abstract>::line_number::21
<abstract> with exclusive ownership, lockup-free caches, and weaker memory consistency models on the performance of  </abstract>::line_number::22
<abstract> prefetching.   </abstract>::line_number::23
<intro>  1 Introduction  </intro>::line_number::24

<title>  Predicting Data Cache Misses in Non-Numeric Applications  </title>::line_number::0
<title> Through Correlation Profiling   </title>::line_number::1
<author>  Todd C. Mowry Chi-Keung Luk   </author>::line_number::2
<affiliation>  Department of Computer Science Department of Computer Science  </affiliation>::line_number::3
<affiliation> Carnegie Mellon University University of Toronto   </affiliation>::line_number::4
<address>  Pittsburgh, PA 15213 Toronto, Canada M5S 3G4   </address>::line_number::5
<email>  tcm@cs.cmu.edu luk@eecg.toronto.edu   </email>::line_number::6
<abstract>  Abstract  </abstract>::line_number::7
<abstract> To maximize the benefit and minimize the overhead of software-based latency tolerance techniques,  </abstract>::line_number::8
<abstract> we would like to apply them precisely to the set of  </abstract>::line_number::9
<abstract> dynamic references that suffer cache misses. Unfortunately, the information provided by the state-of-the-art cache miss profiling technique (summary profiling)  </abstract>::line_number::10
<abstract> is inadequate for references with intermediate miss  </abstract>::line_number::11
<abstract> ratios|it results in either failing to hide latency, or  </abstract>::line_number::12
<abstract> else inserting unnecessary overhead. To overcome this  </abstract>::line_number::13
<abstract> problem, we propose and evaluate a new technique|  </abstract>::line_number::14
<abstract> correlation profiling|which improves predictability by  </abstract>::line_number::15
<abstract> correlating the caching behavior with the associated dynamic context. Our experimental results demonstrate  </abstract>::line_number::16
<abstract> that roughly half of the 22 non-numeric applications  </abstract>::line_number::17
<abstract> we study can potentially enjoy significant reductions  </abstract>::line_number::18
<abstract> in memory stall time by exploiting at least one of the  </abstract>::line_number::19
<abstract> three forms of correlation profiling we consider.   </abstract>::line_number::20
<intro>  1 Introduction  </intro>::line_number::21

<title>  Learning Maps for Indoor Mobile Robot Navigation   </title>::line_number::0
<author>  Sebastian Thrun   </author>::line_number::1
<affiliation>  Computer Science Department and Robotics Institute  </affiliation>::line_number::2
<affiliation> Carnegie Mellon University, Pittsburgh   </affiliation>::line_number::3
<note>  Accepted for Publication in Artificial Intelligence   </note>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> Autonomous robots must be able to learn and maintain models of their environments.  </abstract>::line_number::6
<abstract> Research on mobile robot navigation has produced two major paradigms for mapping indoor  </abstract>::line_number::7
<abstract> environments: grid-based and topological. While grid-based methods produce accurate  </abstract>::line_number::8
<abstract> metric maps, their complexity often prohibits efficient planning and problem solving in  </abstract>::line_number::9
<abstract> large-scale indoor environments. Topological maps, on the other hand, can be used much  </abstract>::line_number::10
<abstract> more efficiently, yet accurate and consistent topological maps are often difficult to learn  </abstract>::line_number::11
<abstract> and maintain in large-scale environments, particularly if momentary sensor data is highly  </abstract>::line_number::12
<abstract> ambiguous. This paper describes an approach that integrates both paradigms: grid-based  </abstract>::line_number::13
<abstract> and topological. Grid-based maps are learned using artificial neural networks and naive  </abstract>::line_number::14
<abstract> Bayesian integration. Topological maps are generated on top of the grid-based maps, by  </abstract>::line_number::15
<abstract> partitioning the latter into coherent regions. By combining both paradigms, the approach  </abstract>::line_number::16
<abstract> presented here gains advantages from both worlds: accuracy/consistency and efficiency.  </abstract>::line_number::17
<abstract> The paper gives results for autonomous exploration, mapping and operation of a mobile  </abstract>::line_number::18
<abstract> robot in populated multi-room environments.   </abstract>::line_number::19
<note>  ? This research was sponsored in part by the National Science Foundation under award IRI-9313367, and by the Wright Laboratory, Aeronautical Systems Center, Air Force Materiel  </note>::line_number::20
<note> Command, USAF, and the Darpa Advanced Research Projects Agency (DARPA) under  </note>::line_number::21
<note> grant number F33615-93-1-1330. We also acknowledge financial support by Daimler Benz  </note>::line_number::22
<note> Corp.  </note>::line_number::23
<note> Preprint submitted to Elsevier Science 15 September 1997   </note>::line_number::24
<page>  +PAGE+  </page>::line_number::25

<title>  WWW Electronic Commerce and Java Trojan Horses   </title>::line_number::0
<author>  J. D. Tygar Alma Whitten   </author>::line_number::1
<email>  tygar@cs.cmu.edu alma@cs.cmu.edu   </email>::line_number::2
<affiliation>  Carnegie Mellon University   </affiliation>::line_number::3
<address>  Pittsburgh, PA 15213   </address>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> World Wide Web electronic commerce applications  </abstract>::line_number::6
<abstract> often require consumers to enter private information (such as credit card numbers) into forms in the  </abstract>::line_number::7
<abstract> browser window. If third parties can insert trojan  </abstract>::line_number::8
<abstract> horse applications onto a consumer's machine, they  </abstract>::line_number::9
<abstract> can monitor keyboard strokes and steal private information.  </abstract>::line_number::10
<abstract> This paper outlines a simple way to accomplish  </abstract>::line_number::11
<abstract> this using Java or similar remote execution facilities.  </abstract>::line_number::12
<abstract> We implemented a simple version of this attack. We  </abstract>::line_number::13
<abstract> give a general method, window personalization, that  </abstract>::line_number::14
<abstract> can thwart or prevent this attack.   </abstract>::line_number::15
<intro>  1 Introduction  </intro>::line_number::16

<title>  Bayesian Analysis of Variance Component Models via Rejection  </title>::line_number::0
<title> Sampling   </title>::line_number::1
<author>  Russell D. Wolfinger   </author>::line_number::2
<affiliation>  SAS Institute Inc.,   SAS Campus Drive,  </affiliation>::line_number::3
<affiliation> Cary, NC 27513, U.S.A.   </affiliation>::line_number::4
<author>  and Robert E. Kass   </author>::line_number::5
<affiliation>  Department of Statistics, Carnegie Mellon University   </affiliation>::line_number::6
<address>  Pittsburgh, PA 15213, U.S.A.   </address>::line_number::7
<date>  January, 1996   </date>::line_number::8
<abstract>  Abstract  </abstract>::line_number::9
<abstract> We consider the usual Normal linear mixed model for "components of variance" from a Bayesian  </abstract>::line_number::10
<abstract> viewpoint. Instead of using Gibbs sampling or other Markov Chain schemes that rely on full  </abstract>::line_number::11
<abstract> conditional distributions, we propose and investigate a method for simulating from posterior distributions based on rejection sampling. The method applies with arbitrary prior distributions but  </abstract>::line_number::12
<abstract> we also employ as a default reference prior a version of Jeffreys's prior based on the integrated  </abstract>::line_number::13
<abstract> ("restricted") likelihood. We demonstrate the ease of application and flexibility of this approach  </abstract>::line_number::14
<abstract> in several familiar settings, even in the presence of unbalanced data. A program implementing the  </abstract>::line_number::15
<abstract> algorithm discussed here will be available in the SAS MIXED procedure.   </abstract>::line_number::16
<keyword>  Some key words: Jeffreys's prior, Mixed model, Posterior simulation, Reference prior, REML.   </keyword>::line_number::17
<page>  +PAGE+  </page>::line_number::18

<title>  Backfitting in Smoothing Spline ANOVA   </title>::line_number::0
<author>  By Zhen Luo 1   </author>::line_number::1
<affiliation>  Pennsylvania State University  </affiliation>::line_number::2
<affiliation>  </affiliation>::line_number::3
<abstract>  Abstract  </abstract>::line_number::4
<abstract> A scheme to compute smoothing spline ANOVA estimates for large data sets with a (near)  </abstract>::line_number::5
<abstract> tensor-product structure is proposed. Such data sets are common in spatial-temporal analysis and  </abstract>::line_number::6
<abstract> image analysis. This scheme combines backfitting algorithm with iterative imputation algorithm in  </abstract>::line_number::7
<abstract> order to save both computational space and time. The convergence of this algorithm and various  </abstract>::line_number::8
<abstract> ways to further speed it up, such as collapsing component functions and successive over-relaxation,  </abstract>::line_number::9
<abstract> are discussed. Issues related to its application in spatial-temporal analysis are discussed too. An  </abstract>::line_number::10
<abstract> application to a global analysis of historical surface temperature data is described.   </abstract>::line_number::11
<intro>  1 Introduction </intro>::line_number::12
<intro>  </intro>::line_number::13

<pubnum>  Working Paper IS-98-01 (Information Systems)   </pubnum>::line_number::0
<affiliation>  Leonard N. Stern School of Business, New York University.   </affiliation>::line_number::1
<note>  In: Proceedings of the IEEE/IAFE/INFORMS Conference on Computational Intelligence for Financial Engineering  </note>::line_number::2
<note> (CIFEr'98, New York, March 1998)   </note>::line_number::3
<web>  http://www.stern.nyu.edu/~aweigend/Research/Papers/TradeStyles   </web>::line_number::4
<title>  Uncovering Hidden Structure in Bond Futures Trading   </title>::line_number::5
<author>  Fei CHEN , Stephen FIGLEWSKI ,  </author>::line_number::6
<author> Jeffrey HEISLER zz , Andreas S. WEIGEND    </author>::line_number::7
<abstract>  Abstract. This study uncovers trading styles in the transaction records of US Treasury bond futures.  </abstract>::line_number::8
<abstract> It uses transaction-by-transaction data from the Commodity Futures Trading Commissions' (CFTC)  </abstract>::line_number::9
<abstract> Computerized Trade Reconstruction (CTR) records. The data set consists of 30 million transaction|  </abstract>::line_number::10
<abstract> the complete US T-bond futures market for 3 years. Each transaction record consists of time (by the  </abstract>::line_number::11
<abstract> minute), price, volume, buy/sell, and an identifier of the specific account.  </abstract>::line_number::12
<abstract> We use statistical clustering techniques to group together trades that are similar. Two sets of  </abstract>::line_number::13
<abstract> assumptions have to be made: (1) What is a trade? We define a trade to begin when an account opens  </abstract>::line_number::14
<abstract> a position, and to end when its position size returns to zero. We describe each trade by several trade-specific variables (e.g., length of trade, maximum position size, opening move, long or short) and several  </abstract>::line_number::15
<abstract> exogenous, market-specific variables (e.g., price, volatility, trading volume). (2) What process generated  </abstract>::line_number::16
<abstract> the data? We assume a mixture of Gaussians. An observed trade is interpreted as a noisy realization of  </abstract>::line_number::17
<abstract> one of the mixture components. This paper assumes identity covariance matrices. Furthermore, each  </abstract>::line_number::18
<abstract> trade is fully assigned to a single cluster. We compare this approach to diagonal and to full covariance  </abstract>::line_number::19
<abstract> structure with probabilistic assignments.  </abstract>::line_number::20
<abstract> Trade profit was held back in the clustering process. It turns out that the clusters differ significantly in their profit and risk characteristics. Using conditional distributions, we summarize features  </abstract>::line_number::21
<abstract> of profitable trading styles and contrast them with losing strategies. We find that profitable styles tend  </abstract>::line_number::22
<abstract> to hold trades longer, trade at higher volatility, and trade earlier in the contracts. We also show how  </abstract>::line_number::23
<abstract> some clusters uncover "technical" traders. Using the information about the individual accounts, the  </abstract>::line_number::24
<abstract> assignments of accounts to clusters are described by entropy, and the transitions of a given account  </abstract>::line_number::25
<abstract> through clusters is modeled by a first order Markov model.   </abstract>::line_number::26
<intro>  1 Motivation and Overview  </intro>::line_number::27

<title>  Problem Solving for Redesign   </title>::line_number::0
<author>  Anita Pos 1 and Hans Akkermans 1 and Remco Straatman 2  </author>::line_number::1
<author>  </author>::line_number::2
<affiliation>  1 University of Twente (UT)  </affiliation>::line_number::3
<affiliation> Department of Computer Science   </affiliation>::line_number::4
<address>  P.O. Box 217  </address>::line_number::5
<address> NL-7500 AE Enschede  </address>::line_number::6
<address> The Netherlands   </address>::line_number::7
<email>  E-mail: fpos,akkermang@cs.utwente.nl   </email>::line_number::8
<affiliation>  2 University of Amsterdam (UvA)  </affiliation>::line_number::9
<affiliation> Department of Social Science Informatics (SWI)   </affiliation>::line_number::10
<address>  Roetersstraat 15  </address>::line_number::11
<address> 1081 WB Amsterdam  </address>::line_number::12
<address> The Netherlands   </address>::line_number::13
<email>  E-mail: remco@swi.psy.uva.nl   </email>::line_number::14
<abstract>  Abstract. A knowledge-level analysis of complex tasks like diagnosis and design can give us a better understanding of these tasks in terms of the goals they  </abstract>::line_number::15
<abstract> aim to achieve and the different ways to achieve these goals. In this paper we  </abstract>::line_number::16
<abstract> present a knowledge-level analysis of redesign. Redesign is viewed as a family of  </abstract>::line_number::17
<abstract> methods based on some common principles, and a number of dimensions along  </abstract>::line_number::18
<abstract> which redesign problem solving methods can vary are distinguished. By examining the problem-solving behavior of a number of existing redesign systems and approaches, we came up with a collection of problem-solving methods for redesign  </abstract>::line_number::19
<abstract> and developed a task-method structure for redesign.  </abstract>::line_number::20
<abstract> In constructing a system for redesign a large number of knowledge-related choices  </abstract>::line_number::21
<abstract> and decisions are made. In order to describe all relevant choices in redesign problem solving, we have to extend the current notion of possible relations between  </abstract>::line_number::22
<abstract> tasks and methods in a PSM architecture. The realization of a task by a problem-solving method, and the decomposition of a problem-solving method into subtasks are the most common relations in a PSM architecture. However, we suggest  </abstract>::line_number::23
<abstract> to extend these relations with the notions of task refinement and method refinement. These notions represent intermediate decisions in a task-method structure,  </abstract>::line_number::24
<abstract> in which the competence of a task or method is refined without immediately paying attention to its operationalization in terms of subtasks. Explicit representation  </abstract>::line_number::25
<abstract> of this kind of intermediate decisions helps to make and represent decisions in a  </abstract>::line_number::26
<abstract> more piecemeal fashion.   </abstract>::line_number::27
<intro>  1 Introduction  </intro>::line_number::28

<title>  An Extensible Protocol Architecture for  </title>::line_number::0
<title> Application-Specific Networking   </title>::line_number::1
<author>  Marc E. Fiuczynski  </author>::line_number::2
<author> Brian N. Bershad   </author>::line_number::3
<email>  fmef,bershadg@cs.washington.edu   </email>::line_number::4
<affiliation>  Department of Computer Science and Engineering  </affiliation>::line_number::5
<affiliation> University of Washington   </affiliation>::line_number::6
<address>  Seattle, WA 98195   </address>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> Plexus is a networking architecture that allows applications to achieve high performance with customized  </abstract>::line_number::9
<abstract> protocols. Application-specific protocols are written in  </abstract>::line_number::10
<abstract> a typesafe language and installed dynamically into the  </abstract>::line_number::11
<abstract> operating system kernel. Because these protocols execute within the kernel, they can access the network  </abstract>::line_number::12
<abstract> interface and other operating system services with low  </abstract>::line_number::13
<abstract> overhead. Protocols implemented with Plexus outperform equivalent protocols implemented on conventional monolithic systems. Plexus runs in the context  </abstract>::line_number::14
<abstract> of the SPIN extensible operating system.   </abstract>::line_number::15
<intro>  1 Introduction  </intro>::line_number::16

<intro> -1  </intro>::line_number::0
<title>  The OPENET Architecture   </title>::line_number::1
<author>  Israel Cidon  </author>::line_number::2
<author> Tony Hsiao  </author>::line_number::3
<author> Asad Khamisy  </author>::line_number::4
<author> Abhay Parekh  </author>::line_number::5
<author> Raphael Rom  </author>::line_number::6
<author> Moshe Sidi   </author>::line_number::7
<pubnum>  SMLI TR-95-37   December 1995   </pubnum>::line_number::8
<abstract>  Abstract:  </abstract>::line_number::9
<abstract> ATM networks will soon be moving from the experimental stage of test-beds to a commercial state  </abstract>::line_number::10
<abstract> where production networks are deployed and operated. The progress of ATM networks appears to be  </abstract>::line_number::11
<abstract> at risk due to the lack of a universal, open, and efficient ATM network control platform. The emerging  </abstract>::line_number::12
<abstract> Private Network to Network Interface (PNNI) standard introduces a control platform that can be used  </abstract>::line_number::13
<abstract> as an internetwork and possibly as an intra-network solution. However, the current PNNI still falls short  </abstract>::line_number::14
<abstract> in providing an acceptable universal solution, due to lack of performance optimizations for intra-network operation, limited functionality, and the lack of open interfaces for future functional extensions  </abstract>::line_number::15
<abstract> and services.  </abstract>::line_number::16
<abstract> OPENET is a common portable, open, and high-performance network control platform based on performance and functional enhancements to the PNNI standard. It is vendor-independent, scalable (in  </abstract>::line_number::17
<abstract> terms of network size and volume of calls), high-performance (in terms of call processing latency and  </abstract>::line_number::18
<abstract> throughput), and extensible (in terms of integrating customer-specific and value-added services).  </abstract>::line_number::19
<abstract> OPENET is designed as an extension to current PNNI so it can serve as a next generation PNNI. It is  </abstract>::line_number::20
<abstract> compatible with PNNI in the internetworking environment allowing large networks to be partitioned  </abstract>::line_number::21
<abstract> according to natural topological or organizational boundaries rather than the artificial use of internet-work interfaces at vendor boundaries.  </abstract>::line_number::22
<abstract> This report describes the OPENET architecture. The major novelties of the OPENET architecture compared to the current PNNI are: the use of native ATM switching for the dissemination of utilization  </abstract>::line_number::23
<abstract> updates; lightweight call setup; take down and modification signaling; a new signaling paradigm that  </abstract>::line_number::24
<abstract> better supports fast reservation and multicast services; and a rich signaling infrastructure that enables  </abstract>::line_number::25
<abstract> the development of augmented services (such as mobility, directory, etc.), leveraging the existing functions of the network control platform.   </abstract>::line_number::26
<email>  email address:  </email>::line_number::27
<email> raphael.rom@eng.sun.com   </email>::line_number::28
<address>  M/S 29-01  </address>::line_number::29
<address> 2550 Garcia Avenue  </address>::line_number::30
<address> Mountain View, CA 94043   </address>::line_number::31
<page>  +PAGE+  </page>::line_number::32

<title>  Two Computer Systems Paradoxes: Serialize-to-Parallelize,  </title>::line_number::0
<title> and Queuing Concurrent-Writes   </title>::line_number::1
<author>  Rimon Orni and Uzi Vishkin    </author>::line_number::2
<date>  September 17, 1995   </date>::line_number::3
<abstract>  Abstract  </abstract>::line_number::4
<abstract> We present and examine the following Serialize-to-Parallelize Paradox: suppose a  </abstract>::line_number::5
<abstract> programmer has a parallel algorithm in mind; the programmer must serialize the algorithm, and is actually trained to suppress its parallelism, while writing code; later,  </abstract>::line_number::6
<abstract> however, compilation and runtime techniques are used to reverse the results of this serialization effort and extract as much parallelism as possible. This work actually provides  </abstract>::line_number::7
<abstract> examples where parallel or parallel-style code enables extracting more parallelism than  </abstract>::line_number::8
<abstract> standard serial code.  </abstract>::line_number::9
<abstract> The "arbitrary concurrent-write" convention is useful in parallel algorithms and programs and appears to be not too difficult to implement in hardware for serial machines.  </abstract>::line_number::10
<abstract> Still, typically concurrent-writes to the same memory location in a program are implemented by queuing the write operations, thus requiring time linear in the number of  </abstract>::line_number::11
<abstract> writes. We call this the Queuing Concurrent-Writes Paradox.  </abstract>::line_number::12
<abstract> Assuming that providing useful, easy-to-program programming paradigms to improve the overall effectiveness of computer systems is of interest, this work is a modest  </abstract>::line_number::13
<abstract> example for applying such software-driven considerations to computer architecture issues. This work may be the first to relate parallel algorithms and parallel programming  </abstract>::line_number::14
<abstract> with the technology of instruction level parallelism.   </abstract>::line_number::15
<intro>  1 Introduction  </intro>::line_number::16

<title>  Mobile Robot Localization using Landmarks   </title>::line_number::0
<author>  Margrit Betke    </author>::line_number::1
<affiliation>  Massachusetts Institute of Technology  </affiliation>::line_number::2
<affiliation> Laboratory for Computer Science   </affiliation>::line_number::3
<address>  Cambridge, MA 02139   </address>::line_number::4
<author>  Leonid Gurvits    </author>::line_number::5
<affiliation>  NEC Research Institute   </affiliation>::line_number::6
<address>  4 Independence Way  </address>::line_number::7
<address> Princeton, NJ 08540   </address>::line_number::8
<date>  April 27, 1995   </date>::line_number::9
<abstract>  Abstract  </abstract>::line_number::10
<abstract> We describe an efficient method for localizing a mobile robot in an environment with landmarks. We assume that the robot can identify these landmarks  </abstract>::line_number::11
<abstract> and measure their bearings relative to each other. Given such noisy input, the  </abstract>::line_number::12
<abstract> algorithm estimates the robot's position and orientation with respect to the  </abstract>::line_number::13
<abstract> map of the environment. The algorithm makes efficient use of our representation of the landmarks by complex numbers. The algorithm runs in time linear  </abstract>::line_number::14
<abstract> in the number of landmarks. We present results of simulations and propose  </abstract>::line_number::15
<abstract> how to use our method for robot navigation.   </abstract>::line_number::16
<keyword>  Keywords: Robotics, mobile robot localization, landmark navigation, map  </keyword>::line_number::17
<keyword> algorithms, triangulation.   </keyword>::line_number::18
<note>  Part of this research was done while the author was visiting Siemens Corporate Research. The  </note>::line_number::19
<email> author is also supported by NSF grant ASC-9217041. Author's net address:   margrit@lcs.mit.edu   </email>::line_number::20
<note>  Author's net address:   gurvits@research.nj.nec.com   </note>::line_number::21
<page>  +PAGE+  </page>::line_number::22

<title>  Learning and Vision Algorithms for  </title>::line_number::0
<title> Robot Navigation   </title>::line_number::1
<author>  by  </author>::line_number::2
<author> Margrit Betke   </author>::line_number::3
<degree>  S.M., Massachusetts Institute of Technology (1992)  </degree>::line_number::4
<affiliation> Submitted to the   Department of Electrical Engineering and Computer  </affiliation>::line_number::5
<degree> Science   in partial fulfillment of the requirements for the degree of  </degree>::line_number::6
<degree> Doctor of Philosophy in Electrical Engineering and Computer Science  </degree>::line_number::7
<degree> at the   </degree>::line_number::8
<affiliation>  MASSACHUSETTS INSTITUTE OF TECHNOLOGY   </affiliation>::line_number::9
<date>  June 1995   </date>::line_number::10
<note>  c Massachusetts Institute of Technology 1995. All rights reserved.   </note>::line_number::11
<degree>  Author : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :   </degree>::line_number::12
<affiliation>  Department of Electrical Engineering and Computer Science   </affiliation>::line_number::13
<date>  May 18, 1995   </date>::line_number::14
<degree>  Certified by : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :  </degree>::line_number::15
<degree> Ronald L. Rivest  </degree>::line_number::16
<degree> Professor  </degree>::line_number::17
<degree> Thesis Supervisor  </degree>::line_number::18
<degree> Accepted by : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :  </degree>::line_number::19
<degree> F. R. Morgenthaler  </degree>::line_number::20
<degree> Chairman, Department Committee on Graduate Students   </degree>::line_number::21
<page>  +PAGE+  </page>::line_number::22

<pubnum>  CAR-TR-858  </pubnum>::line_number::0
<pubnum> N00014-95-1-0521   </pubnum>::line_number::1
<date>  June 1997   </date>::line_number::2
<title>  Information-Conserving Object Recognition   </title>::line_number::3
<author>  Margrit Betke and Nicholas C. Makris :   </author>::line_number::4
<affiliation>  Computer Vision Laboratory  </affiliation>::line_number::5
<affiliation> Center for Automation Research  </affiliation>::line_number::6
<affiliation> University of Maryland   </affiliation>::line_number::7
<address>  College Park, MD 20742-3275   </address>::line_number::8
<abstract>  Abstract  </abstract>::line_number::9
<abstract> The problem of recognizing objects imaged in complex real-world scenes is examined from  </abstract>::line_number::10
<abstract> a parametric perspective using the theory of statistical estimation. A scalar measure of an  </abstract>::line_number::11
<abstract> object's complexity, which is invariant under affine transformation and changes in image noise  </abstract>::line_number::12
<abstract> level, is extracted from the object's Fisher information. The volume of Fisher information is  </abstract>::line_number::13
<abstract> shown to provide an overall statistical measure of the object's recognizability in a particular  </abstract>::line_number::14
<abstract> image, while the complexity provides an intrinsically physical measure that characterizes the  </abstract>::line_number::15
<abstract> object in any image. An information-conserving method is then developed for recognizing  </abstract>::line_number::16
<abstract> an object imaged in a complex scene. Here the term "information-conserving" means that  </abstract>::line_number::17
<abstract> the method uses all the measured data pertinent to the object's recognizability, attains the  </abstract>::line_number::18
<abstract> theoretical lower bound on estimation error for any unbiased estimate of the parameter vector  </abstract>::line_number::19
<abstract> describing the object, and therefore is statistically optimal. This method is then successfully  </abstract>::line_number::20
<abstract> applied to finding objects imaged in thousands of complex real-world scenes.   </abstract>::line_number::21
<note>  The support of the Office of Naval Research under Contract N00014-95-1-0521 is gratefully acknowledged. Author's new address (starting September 1997):   Department of Computer Science, Boston College,   </note>::line_number::22
<address>  Fulton Hall, Chestnut Hill, MA 02167.   Email: betke@cs.bc.edu   </address>::line_number::23
<note>  N. C. Makris was with the Naval Research Laboratory, Washington, DC 20375. His new address is   Department of Ocean Engineering, Massachusetts Institute of Technology,   Cambridge, MA 02138.   </note>::line_number::24
<page>  +PAGE+  </page>::line_number::25

<title>  Augmenting Collective Adaptation  </title>::line_number::0
<title> with Simple Process Agents   </title>::line_number::1
<author>  Thomas Haynes   </author>::line_number::2
<affiliation>  Department of Mathematical & Computer Sciences   </affiliation>::line_number::3
<address>  600 South College Ave.   </address>::line_number::4
<affiliation>  The University of Tulsa   </affiliation>::line_number::5
<address>  Tulsa, OK 74104-3189   </address>::line_number::6
<email>  e-mail: haynes@euler.mcs.utulsa.edu   </email>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> We have integrated the distributed search of genetic  </abstract>::line_number::9
<abstract> programming based systems with collective memory  </abstract>::line_number::10
<abstract> to form a collective adaptation search method. Such a  </abstract>::line_number::11
<abstract> system significantly improves search as problem complexity is increased. However, there is still considerable scope for improvement. In collective adaptation, search agents gather knowledge of their environment and deposit it in a central information repository. Process agents are then able to manipulate that  </abstract>::line_number::12
<abstract> focused knowledge, exploiting the exploration of the  </abstract>::line_number::13
<abstract> search agents. We examine the utility of increasing  </abstract>::line_number::14
<abstract> the capabilities of the centralized process agents.   </abstract>::line_number::15
<intro>  Introduction  </intro>::line_number::16

<title>  Parallel Algorithms   </title>::line_number::0
<author>  Guy E. Blelloch and Bruce M. Maggs   </author>::line_number::1
<affiliation>  School of Computer Science  </affiliation>::line_number::2
<affiliation> Carnegie Mellon University   </affiliation>::line_number::3
<address>  5000 Forbes Avenue  </address>::line_number::4
<address> Pittsburgh, PA 15213   </address>::line_number::5
<email>  guyb@cs.cmu.edu, bmm@cs.cmu.edu   </email>::line_number::6
<intro>  Introduction  </intro>::line_number::7

<title>  Trainable Cataloging for Digital Image Libraries with Applications  </title>::line_number::0
<title> to Volcano Detection   </title>::line_number::1
<author>  M.C. Burl yz , U.M. Fayyad , P. Perona , P. Smyth    </author>::line_number::2
<affiliation>  California Institute of Technology Jet Propulsion Laboratory   </affiliation>::line_number::3
<address>  MS 116-81 | Pasadena, CA 91125 MS 525-3660 | Pasadena, CA 91109   </address>::line_number::4
<email>  fburl,peronag@systems.caltech.edu ffayyad,pjsg@aig.jpl.nasa.gov   </email>::line_number::5
<pubnum>  Computation and Neural Systems Technical Report  </pubnum>::line_number::6
<date> CNS-TR-96-01 |   October 2, 1996   </date>::line_number::7
<abstract>  Abstract  </abstract>::line_number::8
<abstract> Users of digital image libraries are often not interested in image data per se but in derived  </abstract>::line_number::9
<abstract> products such as catalogs of objects of interest. Converting an image database into a usable  </abstract>::line_number::10
<abstract> catalog is typically carried out manually at present. For many larger image databases the  </abstract>::line_number::11
<abstract> purely manual approach is completely impractical. In this paper we describe the development  </abstract>::line_number::12
<abstract> of a trainable cataloging system: the user indicates the location of the objects of interest for  </abstract>::line_number::13
<abstract> a number of training images and the system learns to detect and catalog these objects in the  </abstract>::line_number::14
<abstract> rest of the database. In particular we describe the application of this system to the cataloging  </abstract>::line_number::15
<abstract> of small volcanoes in radar images of Venus. The volcano problem is of interest because of the  </abstract>::line_number::16
<abstract> scale (30,000 images, order of 1 million detectable volcanoes), technical difficulty (the variability  </abstract>::line_number::17
<abstract> of the volcanoes in appearance) and the scientific importance of the problem. The problem of  </abstract>::line_number::18
<abstract> uncertain or subjective ground truth is of fundamental importance in cataloging problems of this  </abstract>::line_number::19
<abstract> nature and is discussed in some detail. Experimental results are presented which quantify and  </abstract>::line_number::20
<abstract> compare the detection performance of the system relative to human detection performance. The  </abstract>::line_number::21
<abstract> paper concludes by discussing the limitations of the proposed system and the lessons learned of  </abstract>::line_number::22
<abstract> general relevance to the development of digital image libraries.   </abstract>::line_number::23
<keyword>  Keywords: digital image libraries, pattern recognition, science data analysis, volcanoes, Venus,  </keyword>::line_number::24
<keyword> SAR, detection, classification, learning, remote sensing   </keyword>::line_number::25
<page>  +PAGE+  </page>::line_number::26

<title>  Perfect Simulation of some Point Processes  </title>::line_number::0
<title> for the Impatient User   </title>::line_number::1
<author>  Elke Thonnes   </author>::line_number::2
<affiliation>  Department of Statistics, University of Warwick    </affiliation>::line_number::3
<date>  February 9, 1998   </date>::line_number::4
<abstract>  Abstract  </abstract>::line_number::5
<abstract> Recently Propp and Wilson [14] have proposed an algorithm, called  </abstract>::line_number::6
<abstract> Coupling from the Past (CFTP), which allows not only an approximate but perfect (i.e. exact) simulation of the stationary distribution  </abstract>::line_number::7
<abstract> of certain finite state space Markov chains. Perfect Sampling using  </abstract>::line_number::8
<abstract> CFTP has been successfully extended to the context of point processes, amongst other authors, by Haggstrom et al. [5]. In [5] Gibbs  </abstract>::line_number::9
<abstract> sampling is applied to a bivariate point process, the penetrable spheres  </abstract>::line_number::10
<abstract> mixture model [19]. However, in general the running time of CFTP  </abstract>::line_number::11
<abstract> in terms of number of transitions is not independent of the state sampled. Thus an impatient user who aborts long runs may introduce a  </abstract>::line_number::12
<abstract> subtle bias, the user impatience bias. Fill [3] introduced an exact sampling algorithm for finite state space Markov chains which, in contrast  </abstract>::line_number::13
<abstract> to CFTP, is unbiased for user impatience. Fill's algorithm is a form  </abstract>::line_number::14
<abstract> of rejection sampling and similar to CFTP requires sufficient mono-tonicity properties of the transition kernel used. We show how Fill's  </abstract>::line_number::15
<abstract> version of rejection sampling can be extended to an infinite state space  </abstract>::line_number::16
<abstract> context to produce an exact sample of the penetrable spheres mixture  </abstract>::line_number::17
<abstract> process and related models. Following [5] we use Gibbs sampling and  </abstract>::line_number::18
<abstract> make use of the partial order of the mixture model state space. Thus   </abstract>::line_number::19
<note>  Research supported by EPSRC earmarked studentship and University of Warwick  </note>::line_number::20
<affiliation> graduate award. Postal address:   Dept. of Statistics, University of Warwick,   Coventry,  </affiliation>::line_number::21
<affiliation> CV4 7AL, UK   </affiliation>::line_number::22
<page>  +PAGE+  </page>::line_number::23

<note>  127   </note>::line_number::0
<title>  Progress for Local Variables in UNITY   </title>::line_number::1
<author>  Rob Udink and Ted Herman and Joost Kok   </author>::line_number::2
<affiliation>  Department of Computer Science, Utrecht University,   </affiliation>::line_number::3
<address>  P.O. Box 80089, 3508 TB Utrecht, The Netherlands   </address>::line_number::4
<email>  e-mail: frob,ted,joostg@cs.ruu.nl   </email>::line_number::5
<abstract>  A new notion of refinement for UNITY programs with local variables is defined. This  </abstract>::line_number::6
<abstract> notion is compositional in the following sense: programs can be refined in arbitrary contexts such that all unless and leadsto properties (i.e. temporal properties for both safety  </abstract>::line_number::7
<abstract> and progress) of the composition are preserved. The refinement notion is based on preservation of a new kind of UNITY-like property that takes into account the locality of  </abstract>::line_number::8
<abstract> variables. We do a small case study about registers.   </abstract>::line_number::9
<note>  Keyword Codes: F.3.1   </note>::line_number::10
<keyword>  Keywords: Specifying and Verifying and Reasoning about Programs   </keyword>::line_number::11
<intro>  1. INTRODUCTION  </intro>::line_number::12

<title>  On the Relation Between Unity Properties  </title>::line_number::0
<title> and Sequences of States   </title>::line_number::1
<author>  R.T. Udink    </author>::line_number::2
<affiliation>  Utrecht University, Department of Computer Science,   </affiliation>::line_number::3
<address>  P.O. Box 80.089, 3508 TB Utrecht, the Netherlands   </address>::line_number::4
<author>  J.N. Kok   </author>::line_number::5
<affiliation>  Utrecht University, Department of Computer Science,   </affiliation>::line_number::6
<address>  P.O. Box 80.089, 3508 TB Utrecht, the Netherlands   </address>::line_number::7
<abstract>  ABSTRACT Stepwise refinement of programs has proven to be a suitable  </abstract>::line_number::8
<abstract> method for developing parallel and distributed programs. We examine and compare a  </abstract>::line_number::9
<abstract> number of different notions of program refinement for Unity. Two of these notions are  </abstract>::line_number::10
<abstract> based on execution sequences. Refinement corresponds to the reduction of the set of execution sequences, i.e. reducing the amount of nondeterminism. The other refinement  </abstract>::line_number::11
<abstract> notions are based on Unity properties as introduced by Chandy and Misra. The Unity approach is to refine specifications. Although it has proven a suitable formalism for deriving  </abstract>::line_number::12
<abstract> algorithms, it seems less suitable for handling implementation details. Following Sanders  </abstract>::line_number::13
<abstract> and Singh, we formalize program refinement in the Unity framework as the preservation  </abstract>::line_number::14
<abstract> of Unity properties. We show that Unity properties are not powerful enough to characterize execution sequences. As a consequence, the notion of property-preserving refinement  </abstract>::line_number::15
<abstract> differs from the notion of reducing the set of execution sequences.   </abstract>::line_number::16
<keyword>  Keywords Semantic models, Unity, program refinement.   </keyword>::line_number::17
<note>  CONTENTS  </note>::line_number::18
<note> 0 Introduction  </note>::line_number::19

<title>  Adaptive Information Filtering using Evolutionary Computation   </title>::line_number::0
<author>  D.R. Tauritz & J.N. Kok & I.G. Sprinkhuizen-Kuyper   </author>::line_number::1
<affiliation>  Department of Computer Science, Leiden University   </affiliation>::line_number::2
<address>  P.O. Box 9512, 2300 RA Leiden, The Netherlands   </address>::line_number::3
<intro>  1 Introduction  </intro>::line_number::4

<title>  SuperWeb: Towards a Global Web-Based Parallel Computing Infrastructure   </title>::line_number::0
<author>  Albert D. Alexandrov, Maximilian Ibel, Klaus E. Schauser, and Chris J. Scheiman   </author>::line_number::1
<affiliation>  Department of Computer Science  </affiliation>::line_number::2
<affiliation> University of California, Santa Barbara   </affiliation>::line_number::3
<address>  Santa Barbara, CA 93106   </address>::line_number::4
<email>  fberto,ibel,schauser,chrissg@cs.ucsb.edu   </email>::line_number::5
<abstract>  Abstract  </abstract>::line_number::6
<abstract> The Internet, best known by most users as the WorldWide-Web, continues to expand at an amazing pace. We  </abstract>::line_number::7
<abstract> propose a new infrastructure to harness the combined resources, such as CPU cycles or disk storage, and make them  </abstract>::line_number::8
<abstract> available to everyone interested. This infrastructure has the  </abstract>::line_number::9
<abstract> potential for solving parallel supercomputing applications  </abstract>::line_number::10
<abstract> involving thousands of cooperating components. Our approach is based on recent advances in Internet connectivity  </abstract>::line_number::11
<abstract> and the implementation of safe distributed computing embodied in languages such as Java.  </abstract>::line_number::12
<abstract> We developed a prototype of a global computing infrastructure, called SuperWeb, that consists of hosts, brokers  </abstract>::line_number::13
<abstract> and clients. Hosts register a fraction of their computing resources (CPU time, memory, bandwidth, disk space) with  </abstract>::line_number::14
<abstract> resource brokers. Client computations are then mapped by  </abstract>::line_number::15
<abstract> the broker onto the registered resources. We examine an economic model for trading computing resources, and discuss  </abstract>::line_number::16
<abstract> several technical challenges associated with such a global  </abstract>::line_number::17
<abstract> computing environment.   </abstract>::line_number::18
<keyword>  Keywords: Global computing, Internet, Java, WorldWide-Web, massively parallel computing, secure computing,  </keyword>::line_number::19
<keyword> microeconomic model.   </keyword>::line_number::20
<intro>  1 Introduction  </intro>::line_number::21

